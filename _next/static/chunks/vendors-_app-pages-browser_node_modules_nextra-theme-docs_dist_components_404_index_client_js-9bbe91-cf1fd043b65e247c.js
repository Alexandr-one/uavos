(self["webpackJsonpNextraApp"] = self["webpackJsonpNextraApp"] || []).push([["vendors-_app-pages-browser_node_modules_nextra-theme-docs_dist_components_404_index_client_js-9bbe91"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/api/link.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* reexport default from dynamic */ _client_link__WEBPACK_IMPORTED_MODULE_0___default.a; }
/* harmony export */ });
/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/link.js");
/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_link__WEBPACK_IMPORTED_MODULE_0__);



//# sourceMappingURL=link.js.map

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js");
/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (checked) */ if(__webpack_require__.o(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__, "usePathname")) __webpack_require__.d(__webpack_exports__, { usePathname: function() { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__.usePathname; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__, "useRouter")) __webpack_require__.d(__webpack_exports__, { useRouter: function() { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__.useRouter; } });


//# sourceMappingURL=navigation.js.map

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var _global_process, _global_process1;
module.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === "object" ? __webpack_require__.g.process : __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js");

//# sourceMappingURL=process.js.map

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/add-locale.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "addLocale", ({
    enumerable: true,
    get: function() {
        return addLocale;
    }
}));
const _normalizetrailingslash = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js");
const addLocale = function(path) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        args[_key - 1] = arguments[_key];
    }
    if (false) {}
    return path;
};
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=add-locale.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getDomainLocale", ({
    enumerable: true,
    get: function() {
        return getDomainLocale;
    }
}));
const _normalizetrailingslash = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js");
const basePath = (/* unused pure expression or super */ null && ("/uavos" || 0));
function getDomainLocale(path, locale, locales, domainLocales) {
    if (false) {} else {
        return false;
    }
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=get-domain-locale.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/image-component.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "Image", ({
    enumerable: true,
    get: function() {
        return Image;
    }
}));
const _interop_require_default = __webpack_require__("(app-pages-browser)/../../node_modules/@swc/helpers/esm/_interop_require_default.js");
const _interop_require_wildcard = __webpack_require__("(app-pages-browser)/../../node_modules/@swc/helpers/esm/_interop_require_wildcard.js");
const _jsxruntime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js"));
const _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js"));
const _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js"));
const _getimgprops = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js");
const _imageconfig = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js");
const _imageconfigcontextsharedruntime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js");
const _warnonce = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js");
const _routercontextsharedruntime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js"));
// This is replaced by webpack define plugin
const configEnv = {"deviceSizes":[640,750,828,1080,1200,1920,2048,3840],"imageSizes":[16,32,48,64,96,128,256,384],"path":"/uavos/_next/image/","loader":"default","dangerouslyAllowSVG":false,"unoptimized":true};
if (typeof window === "undefined") {
    globalThis.__NEXT_IMAGE_IMPORTED = true;
}
// See https://stackoverflow.com/q/39777833/266535 for why we use this ref
// handler instead of the img's onLoad attribute.
function handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {
    const src = img == null ? void 0 : img.src;
    if (!img || img["data-loaded-src"] === src) {
        return;
    }
    img["data-loaded-src"] = src;
    const p = "decode" in img ? img.decode() : Promise.resolve();
    p.catch(()=>{}).then(()=>{
        if (!img.parentElement || !img.isConnected) {
            // Exit early in case of race condition:
            // - onload() is called
            // - decode() is called but incomplete
            // - unmount is called
            // - decode() completes
            return;
        }
        if (placeholder !== "empty") {
            setBlurComplete(true);
        }
        if (onLoadRef == null ? void 0 : onLoadRef.current) {
            // Since we don't have the SyntheticEvent here,
            // we must create one with the same shape.
            // See https://reactjs.org/docs/events.html
            const event = new Event("load");
            Object.defineProperty(event, "target", {
                writable: false,
                value: img
            });
            let prevented = false;
            let stopped = false;
            onLoadRef.current({
                ...event,
                nativeEvent: event,
                currentTarget: img,
                target: img,
                isDefaultPrevented: ()=>prevented,
                isPropagationStopped: ()=>stopped,
                persist: ()=>{},
                preventDefault: ()=>{
                    prevented = true;
                    event.preventDefault();
                },
                stopPropagation: ()=>{
                    stopped = true;
                    event.stopPropagation();
                }
            });
        }
        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {
            onLoadingCompleteRef.current(img);
        }
        if (false) {}
    });
}
function getDynamicProps(fetchPriority) {
    if (Boolean(_react.use)) {
        // In React 19.0.0 or newer, we must use camelCase
        // prop to avoid "Warning: Invalid DOM property".
        // See https://github.com/facebook/react/pull/25927
        return {
            fetchPriority
        };
    }
    // In React 18.2.0 or older, we must use lowercase prop
    // to avoid "Warning: Invalid DOM property".
    return {
        fetchpriority: fetchPriority
    };
}
const ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{
    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest } = param;
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
        ...rest,
        ...getDynamicProps(fetchPriority),
        // It's intended to keep `loading` before `src` because React updates
        // props in order which causes Safari/Firefox to not lazy load properly.
        // See https://github.com/facebook/react/issues/25883
        loading: loading,
        width: width,
        height: height,
        decoding: decoding,
        "data-nimg": fill ? "fill" : "1",
        className: className,
        style: style,
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        sizes: sizes,
        srcSet: srcSet,
        src: src,
        ref: (0, _react.useCallback)((img)=>{
            if (forwardedRef) {
                if (typeof forwardedRef === "function") forwardedRef(img);
                else if (typeof forwardedRef === "object") {
                    // @ts-ignore - .current is read only it's usually assigned by react internally
                    forwardedRef.current = img;
                }
            }
            if (!img) {
                return;
            }
            if (onError) {
                // If the image has an error before react hydrates, then the error is lost.
                // The workaround is to wait until the image is mounted which is after hydration,
                // then we set the src again to trigger the error handler (if there was an error).
                // eslint-disable-next-line no-self-assign
                img.src = img.src;
            }
            if (false) {}
            if (img.complete) {
                handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);
            }
        }, [
            src,
            placeholder,
            onLoadRef,
            onLoadingCompleteRef,
            setBlurComplete,
            onError,
            unoptimized,
            sizesInput,
            forwardedRef
        ]),
        onLoad: (event)=>{
            const img = event.currentTarget;
            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);
        },
        onError: (event)=>{
            // if the real image fails to load, this will ensure "alt" is visible
            setShowAltText(true);
            if (placeholder !== "empty") {
                // If the real image fails to load, this will still remove the placeholder.
                setBlurComplete(true);
            }
            if (onError) {
                onError(event);
            }
        }
    });
});
function ImagePreload(param) {
    let { isAppRouter, imgAttributes } = param;
    const opts = {
        as: "image",
        imageSrcSet: imgAttributes.srcSet,
        imageSizes: imgAttributes.sizes,
        crossOrigin: imgAttributes.crossOrigin,
        referrerPolicy: imgAttributes.referrerPolicy,
        ...getDynamicProps(imgAttributes.fetchPriority)
    };
    if (isAppRouter && _reactdom.default.preload) {
        // See https://github.com/facebook/react/pull/26940
        _reactdom.default.preload(imgAttributes.src, opts);
        return null;
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)("link", {
            rel: "preload",
            // Note how we omit the `href` attribute, as it would only be relevant
            // for browsers that do not support `imagesrcset`, and in those cases
            // it would cause the incorrect image to be preloaded.
            //
            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset
            href: imgAttributes.srcSet ? undefined : imgAttributes.src,
            ...opts
        }, "__nimg-" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)
    });
}
const Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{
    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);
    // We're in the app directory if there is no pages router.
    const isAppRouter = !pagesRouter;
    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);
    const config = (0, _react.useMemo)(()=>{
        var _c_qualities;
        const c = configEnv || configContext || _imageconfig.imageConfigDefault;
        const allSizes = [
            ...c.deviceSizes,
            ...c.imageSizes
        ].sort((a, b)=>a - b);
        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);
        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);
        return {
            ...c,
            allSizes,
            deviceSizes,
            qualities
        };
    }, [
        configContext
    ]);
    const { onLoad, onLoadingComplete } = props;
    const onLoadRef = (0, _react.useRef)(onLoad);
    (0, _react.useEffect)(()=>{
        onLoadRef.current = onLoad;
    }, [
        onLoad
    ]);
    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);
    (0, _react.useEffect)(()=>{
        onLoadingCompleteRef.current = onLoadingComplete;
    }, [
        onLoadingComplete
    ]);
    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);
    const [showAltText, setShowAltText] = (0, _react.useState)(false);
    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {
        defaultLoader: _imageloader.default,
        imgConf: config,
        blurComplete,
        showAltText
    });
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {
                ...imgAttributes,
                unoptimized: imgMeta.unoptimized,
                placeholder: imgMeta.placeholder,
                fill: imgMeta.fill,
                onLoadRef: onLoadRef,
                onLoadingCompleteRef: onLoadingCompleteRef,
                setBlurComplete: setBlurComplete,
                setShowAltText: setShowAltText,
                sizesInput: props.sizes,
                ref: forwardedRef
            }),
            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {
                isAppRouter: isAppRouter,
                imgAttributes: imgAttributes
            }) : null
        ]
    });
});
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=image-component.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/link.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
const _interop_require_default = __webpack_require__("(app-pages-browser)/../../node_modules/@swc/helpers/esm/_interop_require_default.js");
const _jsxruntime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js"));
const _resolvehref = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js");
const _islocalurl = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js");
const _formaturl = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js");
const _utils = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js");
const _addlocale = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/add-locale.js");
const _routercontextsharedruntime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js");
const _approutercontextsharedruntime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js");
const _useintersection = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js");
const _getdomainlocale = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js");
const _addbasepath = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js");
const _routerreducertypes = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js");
const prefetched = new Set();
function prefetch(router, href, as, options, appOptions, isAppRouter) {
    if (typeof window === "undefined") {
        return;
    }
    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.
    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {
        return;
    }
    // We should only dedupe requests when experimental.optimisticClientCache is
    // disabled.
    if (!options.bypassPrefetchedCheck) {
        const locale = typeof options.locale !== "undefined" ? options.locale : "locale" in router ? router.locale : undefined;
        const prefetchedKey = href + "%" + as + "%" + locale;
        // If we've already fetched the key, then don't prefetch it again!
        if (prefetched.has(prefetchedKey)) {
            return;
        }
        // Mark this URL as prefetched.
        prefetched.add(prefetchedKey);
    }
    const doPrefetch = async ()=>{
        if (isAppRouter) {
            // note that `appRouter.prefetch()` is currently sync,
            // so we have to wrap this call in an async function to be able to catch() errors below.
            return router.prefetch(href, appOptions);
        } else {
            return router.prefetch(href, as, options);
        }
    };
    // Prefetch the JSON page if asked (only in the client)
    // We need to handle a prefetch error here since we may be
    // loading with priority which can reject but we don't
    // want to force navigation since this is only a prefetch
    doPrefetch().catch((err)=>{
        if (false) {}
    });
}
function isModifiedEvent(event) {
    const eventTarget = event.currentTarget;
    const target = eventTarget.getAttribute("target");
    return target && target !== "_self" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
    event.nativeEvent && event.nativeEvent.which === 2;
}
function linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter) {
    const { nodeName } = e.currentTarget;
    // anchors inside an svg have a lowercase nodeName
    const isAnchorNodeName = nodeName.toUpperCase() === "A";
    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.
    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {
        // ignore click for browser’s default behavior
        return;
    }
    e.preventDefault();
    const navigate = ()=>{
        // If the router is an NextRouter instance it will have `beforePopState`
        const routerScroll = scroll != null ? scroll : true;
        if ("beforePopState" in router) {
            router[replace ? "replace" : "push"](href, as, {
                shallow,
                locale,
                scroll: routerScroll
            });
        } else {
            router[replace ? "replace" : "push"](as || href, {
                scroll: routerScroll
            });
        }
    };
    if (isAppRouter) {
        _react.default.startTransition(navigate);
    } else {
        navigate();
    }
}
function formatStringOrUrl(urlObjOrString) {
    if (typeof urlObjOrString === "string") {
        return urlObjOrString;
    }
    return (0, _formaturl.formatUrl)(urlObjOrString);
}
/**
 * A React component that extends the HTML `<a>` element to provide [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)
 * and client-side navigation between routes.
 *
 * It is the primary way to navigate between routes in Next.js.
 *
 * Read more: [Next.js docs: `<Link>`](https://nextjs.org/docs/app/api-reference/components/link)
 */ const Link = /*#__PURE__*/ _react.default.forwardRef(function LinkComponent(props, forwardedRef) {
    let children;
    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;
    children = childrenProp;
    if (legacyBehavior && (typeof children === "string" || typeof children === "number")) {
        children = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
            children: children
        });
    }
    const pagesRouter = _react.default.useContext(_routercontextsharedruntime.RouterContext);
    const appRouter = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);
    const router = pagesRouter != null ? pagesRouter : appRouter;
    // We're in the app directory if there is no pages router.
    const isAppRouter = !pagesRouter;
    const prefetchEnabled = prefetchProp !== false;
    /**
     * The possible states for prefetch are:
     * - null: this is the default "auto" mode, where we will prefetch partially if the link is in the viewport
     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially
     * - false: we will not prefetch if in the viewport at all
     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;
    if (false) {}
    if (false) {}
    const { href, as } = _react.default.useMemo(()=>{
        if (!pagesRouter) {
            const resolvedHref = formatStringOrUrl(hrefProp);
            return {
                href: resolvedHref,
                as: asProp ? formatStringOrUrl(asProp) : resolvedHref
            };
        }
        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);
        return {
            href: resolvedHref,
            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref
        };
    }, [
        pagesRouter,
        hrefProp,
        asProp
    ]);
    const previousHref = _react.default.useRef(href);
    const previousAs = _react.default.useRef(as);
    // This will return the first child, if multiple are provided it will throw an error
    let child;
    if (legacyBehavior) {
        if (false) {} else {
            child = _react.default.Children.only(children);
        }
    } else {
        if (false) {}
    }
    const childRef = legacyBehavior ? child && typeof child === "object" && child.ref : forwardedRef;
    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({
        rootMargin: "200px"
    });
    const setRef = _react.default.useCallback((el)=>{
        // Before the link getting observed, check if visible state need to be reset
        if (previousAs.current !== as || previousHref.current !== href) {
            resetVisible();
            previousAs.current = as;
            previousHref.current = href;
        }
        setIntersectionRef(el);
        if (childRef) {
            if (typeof childRef === "function") childRef(el);
            else if (typeof childRef === "object") {
                childRef.current = el;
            }
        }
    }, [
        as,
        childRef,
        href,
        resetVisible,
        setIntersectionRef
    ]);
    // Prefetch the URL if we haven't already and it's visible.
    _react.default.useEffect(()=>{
        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.
        if (false) {}
        if (!router) {
            return;
        }
        // If we don't need to prefetch the URL, don't do prefetch.
        if (!isVisible || !prefetchEnabled) {
            return;
        }
        // Prefetch the URL.
        prefetch(router, href, as, {
            locale
        }, {
            kind: appPrefetchKind
        }, isAppRouter);
    }, [
        as,
        href,
        isVisible,
        locale,
        prefetchEnabled,
        pagesRouter == null ? void 0 : pagesRouter.locale,
        router,
        isAppRouter,
        appPrefetchKind
    ]);
    const childProps = {
        ref: setRef,
        onClick (e) {
            if (false) {}
            if (!legacyBehavior && typeof onClick === "function") {
                onClick(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onClick === "function") {
                child.props.onClick(e);
            }
            if (!router) {
                return;
            }
            if (e.defaultPrevented) {
                return;
            }
            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter);
        },
        onMouseEnter (e) {
            if (!legacyBehavior && typeof onMouseEnterProp === "function") {
                onMouseEnterProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === "function") {
                child.props.onMouseEnter(e);
            }
            if (!router) {
                return;
            }
            if ((!prefetchEnabled || "production" === "development") && isAppRouter) {
                return;
            }
            prefetch(router, href, as, {
                locale,
                priority: true,
                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}
                bypassPrefetchedCheck: true
            }, {
                kind: appPrefetchKind
            }, isAppRouter);
        },
        onTouchStart:  false ? 0 : function onTouchStart(e) {
            if (!legacyBehavior && typeof onTouchStartProp === "function") {
                onTouchStartProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onTouchStart === "function") {
                child.props.onTouchStart(e);
            }
            if (!router) {
                return;
            }
            if (!prefetchEnabled && isAppRouter) {
                return;
            }
            prefetch(router, href, as, {
                locale,
                priority: true,
                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}
                bypassPrefetchedCheck: true
            }, {
                kind: appPrefetchKind
            }, isAppRouter);
        }
    };
    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
    // defined, we specify the current 'href', so that repetition is not needed by the user.
    // If the url is absolute, we can bypass the logic to prepend the domain and locale.
    if ((0, _utils.isAbsoluteUrl)(as)) {
        childProps.href = as;
    } else if (!legacyBehavior || passHref || child.type === "a" && !("href" in child.props)) {
        const curLocale = typeof locale !== "undefined" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;
        // we only render domain locales if we are currently on a domain locale
        // so that locale links are still visitable in development/preview envs
        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);
        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));
    }
    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
        ...restProps,
        ...childProps,
        children: children
    });
});
const _default = Link;
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=link.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/***/ (function(module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    cancelIdleCallback: function() {
        return cancelIdleCallback;
    },
    requestIdleCallback: function() {
        return requestIdleCallback;
    }
});
const requestIdleCallback = typeof self !== "undefined" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {
    let start = Date.now();
    return self.setTimeout(function() {
        cb({
            didTimeout: false,
            timeRemaining: function() {
                return Math.max(0, 50 - (Date.now() - start));
            }
        });
    }, 1);
};
const cancelIdleCallback = typeof self !== "undefined" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {
    return clearTimeout(id);
};
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=request-idle-callback.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "resolveHref", ({
    enumerable: true,
    get: function() {
        return resolveHref;
    }
}));
const _querystring = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js");
const _formaturl = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js");
const _omit = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js");
const _utils = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js");
const _normalizetrailingslash = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js");
const _islocalurl = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js");
const _utils1 = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js");
const _interpolateas = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js");
function resolveHref(router, href, resolveAs) {
    // we use a dummy base url for relative urls
    let base;
    let urlAsString = typeof href === "string" ? href : (0, _formaturl.formatWithValidation)(href);
    // repeated slashes and backslashes in the URL are considered
    // invalid and will never match a Next.js page/file
    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\/\//);
    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;
    const urlParts = urlAsStringNoProto.split("?", 1);
    if ((urlParts[0] || "").match(/(\/\/|\\)/)) {
        console.error("Invalid href '" + urlAsString + "' passed to next/router in page: '" + router.pathname + "'. Repeated forward-slashes (//) or backslashes \\ are not valid in the href.");
        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);
        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : "") + normalizedUrl;
    }
    // Return because it cannot be routed by the Next.js router
    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {
        return resolveAs ? [
            urlAsString
        ] : urlAsString;
    }
    try {
        base = new URL(urlAsString.startsWith("#") ? router.asPath : router.pathname, "http://n");
    } catch (_) {
        // fallback to / for invalid asPath values e.g. //
        base = new URL("/", "http://n");
    }
    try {
        const finalUrl = new URL(urlAsString, base);
        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);
        let interpolatedAs = "";
        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);
            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);
            if (result) {
                interpolatedAs = (0, _formaturl.formatWithValidation)({
                    pathname: result,
                    hash: finalUrl.hash,
                    query: (0, _omit.omit)(query, params)
                });
            }
        }
        // if the origin didn't change, it means we received a relative href
        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
        return resolveAs ? [
            resolvedHref,
            interpolatedAs || resolvedHref
        ] : resolvedHref;
    } catch (_) {
        return resolveAs ? [
            urlAsString
        ] : urlAsString;
    }
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=resolve-href.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useIntersection", ({
    enumerable: true,
    get: function() {
        return useIntersection;
    }
}));
const _react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
const _requestidlecallback = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js");
const hasIntersectionObserver = typeof IntersectionObserver === "function";
const observers = new Map();
const idList = [];
function createObserver(options) {
    const id = {
        root: options.root || null,
        margin: options.rootMargin || ""
    };
    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);
    let instance;
    if (existing) {
        instance = observers.get(existing);
        if (instance) {
            return instance;
        }
    }
    const elements = new Map();
    const observer = new IntersectionObserver((entries)=>{
        entries.forEach((entry)=>{
            const callback = elements.get(entry.target);
            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;
            if (callback && isVisible) {
                callback(isVisible);
            }
        });
    }, options);
    instance = {
        id,
        observer,
        elements
    };
    idList.push(id);
    observers.set(id, instance);
    return instance;
}
function observe(element, callback, options) {
    const { id, observer, elements } = createObserver(options);
    elements.set(element, callback);
    observer.observe(element);
    return function unobserve() {
        elements.delete(element);
        observer.unobserve(element);
        // Destroy observer when there's nothing left to watch:
        if (elements.size === 0) {
            observer.disconnect();
            observers.delete(id);
            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);
            if (index > -1) {
                idList.splice(index, 1);
            }
        }
    };
}
function useIntersection(param) {
    let { rootRef, rootMargin, disabled } = param;
    const isDisabled = disabled || !hasIntersectionObserver;
    const [visible, setVisible] = (0, _react.useState)(false);
    const elementRef = (0, _react.useRef)(null);
    const setElement = (0, _react.useCallback)((element)=>{
        elementRef.current = element;
    }, []);
    (0, _react.useEffect)(()=>{
        if (hasIntersectionObserver) {
            if (isDisabled || visible) return;
            const element = elementRef.current;
            if (element && element.tagName) {
                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {
                    root: rootRef == null ? void 0 : rootRef.current,
                    rootMargin
                });
                return unobserve;
            }
        } else {
            if (!visible) {
                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));
                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);
            }
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled,
        rootMargin,
        rootRef,
        visible,
        elementRef.current
    ]);
    const resetVisible = (0, _react.useCallback)(()=>{
        setVisible(false);
    }, []);
    return [
        setElement,
        visible,
        resetVisible
    ];
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-intersection.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/***/ (function(module) {

var __dirname = "/";
(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}(function(){try{if(typeof setTimeout==="function"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout==="function"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title="browser";t.browser=true;t.env={};t.argv=[];t.version="";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error("process.binding is not supported")};t.cwd=function(){return"/"};t.chdir=function(e){throw new Error("process.chdir is not supported")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var r=__nccwpck_require__(229);module.exports=r})();

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/lib/constants.js":
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ACTION_SUFFIX: function() {
        return ACTION_SUFFIX;
    },
    APP_DIR_ALIAS: function() {
        return APP_DIR_ALIAS;
    },
    CACHE_ONE_YEAR: function() {
        return CACHE_ONE_YEAR;
    },
    DOT_NEXT_ALIAS: function() {
        return DOT_NEXT_ALIAS;
    },
    ESLINT_DEFAULT_DIRS: function() {
        return ESLINT_DEFAULT_DIRS;
    },
    GSP_NO_RETURNED_VALUE: function() {
        return GSP_NO_RETURNED_VALUE;
    },
    GSSP_COMPONENT_MEMBER_ERROR: function() {
        return GSSP_COMPONENT_MEMBER_ERROR;
    },
    GSSP_NO_RETURNED_VALUE: function() {
        return GSSP_NO_RETURNED_VALUE;
    },
    INSTRUMENTATION_HOOK_FILENAME: function() {
        return INSTRUMENTATION_HOOK_FILENAME;
    },
    MIDDLEWARE_FILENAME: function() {
        return MIDDLEWARE_FILENAME;
    },
    MIDDLEWARE_LOCATION_REGEXP: function() {
        return MIDDLEWARE_LOCATION_REGEXP;
    },
    NEXT_BODY_SUFFIX: function() {
        return NEXT_BODY_SUFFIX;
    },
    NEXT_CACHE_IMPLICIT_TAG_ID: function() {
        return NEXT_CACHE_IMPLICIT_TAG_ID;
    },
    NEXT_CACHE_REVALIDATED_TAGS_HEADER: function() {
        return NEXT_CACHE_REVALIDATED_TAGS_HEADER;
    },
    NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: function() {
        return NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER;
    },
    NEXT_CACHE_SOFT_TAGS_HEADER: function() {
        return NEXT_CACHE_SOFT_TAGS_HEADER;
    },
    NEXT_CACHE_SOFT_TAG_MAX_LENGTH: function() {
        return NEXT_CACHE_SOFT_TAG_MAX_LENGTH;
    },
    NEXT_CACHE_TAGS_HEADER: function() {
        return NEXT_CACHE_TAGS_HEADER;
    },
    NEXT_CACHE_TAG_MAX_ITEMS: function() {
        return NEXT_CACHE_TAG_MAX_ITEMS;
    },
    NEXT_CACHE_TAG_MAX_LENGTH: function() {
        return NEXT_CACHE_TAG_MAX_LENGTH;
    },
    NEXT_DATA_SUFFIX: function() {
        return NEXT_DATA_SUFFIX;
    },
    NEXT_INTERCEPTION_MARKER_PREFIX: function() {
        return NEXT_INTERCEPTION_MARKER_PREFIX;
    },
    NEXT_META_SUFFIX: function() {
        return NEXT_META_SUFFIX;
    },
    NEXT_QUERY_PARAM_PREFIX: function() {
        return NEXT_QUERY_PARAM_PREFIX;
    },
    NON_STANDARD_NODE_ENV: function() {
        return NON_STANDARD_NODE_ENV;
    },
    PAGES_DIR_ALIAS: function() {
        return PAGES_DIR_ALIAS;
    },
    PRERENDER_REVALIDATE_HEADER: function() {
        return PRERENDER_REVALIDATE_HEADER;
    },
    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function() {
        return PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER;
    },
    PUBLIC_DIR_MIDDLEWARE_CONFLICT: function() {
        return PUBLIC_DIR_MIDDLEWARE_CONFLICT;
    },
    ROOT_DIR_ALIAS: function() {
        return ROOT_DIR_ALIAS;
    },
    RSC_ACTION_CLIENT_WRAPPER_ALIAS: function() {
        return RSC_ACTION_CLIENT_WRAPPER_ALIAS;
    },
    RSC_ACTION_ENCRYPTION_ALIAS: function() {
        return RSC_ACTION_ENCRYPTION_ALIAS;
    },
    RSC_ACTION_PROXY_ALIAS: function() {
        return RSC_ACTION_PROXY_ALIAS;
    },
    RSC_ACTION_VALIDATE_ALIAS: function() {
        return RSC_ACTION_VALIDATE_ALIAS;
    },
    RSC_MOD_REF_PROXY_ALIAS: function() {
        return RSC_MOD_REF_PROXY_ALIAS;
    },
    RSC_PREFETCH_SUFFIX: function() {
        return RSC_PREFETCH_SUFFIX;
    },
    RSC_SUFFIX: function() {
        return RSC_SUFFIX;
    },
    SERVER_PROPS_EXPORT_ERROR: function() {
        return SERVER_PROPS_EXPORT_ERROR;
    },
    SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function() {
        return SERVER_PROPS_GET_INIT_PROPS_CONFLICT;
    },
    SERVER_PROPS_SSG_CONFLICT: function() {
        return SERVER_PROPS_SSG_CONFLICT;
    },
    SERVER_RUNTIME: function() {
        return SERVER_RUNTIME;
    },
    SSG_FALLBACK_EXPORT_ERROR: function() {
        return SSG_FALLBACK_EXPORT_ERROR;
    },
    SSG_GET_INITIAL_PROPS_CONFLICT: function() {
        return SSG_GET_INITIAL_PROPS_CONFLICT;
    },
    STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function() {
        return STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR;
    },
    UNSTABLE_REVALIDATE_RENAME_ERROR: function() {
        return UNSTABLE_REVALIDATE_RENAME_ERROR;
    },
    WEBPACK_LAYERS: function() {
        return WEBPACK_LAYERS;
    },
    WEBPACK_RESOURCE_QUERIES: function() {
        return WEBPACK_RESOURCE_QUERIES;
    }
});
const NEXT_QUERY_PARAM_PREFIX = "nxtP";
const NEXT_INTERCEPTION_MARKER_PREFIX = "nxtI";
const PRERENDER_REVALIDATE_HEADER = "x-prerender-revalidate";
const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = "x-prerender-revalidate-if-generated";
const RSC_PREFETCH_SUFFIX = ".prefetch.rsc";
const RSC_SUFFIX = ".rsc";
const ACTION_SUFFIX = ".action";
const NEXT_DATA_SUFFIX = ".json";
const NEXT_META_SUFFIX = ".meta";
const NEXT_BODY_SUFFIX = ".body";
const NEXT_CACHE_TAGS_HEADER = "x-next-cache-tags";
const NEXT_CACHE_SOFT_TAGS_HEADER = "x-next-cache-soft-tags";
const NEXT_CACHE_REVALIDATED_TAGS_HEADER = "x-next-revalidated-tags";
const NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = "x-next-revalidate-tag-token";
const NEXT_CACHE_TAG_MAX_ITEMS = 128;
const NEXT_CACHE_TAG_MAX_LENGTH = 256;
const NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;
const NEXT_CACHE_IMPLICIT_TAG_ID = "_N_T_";
const CACHE_ONE_YEAR = 31536000;
const MIDDLEWARE_FILENAME = "middleware";
const MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;
const INSTRUMENTATION_HOOK_FILENAME = "instrumentation";
const PAGES_DIR_ALIAS = "private-next-pages";
const DOT_NEXT_ALIAS = "private-dot-next";
const ROOT_DIR_ALIAS = "private-next-root-dir";
const APP_DIR_ALIAS = "private-next-app-dir";
const RSC_MOD_REF_PROXY_ALIAS = "private-next-rsc-mod-ref-proxy";
const RSC_ACTION_VALIDATE_ALIAS = "private-next-rsc-action-validate";
const RSC_ACTION_PROXY_ALIAS = "private-next-rsc-server-reference";
const RSC_ACTION_ENCRYPTION_ALIAS = "private-next-rsc-action-encryption";
const RSC_ACTION_CLIENT_WRAPPER_ALIAS = "private-next-rsc-action-client-wrapper";
const PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;
const SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;
const SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;
const SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;
const STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;
const SERVER_PROPS_EXPORT_ERROR = `pages with \`getServerSideProps\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;
const GSP_NO_RETURNED_VALUE = "Your `getStaticProps` function did not return an object. Did you forget to add a `return`?";
const GSSP_NO_RETURNED_VALUE = "Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?";
const UNSTABLE_REVALIDATE_RENAME_ERROR = "The `unstable_revalidate` property is available for general use.\n" + "Please use `revalidate` instead.";
const GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;
const NON_STANDARD_NODE_ENV = `You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;
const SSG_FALLBACK_EXPORT_ERROR = `Pages with \`fallback\` enabled in \`getStaticPaths\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;
const ESLINT_DEFAULT_DIRS = [
    "app",
    "pages",
    "components",
    "lib",
    "src"
];
const SERVER_RUNTIME = {
    edge: "edge",
    experimentalEdge: "experimental-edge",
    nodejs: "nodejs"
};
/**
 * The names of the webpack layers. These layers are the primitives for the
 * webpack chunks.
 */ const WEBPACK_LAYERS_NAMES = {
    /**
   * The layer for the shared code between the client and server bundles.
   */ shared: "shared",
    /**
   * React Server Components layer (rsc).
   */ reactServerComponents: "rsc",
    /**
   * Server Side Rendering layer for app (ssr).
   */ serverSideRendering: "ssr",
    /**
   * The browser client bundle layer for actions.
   */ actionBrowser: "action-browser",
    /**
   * The layer for the API routes.
   */ api: "api",
    /**
   * The layer for the middleware code.
   */ middleware: "middleware",
    /**
   * The layer for the instrumentation hooks.
   */ instrument: "instrument",
    /**
   * The layer for assets on the edge.
   */ edgeAsset: "edge-asset",
    /**
   * The browser client bundle layer for App directory.
   */ appPagesBrowser: "app-pages-browser",
    /**
   * The server bundle layer for metadata routes.
   */ appMetadataRoute: "app-metadata-route",
    /**
   * The layer for the server bundle for App Route handlers.
   */ appRouteHandler: "app-route-handler"
};
const WEBPACK_LAYERS = {
    ...WEBPACK_LAYERS_NAMES,
    GROUP: {
        serverOnly: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser,
            WEBPACK_LAYERS_NAMES.appMetadataRoute,
            WEBPACK_LAYERS_NAMES.appRouteHandler,
            WEBPACK_LAYERS_NAMES.instrument
        ],
        clientOnly: [
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser
        ],
        nonClientServerTarget: [
            // middleware and pages api
            WEBPACK_LAYERS_NAMES.middleware,
            WEBPACK_LAYERS_NAMES.api
        ],
        app: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser,
            WEBPACK_LAYERS_NAMES.appMetadataRoute,
            WEBPACK_LAYERS_NAMES.appRouteHandler,
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser,
            WEBPACK_LAYERS_NAMES.shared,
            WEBPACK_LAYERS_NAMES.instrument
        ]
    }
};
const WEBPACK_RESOURCE_QUERIES = {
    edgeSSREntry: "__next_edge_ssr_entry__",
    metadata: "__next_metadata__",
    metadataRoute: "__next_metadata_route__",
    metadataImageMeta: "__next_metadata_image_meta__"
};

//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "AmpStateContext", ({
    enumerable: true,
    get: function() {
        return AmpStateContext;
    }
}));
const _interop_require_default = __webpack_require__("(app-pages-browser)/../../node_modules/@swc/helpers/esm/_interop_require_default.js");
const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js"));
const AmpStateContext = _react.default.createContext({});
if (false) {} //# sourceMappingURL=amp-context.shared-runtime.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "isInAmpMode", ({
    enumerable: true,
    get: function() {
        return isInAmpMode;
    }
}));
function isInAmpMode(param) {
    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;
    return ampFirst || hybrid && hasQuery;
} //# sourceMappingURL=amp-mode.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js":
/***/ (function(__unused_webpack_module, exports) {

"use strict";
// regexp is based on https://github.com/sindresorhus/escape-string-regexp

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "escapeStringRegexp", ({
    enumerable: true,
    get: function() {
        return escapeStringRegexp;
    }
}));
const reHasRegExp = /[|\\{}()[\]^$+*?.-]/;
const reReplaceRegExp = /[|\\{}()[\]^$+*?.-]/g;
function escapeStringRegexp(str) {
    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23
    if (reHasRegExp.test(str)) {
        return str.replace(reReplaceRegExp, "\\$&");
    }
    return str;
} //# sourceMappingURL=escape-regexp.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getImgProps", ({
    enumerable: true,
    get: function() {
        return getImgProps;
    }
}));
const _warnonce = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js");
const _imageblursvg = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js");
const _imageconfig = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js");
const VALID_LOADING_VALUES = (/* unused pure expression or super */ null && ([
    "lazy",
    "eager",
    undefined
]));
function isStaticRequire(src) {
    return src.default !== undefined;
}
function isStaticImageData(src) {
    return src.src !== undefined;
}
function isStaticImport(src) {
    return typeof src === "object" && (isStaticRequire(src) || isStaticImageData(src));
}
const allImgs = new Map();
let perfObserver;
function getInt(x) {
    if (typeof x === "undefined") {
        return x;
    }
    if (typeof x === "number") {
        return Number.isFinite(x) ? x : NaN;
    }
    if (typeof x === "string" && /^[0-9]+$/.test(x)) {
        return parseInt(x, 10);
    }
    return NaN;
}
function getWidths(param, width, sizes) {
    let { deviceSizes, allSizes } = param;
    if (sizes) {
        // Find all the "vw" percent sizes used in the sizes prop
        const viewportWidthRe = /(^|\s)(1?\d?\d)vw/g;
        const percentSizes = [];
        for(let match; match = viewportWidthRe.exec(sizes); match){
            percentSizes.push(parseInt(match[2]));
        }
        if (percentSizes.length) {
            const smallestRatio = Math.min(...percentSizes) * 0.01;
            return {
                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),
                kind: "w"
            };
        }
        return {
            widths: allSizes,
            kind: "w"
        };
    }
    if (typeof width !== "number") {
        return {
            widths: deviceSizes,
            kind: "w"
        };
    }
    const widths = [
        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and
        // > blue colors. Showing a 3x resolution image in the app vs a 2x
        // > resolution image will be visually the same, though the 3x image
        // > takes significantly more data. Even true 3x resolution screens are
        // > wasteful as the human eye cannot see that level of detail without
        // > something like a magnifying glass.
        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html
        [
            width,
            width * 2 /*, width * 3*/ 
        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))
    ];
    return {
        widths,
        kind: "x"
    };
}
function generateImgAttrs(param) {
    let { config, src, unoptimized, width, quality, sizes, loader } = param;
    if (unoptimized) {
        return {
            src,
            srcSet: undefined,
            sizes: undefined
        };
    }
    const { widths, kind } = getWidths(config, width, sizes);
    const last = widths.length - 1;
    return {
        sizes: !sizes && kind === "w" ? "100vw" : sizes,
        srcSet: widths.map((w, i)=>loader({
                config,
                src,
                quality,
                width: w
            }) + " " + (kind === "w" ? w : i + 1) + kind).join(", "),
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        src: loader({
            config,
            src,
            quality,
            width: widths[last]
        })
    };
}
function getImgProps(param, _state) {
    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = "empty", blurDataURL, fetchPriority, decoding = "async", layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;
    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;
    let config;
    let c = imgConf || _imageconfig.imageConfigDefault;
    if ("allSizes" in c) {
        config = c;
    } else {
        var _c_qualities;
        const allSizes = [
            ...c.deviceSizes,
            ...c.imageSizes
        ].sort((a, b)=>a - b);
        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);
        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);
        config = {
            ...c,
            allSizes,
            deviceSizes,
            qualities
        };
    }
    if (typeof defaultLoader === "undefined") {
        throw new Error("images.loaderFile detected but the file is missing default export.\nRead more: https://nextjs.org/docs/messages/invalid-images-config");
    }
    let loader = rest.loader || defaultLoader;
    // Remove property so it's not spread on <img> element
    delete rest.loader;
    delete rest.srcSet;
    // This special value indicates that the user
    // didn't define a "loader" prop or "loader" config.
    const isDefaultLoader = "__next_img_default" in loader;
    if (isDefaultLoader) {
        if (config.loader === "custom") {
            throw new Error('Image with src "' + src + '" is missing "loader" prop.' + "\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader");
        }
    } else {
        // The user defined a "loader" prop or config.
        // Since the config object is internal only, we
        // must not pass it to the user-defined "loader".
        const customImageLoader = loader;
        loader = (obj)=>{
            const { config: _, ...opts } = obj;
            return customImageLoader(opts);
        };
    }
    if (layout) {
        if (layout === "fill") {
            fill = true;
        }
        const layoutToStyle = {
            intrinsic: {
                maxWidth: "100%",
                height: "auto"
            },
            responsive: {
                width: "100%",
                height: "auto"
            }
        };
        const layoutToSizes = {
            responsive: "100vw",
            fill: "100vw"
        };
        const layoutStyle = layoutToStyle[layout];
        if (layoutStyle) {
            style = {
                ...style,
                ...layoutStyle
            };
        }
        const layoutSizes = layoutToSizes[layout];
        if (layoutSizes && !sizes) {
            sizes = layoutSizes;
        }
    }
    let staticSrc = "";
    let widthInt = getInt(width);
    let heightInt = getInt(height);
    let blurWidth;
    let blurHeight;
    if (isStaticImport(src)) {
        const staticImageData = isStaticRequire(src) ? src.default : src;
        if (!staticImageData.src) {
            throw new Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received " + JSON.stringify(staticImageData));
        }
        if (!staticImageData.height || !staticImageData.width) {
            throw new Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received " + JSON.stringify(staticImageData));
        }
        blurWidth = staticImageData.blurWidth;
        blurHeight = staticImageData.blurHeight;
        blurDataURL = blurDataURL || staticImageData.blurDataURL;
        staticSrc = staticImageData.src;
        if (!fill) {
            if (!widthInt && !heightInt) {
                widthInt = staticImageData.width;
                heightInt = staticImageData.height;
            } else if (widthInt && !heightInt) {
                const ratio = widthInt / staticImageData.width;
                heightInt = Math.round(staticImageData.height * ratio);
            } else if (!widthInt && heightInt) {
                const ratio = heightInt / staticImageData.height;
                widthInt = Math.round(staticImageData.width * ratio);
            }
        }
    }
    src = typeof src === "string" ? src : staticSrc;
    let isLazy = !priority && (loading === "lazy" || typeof loading === "undefined");
    if (!src || src.startsWith("data:") || src.startsWith("blob:")) {
        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
        unoptimized = true;
        isLazy = false;
    }
    if (config.unoptimized) {
        unoptimized = true;
    }
    if (isDefaultLoader && src.endsWith(".svg") && !config.dangerouslyAllowSVG) {
        // Special case to make svg serve as-is to avoid proxying
        // through the built-in Image Optimization API.
        unoptimized = true;
    }
    if (priority) {
        fetchPriority = "high";
    }
    const qualityInt = getInt(quality);
    if (false) {}
    const imgStyle = Object.assign(fill ? {
        position: "absolute",
        height: "100%",
        width: "100%",
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        objectFit,
        objectPosition
    } : {}, showAltText ? {} : {
        color: "transparent"
    }, style);
    const backgroundImage = !blurComplete && placeholder !== "empty" ? placeholder === "blur" ? 'url("data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({
        widthInt,
        heightInt,
        blurWidth,
        blurHeight,
        blurDataURL: blurDataURL || "",
        objectFit: imgStyle.objectFit
    }) + '")' : 'url("' + placeholder + '")' // assume `data:image/`
     : null;
    let placeholderStyle = backgroundImage ? {
        backgroundSize: imgStyle.objectFit || "cover",
        backgroundPosition: imgStyle.objectPosition || "50% 50%",
        backgroundRepeat: "no-repeat",
        backgroundImage
    } : {};
    if (false) {}
    const imgAttributes = generateImgAttrs({
        config,
        src,
        unoptimized,
        width: widthInt,
        quality: qualityInt,
        sizes,
        loader
    });
    if (false) {}
    const props = {
        ...rest,
        loading: isLazy ? "lazy" : loading,
        fetchPriority,
        width: widthInt,
        height: heightInt,
        decoding,
        className,
        style: {
            ...imgStyle,
            ...placeholderStyle
        },
        sizes: imgAttributes.sizes,
        srcSet: imgAttributes.srcSet,
        src: overrideSrc || imgAttributes.src
    };
    const meta = {
        unoptimized,
        priority,
        placeholder,
        fill
    };
    return {
        props,
        meta
    };
} //# sourceMappingURL=get-img-props.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* __next_internal_client_entry_do_not_use__  cjs */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    defaultHead: function() {
        return defaultHead;
    }
});
const _interop_require_default = __webpack_require__("(app-pages-browser)/../../node_modules/@swc/helpers/esm/_interop_require_default.js");
const _interop_require_wildcard = __webpack_require__("(app-pages-browser)/../../node_modules/@swc/helpers/esm/_interop_require_wildcard.js");
const _jsxruntime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js"));
const _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js"));
const _ampcontextsharedruntime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js");
const _headmanagercontextsharedruntime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js");
const _ampmode = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js");
const _warnonce = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js");
function defaultHead(inAmpMode) {
    if (inAmpMode === void 0) inAmpMode = false;
    const head = [
        /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            charSet: "utf-8"
        })
    ];
    if (!inAmpMode) {
        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            name: "viewport",
            content: "width=device-width"
        }));
    }
    return head;
}
function onlyReactElement(list, child) {
    // React children can be "string" or "number" in this case we ignore them for backwards compat
    if (typeof child === "string" || typeof child === "number") {
        return list;
    }
    // Adds support for React.Fragment
    if (child.type === _react.default.Fragment) {
        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{
            if (typeof fragmentChild === "string" || typeof fragmentChild === "number") {
                return fragmentList;
            }
            return fragmentList.concat(fragmentChild);
        }, []));
    }
    return list.concat(child);
}
const METATYPES = [
    "name",
    "httpEquiv",
    "charSet",
    "itemProp"
];
/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>
 Also adds support for deduplicated `key` properties
*/ function unique() {
    const keys = new Set();
    const tags = new Set();
    const metaTypes = new Set();
    const metaCategories = {};
    return (h)=>{
        let isUnique = true;
        let hasKey = false;
        if (h.key && typeof h.key !== "number" && h.key.indexOf("$") > 0) {
            hasKey = true;
            const key = h.key.slice(h.key.indexOf("$") + 1);
            if (keys.has(key)) {
                isUnique = false;
            } else {
                keys.add(key);
            }
        }
        // eslint-disable-next-line default-case
        switch(h.type){
            case "title":
            case "base":
                if (tags.has(h.type)) {
                    isUnique = false;
                } else {
                    tags.add(h.type);
                }
                break;
            case "meta":
                for(let i = 0, len = METATYPES.length; i < len; i++){
                    const metatype = METATYPES[i];
                    if (!h.props.hasOwnProperty(metatype)) continue;
                    if (metatype === "charSet") {
                        if (metaTypes.has(metatype)) {
                            isUnique = false;
                        } else {
                            metaTypes.add(metatype);
                        }
                    } else {
                        const category = h.props[metatype];
                        const categories = metaCategories[metatype] || new Set();
                        if ((metatype !== "name" || !hasKey) && categories.has(category)) {
                            isUnique = false;
                        } else {
                            categories.add(category);
                            metaCategories[metatype] = categories;
                        }
                    }
                }
                break;
        }
        return isUnique;
    };
}
/**
 *
 * @param headChildrenElements List of children of <Head>
 */ function reduceComponents(headChildrenElements, props) {
    const { inAmpMode } = props;
    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{
        const key = c.key || i;
        if (false) {}
        if (false) {}
        return /*#__PURE__*/ _react.default.cloneElement(c, {
            key
        });
    });
}
/**
 * This component injects elements to `<head>` of your page.
 * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
 */ function Head(param) {
    let { children } = param;
    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);
    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {
        reduceComponentsToState: reduceComponents,
        headManager: headManager,
        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),
        children: children
    });
}
const _default = Head;
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=head.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js":
/***/ (function(__unused_webpack_module, exports) {

"use strict";
/**
 * A shared function, used on both client and server, to generate a SVG blur placeholder.
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getImageBlurSvg", ({
    enumerable: true,
    get: function() {
        return getImageBlurSvg;
    }
}));
function getImageBlurSvg(param) {
    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;
    const std = 20;
    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;
    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;
    const viewBox = svgWidth && svgHeight ? "viewBox='0 0 " + svgWidth + " " + svgHeight + "'" : "";
    const preserveAspectRatio = viewBox ? "none" : objectFit === "contain" ? "xMidYMid" : objectFit === "cover" ? "xMidYMid slice" : "none";
    return "%3Csvg xmlns='http://www.w3.org/2000/svg' " + viewBox + "%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='" + std + "'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='" + std + "'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='" + preserveAspectRatio + "' style='filter: url(%23b);' href='" + blurDataURL + "'/%3E%3C/svg%3E";
} //# sourceMappingURL=image-blur-svg.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "ImageConfigContext", ({
    enumerable: true,
    get: function() {
        return ImageConfigContext;
    }
}));
const _interop_require_default = __webpack_require__("(app-pages-browser)/../../node_modules/@swc/helpers/esm/_interop_require_default.js");
const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js"));
const _imageconfig = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js");
const ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);
if (false) {} //# sourceMappingURL=image-config-context.shared-runtime.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js":
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    VALID_LOADERS: function() {
        return VALID_LOADERS;
    },
    imageConfigDefault: function() {
        return imageConfigDefault;
    }
});
const VALID_LOADERS = [
    "default",
    "imgix",
    "cloudinary",
    "akamai",
    "custom"
];
const imageConfigDefault = {
    deviceSizes: [
        640,
        750,
        828,
        1080,
        1200,
        1920,
        2048,
        3840
    ],
    imageSizes: [
        16,
        32,
        48,
        64,
        96,
        128,
        256,
        384
    ],
    path: "/_next/image",
    loader: "default",
    loaderFile: "",
    domains: [],
    disableStaticImages: false,
    minimumCacheTTL: 60,
    formats: [
        "image/webp"
    ],
    dangerouslyAllowSVG: false,
    contentSecurityPolicy: "script-src 'none'; frame-src 'none'; sandbox;",
    contentDispositionType: "inline",
    localPatterns: undefined,
    remotePatterns: [],
    qualities: undefined,
    unoptimized: false
}; //# sourceMappingURL=image-config.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    getImageProps: function() {
        return getImageProps;
    }
});
const _interop_require_default = __webpack_require__("(app-pages-browser)/../../node_modules/@swc/helpers/esm/_interop_require_default.js");
const _getimgprops = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js");
const _imagecomponent = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/image-component.js");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js"));
function getImageProps(imgProps) {
    const { props } = (0, _getimgprops.getImgProps)(imgProps, {
        defaultLoader: _imageloader.default,
        // This is replaced by webpack define plugin
        imgConf: {"deviceSizes":[640,750,828,1080,1200,1920,2048,3840],"imageSizes":[16,32,48,64,96,128,256,384],"path":"/uavos/_next/image/","loader":"default","dangerouslyAllowSVG":false,"unoptimized":true}
    });
    // Normally we don't care about undefined props because we pass to JSX,
    // but this exported function could be used by the end user for anything
    // so we delete undefined props to clean it up a little.
    for (const [key, value] of Object.entries(props)){
        if (value === undefined) {
            delete props[key];
        }
    }
    return {
        props
    };
}
const _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js":
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
const DEFAULT_Q = 75;
function defaultLoader(param) {
    let { config, src, width, quality } = param;
    var _config_qualities;
    if (false) {}
    const q = quality || ((_config_qualities = config.qualities) == null ? void 0 : _config_qualities.reduce((prev, cur)=>Math.abs(cur - DEFAULT_Q) < Math.abs(prev - DEFAULT_Q) ? cur : prev)) || DEFAULT_Q;
    return config.path + "?url=" + encodeURIComponent(src) + "&w=" + width + "&q=" + q + ( false ? 0 : "");
}
// We use this to determine if the import is the default loader
// or a custom loader defined by the user in next.config.js
defaultLoader.__next_img_default = true;
const _default = defaultLoader; //# sourceMappingURL=image-loader.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "RouterContext", ({
    enumerable: true,
    get: function() {
        return RouterContext;
    }
}));
const _interop_require_default = __webpack_require__("(app-pages-browser)/../../node_modules/@swc/helpers/esm/_interop_require_default.js");
const _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js"));
const RouterContext = _react.default.createContext(null);
if (false) {} //# sourceMappingURL=router-context.shared-runtime.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
// Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatUrl: function() {
        return formatUrl;
    },
    formatWithValidation: function() {
        return formatWithValidation;
    },
    urlObjectKeys: function() {
        return urlObjectKeys;
    }
});
const _interop_require_wildcard = __webpack_require__("(app-pages-browser)/../../node_modules/@swc/helpers/esm/_interop_require_wildcard.js");
const _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js"));
const slashedProtocols = /https?|ftp|gopher|file/;
function formatUrl(urlObj) {
    let { auth, hostname } = urlObj;
    let protocol = urlObj.protocol || "";
    let pathname = urlObj.pathname || "";
    let hash = urlObj.hash || "";
    let query = urlObj.query || "";
    let host = false;
    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ":") + "@" : "";
    if (urlObj.host) {
        host = auth + urlObj.host;
    } else if (hostname) {
        host = auth + (~hostname.indexOf(":") ? "[" + hostname + "]" : hostname);
        if (urlObj.port) {
            host += ":" + urlObj.port;
        }
    }
    if (query && typeof query === "object") {
        query = String(_querystring.urlQueryToSearchParams(query));
    }
    let search = urlObj.search || query && "?" + query || "";
    if (protocol && !protocol.endsWith(":")) protocol += ":";
    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname[0] !== "/") pathname = "/" + pathname;
    } else if (!host) {
        host = "";
    }
    if (hash && hash[0] !== "#") hash = "#" + hash;
    if (search && search[0] !== "?") search = "?" + search;
    pathname = pathname.replace(/[?#]/g, encodeURIComponent);
    search = search.replace("#", "%23");
    return "" + protocol + host + pathname + search + hash;
}
const urlObjectKeys = [
    "auth",
    "hash",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "slashes"
];
function formatWithValidation(url) {
    if (false) {}
    return formatUrl(url);
} //# sourceMappingURL=format-url.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getSortedRoutes: function() {
        return _sortedroutes.getSortedRoutes;
    },
    isDynamicRoute: function() {
        return _isdynamic.isDynamicRoute;
    }
});
const _sortedroutes = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js");
const _isdynamic = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js"); //# sourceMappingURL=index.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "interpolateAs", ({
    enumerable: true,
    get: function() {
        return interpolateAs;
    }
}));
const _routematcher = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js");
const _routeregex = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js");
function interpolateAs(route, asPathname, query) {
    let interpolatedRoute = "";
    const dynamicRegex = (0, _routeregex.getRouteRegex)(route);
    const dynamicGroups = dynamicRegex.groups;
    const dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : "") || // Fall back to reading the values from the href
    // TODO: should this take priority; also need to change in the router.
    query;
    interpolatedRoute = route;
    const params = Object.keys(dynamicGroups);
    if (!params.every((param)=>{
        let value = dynamicMatches[param] || "";
        const { repeat, optional } = dynamicGroups[param];
        // support single-level catch-all
        // TODO: more robust handling for user-error (passing `/`)
        let replaced = "[" + (repeat ? "..." : "") + param + "]";
        if (optional) {
            replaced = (!value ? "/" : "") + "[" + replaced + "]";
        }
        if (repeat && !Array.isArray(value)) value = [
            value
        ];
        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present
        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted
        // into the URL and we expect URL encoded segments
        // when parsing dynamic route params
        (segment)=>encodeURIComponent(segment)).join("/") : encodeURIComponent(value)) || "/");
    })) {
        interpolatedRoute = "" // did not satisfy all requirements
        ;
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
    }
    return {
        params,
        result: interpolatedRoute
    };
} //# sourceMappingURL=interpolate-as.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "isDynamicRoute", ({
    enumerable: true,
    get: function() {
        return isDynamicRoute;
    }
}));
const _interceptionroutes = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js");
// Identify /[param]/ in route string
const TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;
function isDynamicRoute(route) {
    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {
        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;
    }
    return TEST_ROUTE.test(route);
} //# sourceMappingURL=is-dynamic.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "isLocalURL", ({
    enumerable: true,
    get: function() {
        return isLocalURL;
    }
}));
const _utils = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js");
const _hasbasepath = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js");
function isLocalURL(url) {
    // prevent a hydration mismatch on href for url with anchor refs
    if (!(0, _utils.isAbsoluteUrl)(url)) return true;
    try {
        // absolute urls can be local if they are on the same origin
        const locationOrigin = (0, _utils.getLocationOrigin)();
        const resolved = new URL(url, locationOrigin);
        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);
    } catch (_) {
        return false;
    }
} //# sourceMappingURL=is-local-url.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js":
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "omit", ({
    enumerable: true,
    get: function() {
        return omit;
    }
}));
function omit(object, keys) {
    const omitted = {};
    Object.keys(object).forEach((key)=>{
        if (!keys.includes(key)) {
            omitted[key] = object[key];
        }
    });
    return omitted;
} //# sourceMappingURL=omit.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    assign: function() {
        return assign;
    },
    searchParamsToUrlQuery: function() {
        return searchParamsToUrlQuery;
    },
    urlQueryToSearchParams: function() {
        return urlQueryToSearchParams;
    }
});
function searchParamsToUrlQuery(searchParams) {
    const query = {};
    searchParams.forEach((value, key)=>{
        if (typeof query[key] === "undefined") {
            query[key] = value;
        } else if (Array.isArray(query[key])) {
            query[key].push(value);
        } else {
            query[key] = [
                query[key],
                value
            ];
        }
    });
    return query;
}
function stringifyUrlQueryParam(param) {
    if (typeof param === "string" || typeof param === "number" && !isNaN(param) || typeof param === "boolean") {
        return String(param);
    } else {
        return "";
    }
}
function urlQueryToSearchParams(urlQuery) {
    const result = new URLSearchParams();
    Object.entries(urlQuery).forEach((param)=>{
        let [key, value] = param;
        if (Array.isArray(value)) {
            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));
        } else {
            result.set(key, stringifyUrlQueryParam(value));
        }
    });
    return result;
}
function assign(target) {
    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        searchParamsList[_key - 1] = arguments[_key];
    }
    searchParamsList.forEach((searchParams)=>{
        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));
        searchParams.forEach((value, key)=>target.append(key, value));
    });
    return target;
} //# sourceMappingURL=querystring.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getRouteMatcher", ({
    enumerable: true,
    get: function() {
        return getRouteMatcher;
    }
}));
const _utils = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js");
function getRouteMatcher(param) {
    let { re, groups } = param;
    return (pathname)=>{
        const routeMatch = re.exec(pathname);
        if (!routeMatch) {
            return false;
        }
        const decode = (param)=>{
            try {
                return decodeURIComponent(param);
            } catch (_) {
                throw new _utils.DecodeError("failed to decode param");
            }
        };
        const params = {};
        Object.keys(groups).forEach((slugName)=>{
            const g = groups[slugName];
            const m = routeMatch[g.pos];
            if (m !== undefined) {
                params[slugName] = ~m.indexOf("/") ? m.split("/").map((entry)=>decode(entry)) : g.repeat ? [
                    decode(m)
                ] : decode(m);
            }
        });
        return params;
    };
} //# sourceMappingURL=route-matcher.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getNamedMiddlewareRegex: function() {
        return getNamedMiddlewareRegex;
    },
    getNamedRouteRegex: function() {
        return getNamedRouteRegex;
    },
    getRouteRegex: function() {
        return getRouteRegex;
    },
    parseParameter: function() {
        return parseParameter;
    }
});
const _constants = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/lib/constants.js");
const _interceptionroutes = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js");
const _escaperegexp = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js");
const _removetrailingslash = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js");
function parseParameter(param) {
    const optional = param.startsWith("[") && param.endsWith("]");
    if (optional) {
        param = param.slice(1, -1);
    }
    const repeat = param.startsWith("...");
    if (repeat) {
        param = param.slice(3);
    }
    return {
        key: param,
        repeat,
        optional
    };
}
function getParametrizedRoute(route) {
    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split("/");
    const groups = {};
    let groupIndex = 1;
    return {
        parameterizedRoute: segments.map((segment)=>{
            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));
            const paramMatches = segment.match(/\[((?:\[.*\])|.+)\]/) // Check for parameters
            ;
            if (markerMatch && paramMatches) {
                const { key, optional, repeat } = parseParameter(paramMatches[1]);
                groups[key] = {
                    pos: groupIndex++,
                    repeat,
                    optional
                };
                return "/" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + "([^/]+?)";
            } else if (paramMatches) {
                const { key, repeat, optional } = parseParameter(paramMatches[1]);
                groups[key] = {
                    pos: groupIndex++,
                    repeat,
                    optional
                };
                return repeat ? optional ? "(?:/(.+?))?" : "/(.+?)" : "/([^/]+?)";
            } else {
                return "/" + (0, _escaperegexp.escapeStringRegexp)(segment);
            }
        }).join(""),
        groups
    };
}
function getRouteRegex(normalizedRoute) {
    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);
    return {
        re: new RegExp("^" + parameterizedRoute + "(?:/)?$"),
        groups: groups
    };
}
/**
 * Builds a function to generate a minimal routeKey using only a-z and minimal
 * number of characters.
 */ function buildGetSafeRouteKey() {
    let i = 0;
    return ()=>{
        let routeKey = "";
        let j = ++i;
        while(j > 0){
            routeKey += String.fromCharCode(97 + (j - 1) % 26);
            j = Math.floor((j - 1) / 26);
        }
        return routeKey;
    };
}
function getSafeKeyFromSegment(param) {
    let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix } = param;
    const { key, optional, repeat } = parseParameter(segment);
    // replace any non-word characters since they can break
    // the named regex
    let cleanedKey = key.replace(/\W/g, "");
    if (keyPrefix) {
        cleanedKey = "" + keyPrefix + cleanedKey;
    }
    let invalidKey = false;
    // check if the key is still invalid and fallback to using a known
    // safe key
    if (cleanedKey.length === 0 || cleanedKey.length > 30) {
        invalidKey = true;
    }
    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {
        invalidKey = true;
    }
    if (invalidKey) {
        cleanedKey = getSafeRouteKey();
    }
    if (keyPrefix) {
        routeKeys[cleanedKey] = "" + keyPrefix + key;
    } else {
        routeKeys[cleanedKey] = key;
    }
    // if the segment has an interception marker, make sure that's part of the regex pattern
    // this is to ensure that the route with the interception marker doesn't incorrectly match
    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])
    const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : "";
    return repeat ? optional ? "(?:/" + interceptionPrefix + "(?<" + cleanedKey + ">.+?))?" : "/" + interceptionPrefix + "(?<" + cleanedKey + ">.+?)" : "/" + interceptionPrefix + "(?<" + cleanedKey + ">[^/]+?)";
}
function getNamedParametrizedRoute(route, prefixRouteKeys) {
    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split("/");
    const getSafeRouteKey = buildGetSafeRouteKey();
    const routeKeys = {};
    return {
        namedParameterizedRoute: segments.map((segment)=>{
            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));
            const paramMatches = segment.match(/\[((?:\[.*\])|.+)\]/) // Check for parameters
            ;
            if (hasInterceptionMarker && paramMatches) {
                const [usedMarker] = segment.split(paramMatches[0]);
                return getSafeKeyFromSegment({
                    getSafeRouteKey,
                    interceptionMarker: usedMarker,
                    segment: paramMatches[1],
                    routeKeys,
                    keyPrefix: prefixRouteKeys ? _constants.NEXT_INTERCEPTION_MARKER_PREFIX : undefined
                });
            } else if (paramMatches) {
                return getSafeKeyFromSegment({
                    getSafeRouteKey,
                    segment: paramMatches[1],
                    routeKeys,
                    keyPrefix: prefixRouteKeys ? _constants.NEXT_QUERY_PARAM_PREFIX : undefined
                });
            } else {
                return "/" + (0, _escaperegexp.escapeStringRegexp)(segment);
            }
        }).join(""),
        routeKeys
    };
}
function getNamedRouteRegex(normalizedRoute, prefixRouteKey) {
    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);
    return {
        ...getRouteRegex(normalizedRoute),
        namedRegex: "^" + result.namedParameterizedRoute + "(?:/)?$",
        routeKeys: result.routeKeys
    };
}
function getNamedMiddlewareRegex(normalizedRoute, options) {
    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);
    const { catchAll = true } = options;
    if (parameterizedRoute === "/") {
        let catchAllRegex = catchAll ? ".*" : "";
        return {
            namedRegex: "^/" + catchAllRegex + "$"
        };
    }
    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);
    let catchAllGroupedRegex = catchAll ? "(?:(/.*)?)" : "";
    return {
        namedRegex: "^" + namedParameterizedRoute + catchAllGroupedRegex + "$"
    };
} //# sourceMappingURL=route-regex.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getSortedRoutes", ({
    enumerable: true,
    get: function() {
        return getSortedRoutes;
    }
}));
class UrlNode {
    insert(urlPath) {
        this._insert(urlPath.split("/").filter(Boolean), [], false);
    }
    smoosh() {
        return this._smoosh();
    }
    _smoosh(prefix) {
        if (prefix === void 0) prefix = "/";
        const childrenPaths = [
            ...this.children.keys()
        ].sort();
        if (this.slugName !== null) {
            childrenPaths.splice(childrenPaths.indexOf("[]"), 1);
        }
        if (this.restSlugName !== null) {
            childrenPaths.splice(childrenPaths.indexOf("[...]"), 1);
        }
        if (this.optionalRestSlugName !== null) {
            childrenPaths.splice(childrenPaths.indexOf("[[...]]"), 1);
        }
        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh("" + prefix + c + "/")).reduce((prev, curr)=>[
                ...prev,
                ...curr
            ], []);
        if (this.slugName !== null) {
            routes.push(...this.children.get("[]")._smoosh(prefix + "[" + this.slugName + "]/"));
        }
        if (!this.placeholder) {
            const r = prefix === "/" ? "/" : prefix.slice(0, -1);
            if (this.optionalRestSlugName != null) {
                throw new Error('You cannot define a route with the same specificity as a optional catch-all route ("' + r + '" and "' + r + "[[..." + this.optionalRestSlugName + ']]").');
            }
            routes.unshift(r);
        }
        if (this.restSlugName !== null) {
            routes.push(...this.children.get("[...]")._smoosh(prefix + "[..." + this.restSlugName + "]/"));
        }
        if (this.optionalRestSlugName !== null) {
            routes.push(...this.children.get("[[...]]")._smoosh(prefix + "[[..." + this.optionalRestSlugName + "]]/"));
        }
        return routes;
    }
    _insert(urlPaths, slugNames, isCatchAll) {
        if (urlPaths.length === 0) {
            this.placeholder = false;
            return;
        }
        if (isCatchAll) {
            throw new Error("Catch-all must be the last part of the URL.");
        }
        // The next segment in the urlPaths list
        let nextSegment = urlPaths[0];
        // Check if the segment matches `[something]`
        if (nextSegment.startsWith("[") && nextSegment.endsWith("]")) {
            // Strip `[` and `]`, leaving only `something`
            let segmentName = nextSegment.slice(1, -1);
            let isOptional = false;
            if (segmentName.startsWith("[") && segmentName.endsWith("]")) {
                // Strip optional `[` and `]`, leaving only `something`
                segmentName = segmentName.slice(1, -1);
                isOptional = true;
            }
            if (segmentName.startsWith("...")) {
                // Strip `...`, leaving only `something`
                segmentName = segmentName.substring(3);
                isCatchAll = true;
            }
            if (segmentName.startsWith("[") || segmentName.endsWith("]")) {
                throw new Error("Segment names may not start or end with extra brackets ('" + segmentName + "').");
            }
            if (segmentName.startsWith(".")) {
                throw new Error("Segment names may not start with erroneous periods ('" + segmentName + "').");
            }
            function handleSlug(previousSlug, nextSlug) {
                if (previousSlug !== null) {
                    // If the specific segment already has a slug but the slug is not `something`
                    // This prevents collisions like:
                    // pages/[post]/index.js
                    // pages/[id]/index.js
                    // Because currently multiple dynamic params on the same segment level are not supported
                    if (previousSlug !== nextSlug) {
                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.
                        throw new Error("You cannot use different slug names for the same dynamic path ('" + previousSlug + "' !== '" + nextSlug + "').");
                    }
                }
                slugNames.forEach((slug)=>{
                    if (slug === nextSlug) {
                        throw new Error('You cannot have the same slug name "' + nextSlug + '" repeat within a single dynamic path');
                    }
                    if (slug.replace(/\W/g, "") === nextSegment.replace(/\W/g, "")) {
                        throw new Error('You cannot have the slug names "' + slug + '" and "' + nextSlug + '" differ only by non-word symbols within a single dynamic path');
                    }
                });
                slugNames.push(nextSlug);
            }
            if (isCatchAll) {
                if (isOptional) {
                    if (this.restSlugName != null) {
                        throw new Error('You cannot use both an required and optional catch-all route at the same level ("[...' + this.restSlugName + ']" and "' + urlPaths[0] + '" ).');
                    }
                    handleSlug(this.optionalRestSlugName, segmentName);
                    // slugName is kept as it can only be one particular slugName
                    this.optionalRestSlugName = segmentName;
                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically
                    nextSegment = "[[...]]";
                } else {
                    if (this.optionalRestSlugName != null) {
                        throw new Error('You cannot use both an optional and required catch-all route at the same level ("[[...' + this.optionalRestSlugName + ']]" and "' + urlPaths[0] + '").');
                    }
                    handleSlug(this.restSlugName, segmentName);
                    // slugName is kept as it can only be one particular slugName
                    this.restSlugName = segmentName;
                    // nextSegment is overwritten to [...] so that it can later be sorted specifically
                    nextSegment = "[...]";
                }
            } else {
                if (isOptional) {
                    throw new Error('Optional route parameters are not yet supported ("' + urlPaths[0] + '").');
                }
                handleSlug(this.slugName, segmentName);
                // slugName is kept as it can only be one particular slugName
                this.slugName = segmentName;
                // nextSegment is overwritten to [] so that it can later be sorted specifically
                nextSegment = "[]";
            }
        }
        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode
        if (!this.children.has(nextSegment)) {
            this.children.set(nextSegment, new UrlNode());
        }
        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);
    }
    constructor(){
        this.placeholder = true;
        this.children = new Map();
        this.slugName = null;
        this.restSlugName = null;
        this.optionalRestSlugName = null;
    }
}
function getSortedRoutes(normalizedPages) {
    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment
    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js
    // Only 1 dynamic segment per nesting level
    // So in the case that is test/integration/dynamic-routing it'll be this:
    // pages/[post]/comments.js
    // pages/blog/[post]/comment/[id].js
    // Both are fine because `pages/[post]` and `pages/blog` are on the same level
    // So in this case `UrlNode` created here has `this.slugName === 'post'`
    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities
    // Instead what has to be passed through is the upwards path's dynamic names
    const root = new UrlNode();
    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels
    normalizedPages.forEach((pagePath)=>root.insert(pagePath));
    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority
    return root.smoosh();
} //# sourceMappingURL=sorted-routes.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return SideEffect;
    }
}));
const _react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
const isServer = typeof window === "undefined";
const useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;
const useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;
function SideEffect(props) {
    const { headManager, reduceComponentsToState } = props;
    function emitChange() {
        if (headManager && headManager.mountedInstances) {
            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));
            headManager.updateHead(reduceComponentsToState(headElements, props));
        }
    }
    if (isServer) {
        var _headManager_mountedInstances;
        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);
        emitChange();
    }
    useClientOnlyLayoutEffect(()=>{
        var _headManager_mountedInstances;
        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);
        return ()=>{
            var _headManager_mountedInstances;
            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);
        };
    });
    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all
    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s
    // being rendered, we only trigger the method from the last one.
    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`
    // singleton in the layout effect pass, and actually trigger it in the effect pass.
    useClientOnlyLayoutEffect(()=>{
        if (headManager) {
            headManager._pendingUpdate = emitChange;
        }
        return ()=>{
            if (headManager) {
                headManager._pendingUpdate = emitChange;
            }
        };
    });
    useClientOnlyEffect(()=>{
        if (headManager && headManager._pendingUpdate) {
            headManager._pendingUpdate();
            headManager._pendingUpdate = null;
        }
        return ()=>{
            if (headManager && headManager._pendingUpdate) {
                headManager._pendingUpdate();
                headManager._pendingUpdate = null;
            }
        };
    });
    return null;
} //# sourceMappingURL=side-effect.js.map


/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DecodeError: function() {
        return DecodeError;
    },
    MiddlewareNotFoundError: function() {
        return MiddlewareNotFoundError;
    },
    MissingStaticPage: function() {
        return MissingStaticPage;
    },
    NormalizeError: function() {
        return NormalizeError;
    },
    PageNotFoundError: function() {
        return PageNotFoundError;
    },
    SP: function() {
        return SP;
    },
    ST: function() {
        return ST;
    },
    WEB_VITALS: function() {
        return WEB_VITALS;
    },
    execOnce: function() {
        return execOnce;
    },
    getDisplayName: function() {
        return getDisplayName;
    },
    getLocationOrigin: function() {
        return getLocationOrigin;
    },
    getURL: function() {
        return getURL;
    },
    isAbsoluteUrl: function() {
        return isAbsoluteUrl;
    },
    isResSent: function() {
        return isResSent;
    },
    loadGetInitialProps: function() {
        return loadGetInitialProps;
    },
    normalizeRepeatedSlashes: function() {
        return normalizeRepeatedSlashes;
    },
    stringifyError: function() {
        return stringifyError;
    }
});
const WEB_VITALS = [
    "CLS",
    "FCP",
    "FID",
    "INP",
    "LCP",
    "TTFB"
];
function execOnce(fn) {
    let used = false;
    let result;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (!used) {
            used = true;
            result = fn(...args);
        }
        return result;
    };
}
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);
function getLocationOrigin() {
    const { protocol, hostname, port } = window.location;
    return protocol + "//" + hostname + (port ? ":" + port : "");
}
function getURL() {
    const { href } = window.location;
    const origin = getLocationOrigin();
    return href.substring(origin.length);
}
function getDisplayName(Component) {
    return typeof Component === "string" ? Component : Component.displayName || Component.name || "Unknown";
}
function isResSent(res) {
    return res.finished || res.headersSent;
}
function normalizeRepeatedSlashes(url) {
    const urlParts = url.split("?");
    const urlNoQuery = urlParts[0];
    return urlNoQuery // first we replace any non-encoded backslashes with forward
    // then normalize repeated forward slashes
    .replace(/\\/g, "/").replace(/\/\/+/g, "/") + (urlParts[1] ? "?" + urlParts.slice(1).join("?") : "");
}
async function loadGetInitialProps(App, ctx) {
    if (false) { var _App_prototype; }
    // when called from _app `ctx` is nested in `ctx`
    const res = ctx.res || ctx.ctx && ctx.ctx.res;
    if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
            // @ts-ignore pageProps default
            return {
                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
            };
        }
        return {};
    }
    const props = await App.getInitialProps(ctx);
    if (res && isResSent(res)) {
        return props;
    }
    if (!props) {
        const message = '"' + getDisplayName(App) + '.getInitialProps()" should resolve to an object. But found "' + props + '" instead.';
        throw new Error(message);
    }
    if (false) {}
    return props;
}
const SP = typeof performance !== "undefined";
const ST = SP && [
    "mark",
    "measure",
    "getEntriesByName"
].every((method)=>typeof performance[method] === "function");
class DecodeError extends Error {
}
class NormalizeError extends Error {
}
class PageNotFoundError extends Error {
    constructor(page){
        super();
        this.code = "ENOENT";
        this.name = "PageNotFoundError";
        this.message = "Cannot find module for page: " + page;
    }
}
class MissingStaticPage extends Error {
    constructor(page, message){
        super();
        this.message = "Failed to load static file for page: " + page + " " + message;
    }
}
class MiddlewareNotFoundError extends Error {
    constructor(){
        super();
        this.code = "ENOENT";
        this.message = "Cannot find the middleware module";
    }
}
function stringifyError(error) {
    return JSON.stringify({
        message: error.message,
        stack: error.stack
    });
} //# sourceMappingURL=utils.js.map


/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/components/404/index.client.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  NotFoundLink: function() { return /* binding */ NotFoundLink; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ./node_modules/next/dist/api/navigation.js
var navigation = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/api/navigation.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/hooks/use-mounted.js
var use_mounted = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-mounted.js");
// EXTERNAL MODULE: ../../node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/mdx-components/anchor.js + 1 modules
var mdx_components_anchor = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/mdx-components/anchor.js");
;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/mdx-components/link.js




const Link = (t0)=>{
    const $ = (0,dist.c)(8);
    let className;
    let props;
    if ($[0] !== t0) {
        ({ className, ...props } = t0);
        $[0] = t0;
        $[1] = className;
        $[2] = props;
    } else {
        className = $[1];
        props = $[2];
    }
    let t1;
    if ($[3] !== className) {
        t1 = (0,clsx/* default */.Z)("x:text-primary-600 x:underline x:hover:no-underline x:decoration-from-font x:[text-underline-position:from-font]", className);
        $[3] = className;
        $[4] = t1;
    } else {
        t1 = $[4];
    }
    let t2;
    if ($[5] !== props || $[6] !== t1) {
        t2 = /* @__PURE__ */ (0,jsx_runtime.jsx)(mdx_components_anchor/* Anchor */.e, {
            className: t1,
            ...props
        });
        $[5] = props;
        $[6] = t1;
        $[7] = t2;
    } else {
        t2 = $[7];
    }
    return t2;
};


// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/theme-config.js
var theme_config = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/theme-config.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/utils/get-git-issue-url.js
var get_git_issue_url = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/utils/get-git-issue-url.js");
;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/components/404/index.client.js
/* __next_internal_client_entry_do_not_use__ NotFoundLink auto */ 






const NotFoundLink = (t0)=>{
    const $ = (0,dist.c)(7);
    const { children, labels } = t0;
    const config = (0,theme_config.useThemeConfig)();
    const pathname = (0,navigation.usePathname)();
    const mounted = (0,use_mounted.useMounted)();
    const ref = mounted && document.referrer;
    const referrer = ref ? ' from "'.concat(ref, '"') : "";
    const t1 = 'Found broken "'.concat(mounted ? pathname : "", '" link').concat(referrer, ". Please fix!");
    let t2;
    if ($[0] !== config.docsRepositoryBase || $[1] !== labels || $[2] !== t1) {
        t2 = (0,get_git_issue_url/* getGitIssueUrl */.K)({
            repository: config.docsRepositoryBase,
            title: t1,
            labels
        });
        $[0] = config.docsRepositoryBase;
        $[1] = labels;
        $[2] = t1;
        $[3] = t2;
    } else {
        t2 = $[3];
    }
    let t3;
    if ($[4] !== children || $[5] !== t2) {
        t3 = /* @__PURE__ */ (0,jsx_runtime.jsx)(Link, {
            className: "x:mt-[1.25em]",
            href: t2,
            children
        });
        $[4] = children;
        $[5] = t2;
        $[6] = t3;
    } else {
        t3 = $[6];
    }
    return t3;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/components/footer/switchers.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Switchers: function() { return /* binding */ Switchers; }
/* harmony export */ });
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/config.js");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/theme-config.js");
/* __next_internal_client_entry_do_not_use__ Switchers auto */ 
const Switchers = (t0)=>{
    const { children } = t0;
    const { hideSidebar } = (0,_stores__WEBPACK_IMPORTED_MODULE_0__.useConfig)();
    const { i18n, darkMode } = (0,_stores__WEBPACK_IMPORTED_MODULE_1__.useThemeConfig)();
    if (hideSidebar && (darkMode || i18n.length)) {
        return children;
    }
    return null;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/components/last-updated.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LastUpdated: function() { return /* binding */ LastUpdated; }
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/api/navigation.js");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/theme-config.js");
/* __next_internal_client_entry_do_not_use__ LastUpdated auto */ 



const LastUpdated = (t0)=>{
    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(15);
    const { date, children: t1, locale: t2 } = t0;
    const children = t1 === void 0 ? "Last updated on" : t1;
    const locale = t2 === void 0 ? "en" : t2;
    const { i18n } = (0,_stores__WEBPACK_IMPORTED_MODULE_3__.useThemeConfig)();
    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.usePathname)();
    if (!date) {
        return null;
    }
    let t3;
    if ($[0] !== i18n.length || $[1] !== locale || $[2] !== pathname) {
        t3 = i18n.length ? pathname.split("/", 2)[1] : locale;
        $[0] = i18n.length;
        $[1] = locale;
        $[2] = pathname;
        $[3] = t3;
    } else {
        t3 = $[3];
    }
    const dateLocale = t3;
    let t4;
    if ($[4] !== date) {
        t4 = date.toISOString();
        $[4] = date;
        $[5] = t4;
    } else {
        t4 = $[5];
    }
    let t5;
    if ($[6] !== date || $[7] !== dateLocale) {
        t5 = date.toLocaleDateString(dateLocale, {
            day: "numeric",
            month: "long",
            year: "numeric"
        });
        $[6] = date;
        $[7] = dateLocale;
        $[8] = t5;
    } else {
        t5 = $[8];
    }
    let t6;
    if ($[9] !== t4 || $[10] !== t5) {
        t6 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("time", {
            dateTime: t4,
            suppressHydrationWarning: true,
            children: t5
        });
        $[9] = t4;
        $[10] = t5;
        $[11] = t6;
    } else {
        t6 = $[11];
    }
    let t7;
    if ($[12] !== children || $[13] !== t6) {
        t7 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
            children: [
                children,
                " ",
                t6
            ]
        });
        $[12] = children;
        $[13] = t6;
        $[14] = t7;
    } else {
        t7 = $[14];
    }
    return t7;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/components/locale-switch.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  LocaleSwitch: function() { return /* binding */ LocaleSwitch; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ./node_modules/next/dist/client/add-base-path.js
var add_base_path = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js");
// EXTERNAL MODULE: ./node_modules/next/dist/api/navigation.js
var navigation = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/api/navigation.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/components/select.js + 3 modules
var components_select = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/components/select.js");
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/icons/globe.js


const SvgGlobe = (props) => {
  const $ = (0,dist.c)(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", d: "M4.083 9h1.946c.089-1.546.383-2.97.837-4.118A6.004 6.004 0 004.083 9zM10 2a8 8 0 100 16 8 8 0 000-16zm0 2c-.076 0-.232.032-.465.262-.238.234-.497.623-.737 1.182-.389.907-.673 2.142-.766 3.556h3.936c-.093-1.414-.377-2.649-.766-3.556-.24-.56-.5-.948-.737-1.182C10.232 4.032 10.076 4 10 4zm3.971 5c-.089-1.546-.383-2.97-.837-4.118A6.004 6.004 0 0115.917 9h-1.946zm-2.003 2H8.032c.093 1.414.377 2.649.766 3.556.24.56.5.948.737 1.182.233.23.389.262.465.262.076 0 .232-.032.465-.262.238-.234.498-.623.737-1.182.389-.907.673-2.142.766-3.556zm1.166 4.118c.454-1.147.748-2.572.837-4.118h1.946a6.004 6.004 0 01-2.783 4.118zm-6.268 0C6.412 13.97 6.118 12.546 6.03 11H4.083a6.004 6.004 0 002.783 4.118z" });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "2 2 16 16", fill: "currentColor", ...props, children: t0 });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
};


// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/theme-config.js
var theme_config = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/theme-config.js");
;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/components/locale-switch.js
/* __next_internal_client_entry_do_not_use__ LocaleSwitch auto */ 







const ONE_YEAR = 365 * 24 * 60 * 60 * 1e3;
const LocaleSwitch = (t0)=>{
    const $ = (0,dist.c)(22);
    const { lite, className } = t0;
    const { i18n } = (0,theme_config.useThemeConfig)();
    const pathname = (0,navigation.usePathname)();
    if (!i18n.length) {
        return null;
    }
    let t1;
    if ($[0] !== pathname) {
        t1 = pathname.split("/", 2);
        $[0] = pathname;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    const [, locale] = t1;
    let t2;
    if ($[2] !== className) {
        t2 = (0,clsx/* default */.Z)("x:flex x:items-center x:gap-2", className);
        $[2] = className;
        $[3] = t2;
    } else {
        t2 = $[3];
    }
    let t3;
    if ($[4] !== locale || $[5] !== pathname) {
        t3 = (lang)=>{
            const date = new Date(Date.now() + ONE_YEAR);
            document.cookie = "NEXT_LOCALE=".concat(lang, "; expires=").concat(date.toUTCString(), "; path=/");
            location.href = (0,add_base_path.addBasePath)(pathname.replace("/".concat(locale), "/".concat(lang)));
        };
        $[4] = locale;
        $[5] = pathname;
        $[6] = t3;
    } else {
        t3 = $[6];
    }
    let t4;
    if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
        t4 = /* @__PURE__ */ (0,jsx_runtime.jsx)(SvgGlobe, {
            height: "12"
        });
        $[7] = t4;
    } else {
        t4 = $[7];
    }
    let t5;
    if ($[8] !== i18n || $[9] !== lite || $[10] !== locale) {
        var _i18n_find;
        t5 = !lite && ((_i18n_find = i18n.find((l)=>locale === l.locale)) === null || _i18n_find === void 0 ? void 0 : _i18n_find.name);
        $[8] = i18n;
        $[9] = lite;
        $[10] = locale;
        $[11] = t5;
    } else {
        t5 = $[11];
    }
    let t6;
    if ($[12] !== t5) {
        t6 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                t4,
                t5
            ]
        });
        $[12] = t5;
        $[13] = t6;
    } else {
        t6 = $[13];
    }
    let t7;
    if ($[14] !== i18n) {
        t7 = i18n.map(_temp);
        $[14] = i18n;
        $[15] = t7;
    } else {
        t7 = $[15];
    }
    let t8;
    if ($[16] !== locale || $[17] !== t2 || $[18] !== t3 || $[19] !== t6 || $[20] !== t7) {
        t8 = /* @__PURE__ */ (0,jsx_runtime.jsx)(components_select.Select, {
            title: "Change language",
            className: t2,
            onChange: t3,
            value: locale,
            selectedOption: t6,
            options: t7
        });
        $[16] = locale;
        $[17] = t2;
        $[18] = t3;
        $[19] = t6;
        $[20] = t7;
        $[21] = t8;
    } else {
        t8 = $[21];
    }
    return t8;
};
function _temp(l_0) {
    return {
        id: l_0.locale,
        name: l_0.name
    };
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/components/navbar/index.client.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ClientNavbar: function() { return /* binding */ ClientNavbar; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/@react-aria/focus/dist/useFocusRing.mjs + 8 modules
var useFocusRing = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/focus/dist/useFocusRing.mjs");
// EXTERNAL MODULE: ../../node_modules/@react-aria/interactions/dist/useHover.mjs
var useHover = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/interactions/dist/useHover.mjs");
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/index.js
var react_dom = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-active-press.js
var use_active_press = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-active-press.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
var use_disposables = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-disposables.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-element-size.js
var use_element_size = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-element-size.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-event.js
var use_event = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-inert-others.js
var use_inert_others = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-inert-others.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var use_iso_morphic_effect = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-on-disappear.js
var use_on_disappear = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-on-disappear.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js + 1 modules
var use_outside_click = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-owner.js
var use_owner = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-owner.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-quick-release.js
var use_quick_release = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-quick-release.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
var use_resolve_button_type = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-scroll-lock.js + 7 modules
var use_scroll_lock = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-scroll-lock.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-slot.js
var use_slot = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-slot.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var use_sync_refs = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-text-value.js + 1 modules
var use_text_value = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-text-value.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js
var use_tracked_pointer = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-transition.js + 1 modules
var use_transition = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-transition.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js
var use_tree_walker = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/floating.js
var floating = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/floating.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/open-closed.js
var open_closed = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/open-closed.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/machines/stack-machine.js
var stack_machine = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/machines/stack-machine.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/react-glue.js
var react_glue = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/react-glue.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/bugs.js
var bugs = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/bugs.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js
var calculate_active_index = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/disposables.js
var disposables = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/dom.js
var dom = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/focus-management.js
var focus_management = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/focus-management.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/match.js
var match = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/match.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/render.js + 1 modules
var render = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/render.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/description/description.js
var description = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/description/description.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/keyboard.js
var keyboard = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/keyboard.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/label/label.js
var label = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/label/label.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/mouse.js
var mouse = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/mouse.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/portal/portal.js + 1 modules
var portal = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/portal/portal.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/machine.js
var machine = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/machine.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/element-movement.js
var element_movement = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/element-movement.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/components/menu/menu-machine.js
var y = Object.defineProperty;
var M = (e, i, t)=>i in e ? y(e, i, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : e[i] = t;
var S = (e, i, t)=>(M(e, typeof i != "symbol" ? i + "" : i, t), t);






var menu_machine_P = ((t)=>(t[t.Open = 0] = "Open", t[t.Closed = 1] = "Closed", t))(menu_machine_P || {}), menu_machine_D = ((t)=>(t[t.Pointer = 0] = "Pointer", t[t.Other = 1] = "Other", t))(menu_machine_D || {}), C = ((o)=>(o[o.OpenMenu = 0] = "OpenMenu", o[o.CloseMenu = 1] = "CloseMenu", o[o.GoToItem = 2] = "GoToItem", o[o.Search = 3] = "Search", o[o.ClearSearch = 4] = "ClearSearch", o[o.RegisterItems = 5] = "RegisterItems", o[o.UnregisterItems = 6] = "UnregisterItems", o[o.SetButtonElement = 7] = "SetButtonElement", o[o.SetItemsElement = 8] = "SetItemsElement", o[o.SortItems = 9] = "SortItems", o[o.MarkButtonAsMoved = 10] = "MarkButtonAsMoved", o))(C || {});
function x(e) {
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (t)=>t;
    let t = e.activeItemIndex !== null ? e.items[e.activeItemIndex] : null, n = (0,focus_management/* sortByDomNode */.z2)(i(e.items.slice()), (s)=>s.dataRef.current.domRef.current), r = t ? n.indexOf(t) : null;
    return r === -1 && (r = null), {
        items: n,
        activeItemIndex: r
    };
}
let k = {
    [1] (e) {
        if (e.menuState === 1) return e;
        let i = e.buttonElement ? element_movement/* ElementPositionState */.On.Tracked((0,element_movement/* computeVisualPosition */.kn)(e.buttonElement)) : e.buttonPositionState;
        return {
            ...e,
            activeItemIndex: null,
            pendingFocus: {
                focus: calculate_active_index/* Focus */.T.Nothing
            },
            menuState: 1,
            buttonPositionState: i
        };
    },
    [0] (e, i) {
        return e.menuState === 0 ? e : {
            ...e,
            __demoMode: !1,
            pendingFocus: i.focus,
            menuState: 0,
            buttonPositionState: element_movement/* ElementPositionState */.On.Idle
        };
    },
    [2]: (e, i)=>{
        var s, l, a, I, f;
        if (e.menuState === 1) return e;
        let t = {
            ...e,
            searchQuery: "",
            activationTrigger: (s = i.trigger) != null ? s : 1,
            __demoMode: !1
        };
        if (i.focus === calculate_active_index/* Focus */.T.Nothing) return {
            ...t,
            activeItemIndex: null
        };
        if (i.focus === calculate_active_index/* Focus */.T.Specific) return {
            ...t,
            activeItemIndex: e.items.findIndex((d)=>d.id === i.id)
        };
        if (i.focus === calculate_active_index/* Focus */.T.Previous) {
            let d = e.activeItemIndex;
            if (d !== null) {
                let o = e.items[d].dataRef.current.domRef, c = (0,calculate_active_index/* calculateActiveIndex */.d)(i, {
                    resolveItems: ()=>e.items,
                    resolveActiveIndex: ()=>e.activeItemIndex,
                    resolveId: (u)=>u.id,
                    resolveDisabled: (u)=>u.dataRef.current.disabled
                });
                if (c !== null) {
                    let u = e.items[c].dataRef.current.domRef;
                    if (((l = o.current) == null ? void 0 : l.previousElementSibling) === u.current || ((a = u.current) == null ? void 0 : a.previousElementSibling) === null) return {
                        ...t,
                        activeItemIndex: c
                    };
                }
            }
        } else if (i.focus === calculate_active_index/* Focus */.T.Next) {
            let d = e.activeItemIndex;
            if (d !== null) {
                let o = e.items[d].dataRef.current.domRef, c = (0,calculate_active_index/* calculateActiveIndex */.d)(i, {
                    resolveItems: ()=>e.items,
                    resolveActiveIndex: ()=>e.activeItemIndex,
                    resolveId: (u)=>u.id,
                    resolveDisabled: (u)=>u.dataRef.current.disabled
                });
                if (c !== null) {
                    let u = e.items[c].dataRef.current.domRef;
                    if (((I = o.current) == null ? void 0 : I.nextElementSibling) === u.current || ((f = u.current) == null ? void 0 : f.nextElementSibling) === null) return {
                        ...t,
                        activeItemIndex: c
                    };
                }
            }
        }
        let n = x(e), r = (0,calculate_active_index/* calculateActiveIndex */.d)(i, {
            resolveItems: ()=>n.items,
            resolveActiveIndex: ()=>n.activeItemIndex,
            resolveId: (d)=>d.id,
            resolveDisabled: (d)=>d.dataRef.current.disabled
        });
        return {
            ...t,
            ...n,
            activeItemIndex: r
        };
    },
    [3]: (e, i)=>{
        let n = e.searchQuery !== "" ? 0 : 1, r = e.searchQuery + i.value.toLowerCase(), l = (e.activeItemIndex !== null ? e.items.slice(e.activeItemIndex + n).concat(e.items.slice(0, e.activeItemIndex + n)) : e.items).find((I)=>{
            var f;
            return ((f = I.dataRef.current.textValue) == null ? void 0 : f.startsWith(r)) && !I.dataRef.current.disabled;
        }), a = l ? e.items.indexOf(l) : -1;
        return a === -1 || a === e.activeItemIndex ? {
            ...e,
            searchQuery: r
        } : {
            ...e,
            searchQuery: r,
            activeItemIndex: a,
            activationTrigger: 1
        };
    },
    [4] (e) {
        return e.searchQuery === "" ? e : {
            ...e,
            searchQuery: "",
            searchActiveItemIndex: null
        };
    },
    [5]: (e, i)=>{
        let t = e.items.concat(i.items.map((r)=>r)), n = e.activeItemIndex;
        return e.pendingFocus.focus !== calculate_active_index/* Focus */.T.Nothing && (n = (0,calculate_active_index/* calculateActiveIndex */.d)(e.pendingFocus, {
            resolveItems: ()=>t,
            resolveActiveIndex: ()=>e.activeItemIndex,
            resolveId: (r)=>r.id,
            resolveDisabled: (r)=>r.dataRef.current.disabled
        })), {
            ...e,
            items: t,
            activeItemIndex: n,
            pendingFocus: {
                focus: calculate_active_index/* Focus */.T.Nothing
            },
            pendingShouldSort: !0
        };
    },
    [6]: (e, i)=>{
        let t = e.items, n = [], r = new Set(i.items);
        for (let [s, l] of t.entries())if (r.has(l.id) && (n.push(s), r.delete(l.id), r.size === 0)) break;
        if (n.length > 0) {
            t = t.slice();
            for (let s of n.reverse())t.splice(s, 1);
        }
        return {
            ...e,
            items: t,
            activationTrigger: 1
        };
    },
    [7]: (e, i)=>e.buttonElement === i.element ? e : {
            ...e,
            buttonElement: i.element
        },
    [8]: (e, i)=>e.itemsElement === i.element ? e : {
            ...e,
            itemsElement: i.element
        },
    [9]: (e)=>e.pendingShouldSort ? {
            ...e,
            ...x(e),
            pendingShouldSort: !1
        } : e,
    [10] (e) {
        return e.buttonPositionState.kind !== "Tracked" ? e : {
            ...e,
            buttonPositionState: element_movement/* ElementPositionState */.On.Moved
        };
    }
};
class h extends machine/* Machine */.J {
    static new(param) {
        let { id: t, __demoMode: n = !1 } = param;
        return new h({
            id: t,
            __demoMode: n,
            menuState: n ? 0 : 1,
            buttonElement: null,
            itemsElement: null,
            items: [],
            searchQuery: "",
            activeItemIndex: null,
            activationTrigger: 1,
            pendingShouldSort: !1,
            pendingFocus: {
                focus: calculate_active_index/* Focus */.T.Nothing
            },
            buttonPositionState: element_movement/* ElementPositionState */.On.Idle
        });
    }
    reduce(t, n) {
        return (0,match/* match */.E)(n.type, k, t, n);
    }
    constructor(t){
        super(t);
        S(this, "actions", {
            registerItem: (0,machine/* batch */.dC)(()=>{
                let t = [], n = new Set;
                return [
                    (r, s)=>{
                        n.has(s) || (n.add(s), t.push({
                            id: r,
                            dataRef: s
                        }));
                    },
                    ()=>(n.clear(), this.send({
                            type: 5,
                            items: t.splice(0)
                        }))
                ];
            }),
            unregisterItem: (0,machine/* batch */.dC)(()=>{
                let t = [];
                return [
                    (n)=>t.push(n),
                    ()=>this.send({
                            type: 6,
                            items: t.splice(0)
                        })
                ];
            })
        });
        S(this, "selectors", {
            activeDescendantId (t) {
                var s;
                let n = t.activeItemIndex, r = t.items;
                return n === null || (s = r[n]) == null ? void 0 : s.id;
            },
            isActive (t, n) {
                var l;
                let r = t.activeItemIndex, s = t.items;
                return r !== null ? ((l = s[r]) == null ? void 0 : l.id) === n : !1;
            },
            shouldScrollIntoView (t, n) {
                return t.__demoMode || t.menuState !== 0 || t.activationTrigger === 0 ? !1 : this.isActive(t, n);
            },
            didButtonMove (t) {
                return t.buttonPositionState.kind === "Moved";
            }
        });
        this.on(5, ()=>{
            this.disposables.requestAnimationFrame(()=>{
                this.send({
                    type: 9
                });
            });
        });
        {
            let n = this.state.id, r = stack_machine/* stackMachines */.n.get(null);
            this.disposables.add(r.on(stack_machine/* ActionTypes */.M.Push, (s)=>{
                !r.selectors.isTop(s, n) && this.state.menuState === 0 && this.send({
                    type: 1
                });
            })), this.on(0, ()=>r.actions.push(n)), this.on(1, ()=>r.actions.pop(n));
        }
        this.disposables.group((n)=>{
            this.on(1, (r)=>{
                r.buttonElement && (n.dispose(), n.add((0,element_movement/* detectMovement */.hS)(r.buttonElement, r.buttonPositionState, ()=>{
                    this.send({
                        type: 10
                    });
                })));
            });
        });
    }
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-on-unmount.js
var use_on_unmount = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-on-unmount.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/components/menu/menu-machine-glue.js



const menu_machine_glue_a = /*#__PURE__*/ (0,react.createContext)(null);
function menu_machine_glue_p(t) {
    let n = (0,react.useContext)(menu_machine_glue_a);
    if (n === null) {
        let e = new Error("<".concat(t, " /> is missing a parent <Menu /> component."));
        throw Error.captureStackTrace && Error.captureStackTrace(e, menu_machine_glue_s), e;
    }
    return n;
}
function menu_machine_glue_s(param) {
    let { id: t, __demoMode: n = !1 } = param;
    let e = (0,react.useMemo)(()=>h.new({
            id: t,
            __demoMode: n
        }), []);
    return (0,use_on_unmount/* useOnUnmount */.L)(()=>e.dispose()), e;
}


;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/components/menu/menu.js
/* __next_internal_client_entry_do_not_use__ Menu,MenuButton,MenuHeading,MenuItem,MenuItems,MenuSection,MenuSeparator auto */ 








































let Ze = react.Fragment;
function et(T, g) {
    let l = (0,react.useId)(), { __demoMode: a = !1, ...p } = T, s = menu_machine_glue_s({
        id: l,
        __demoMode: a
    }), [n, b, P] = (0,react_glue/* useSlice */.M)(s, (f)=>[
            f.menuState,
            f.itemsElement,
            f.buttonElement
        ]), I = (0,use_sync_refs/* useSyncRefs */.T)(g), t = stack_machine/* stackMachines */.n.get(null), h = (0,react_glue/* useSlice */.M)(t, (0,react.useCallback)((f)=>t.selectors.isTop(f, l), [
        t,
        l
    ]));
    (0,use_outside_click/* useOutsideClick */.O)(h, [
        P,
        b
    ], (f, m)=>{
        var E;
        s.send({
            type: C.CloseMenu
        }), (0,focus_management/* isFocusableElement */.sP)(m, focus_management/* FocusableMode */.tJ.Loose) || (f.preventDefault(), (E = s.state.buttonElement) == null || E.focus());
    });
    let R = (0,use_event/* useEvent */.z)(()=>{
        s.send({
            type: C.CloseMenu
        });
    }), A = (0,use_slot/* useSlot */.x)({
        open: n === menu_machine_P.Open,
        close: R
    }), u = {
        ref: I
    }, M = (0,render/* useRender */.L6)();
    return /*#__PURE__*/ react.createElement(floating/* FloatingProvider */.HO, null, /*#__PURE__*/ react.createElement(menu_machine_glue_a.Provider, {
        value: s
    }, /*#__PURE__*/ react.createElement(open_closed/* OpenClosedProvider */.up, {
        value: (0,match/* match */.E)(n, {
            [menu_machine_P.Open]: open_closed/* State */.ZM.Open,
            [menu_machine_P.Closed]: open_closed/* State */.ZM.Closed
        })
    }, M({
        ourProps: u,
        theirProps: p,
        slot: A,
        defaultTag: Ze,
        name: "Menu"
    }))));
}
let tt = "button";
function ot(T, g) {
    let l = menu_machine_glue_p("Menu.Button"), a = (0,react.useId)(), { id: p = "headlessui-menu-button-".concat(a), disabled: s = !1, autoFocus: n = !1, ...b } = T, P = (0,react.useRef)(null), I = (0,floating/* useFloatingReferenceProps */.L)(), t = (0,use_sync_refs/* useSyncRefs */.T)(g, P, (0,floating/* useFloatingReference */.AZ)(), (0,use_event/* useEvent */.z)((o)=>l.send({
            type: C.SetButtonElement,
            element: o
        }))), h = (0,use_event/* useEvent */.z)((o)=>{
        switch(o.key){
            case keyboard/* Keys */.R.Space:
            case keyboard/* Keys */.R.Enter:
            case keyboard/* Keys */.R.ArrowDown:
                o.preventDefault(), o.stopPropagation(), l.send({
                    type: C.OpenMenu,
                    focus: {
                        focus: calculate_active_index/* Focus */.T.First
                    }
                });
                break;
            case keyboard/* Keys */.R.ArrowUp:
                o.preventDefault(), o.stopPropagation(), l.send({
                    type: C.OpenMenu,
                    focus: {
                        focus: calculate_active_index/* Focus */.T.Last
                    }
                });
                break;
        }
    }), R = (0,use_event/* useEvent */.z)((o)=>{
        switch(o.key){
            case keyboard/* Keys */.R.Space:
                o.preventDefault();
                break;
        }
    }), [A, u, M] = (0,react_glue/* useSlice */.M)(l, (o)=>[
            o.menuState,
            o.buttonElement,
            o.itemsElement
        ]), f = A === menu_machine_P.Open;
    (0,use_quick_release/* useQuickRelease */.G)(f, {
        trigger: u,
        action: (0,react.useCallback)((o)=>{
            if (u != null && u.contains(o.target)) return use_quick_release/* Action */.a.Ignore;
            let x = o.target.closest('[role="menuitem"]:not([data-disabled])');
            return dom/* isHTMLElement */.Re(x) ? use_quick_release/* Action */.a.Select(x) : M != null && M.contains(o.target) ? use_quick_release/* Action */.a.Ignore : use_quick_release/* Action */.a.Close;
        }, [
            u,
            M
        ]),
        close: (0,react.useCallback)(()=>l.send({
                type: C.CloseMenu
            }), []),
        select: (0,react.useCallback)((o)=>o.click(), [])
    });
    let m = (0,use_event/* useEvent */.z)((o)=>{
        var x;
        if (o.button === mouse/* MouseButton */.t.Left) {
            if ((0,bugs/* isDisabledReactIssue7711 */.P)(o.currentTarget)) return o.preventDefault();
            s || (A === menu_machine_P.Open ? ((0,react_dom.flushSync)(()=>l.send({
                    type: C.CloseMenu
                })), (x = P.current) == null || x.focus({
                preventScroll: !0
            })) : (o.preventDefault(), l.send({
                type: C.OpenMenu,
                focus: {
                    focus: calculate_active_index/* Focus */.T.Nothing
                },
                trigger: menu_machine_D.Pointer
            })));
        }
    }), E = (0,react.useRef)(null), H = (0,use_event/* useEvent */.z)((o)=>{
        E.current = o.pointerType, o.pointerType === "mouse" && m(o);
    }), D = (0,use_event/* useEvent */.z)((o)=>{
        E.current !== "mouse" && m(o);
    }), { isFocusVisible: O, focusProps: F } = (0,useFocusRing/* useFocusRing */.F)({
        autoFocus: n
    }), { isHovered: k, hoverProps: U } = (0,useHover/* useHover */.X)({
        isDisabled: s
    }), { pressed: N, pressProps: B } = (0,use_active_press/* useActivePress */.x)({
        disabled: s
    }), i = (0,use_slot/* useSlot */.x)({
        open: A === menu_machine_P.Open,
        active: N || A === menu_machine_P.Open,
        disabled: s,
        hover: k,
        focus: O,
        autofocus: n
    }), G = (0,render/* mergeProps */.dG)(I(), {
        ref: t,
        id: p,
        type: (0,use_resolve_button_type/* useResolveButtonType */.f)(T, P.current),
        "aria-haspopup": "menu",
        "aria-controls": M == null ? void 0 : M.id,
        "aria-expanded": A === menu_machine_P.Open,
        disabled: s || void 0,
        autoFocus: n,
        onKeyDown: h,
        onKeyUp: R,
        onPointerDown: H,
        onClick: D
    }, F, U, B);
    return (0,render/* useRender */.L6)()({
        ourProps: G,
        theirProps: b,
        slot: i,
        defaultTag: tt,
        name: "Menu.Button"
    });
}
let nt = "div", rt = render/* RenderFeatures */.VN.RenderStrategy | render/* RenderFeatures */.VN.Static;
function at(T, g) {
    let l = (0,react.useId)(), { id: a = "headlessui-menu-items-".concat(l), anchor: p, portal: s = !1, modal: n = !0, transition: b = !1, ...P } = T, I = (0,floating/* useResolvedAnchor */.Vy)(p), t = menu_machine_glue_p("Menu.Items"), [h, R] = (0,floating/* useFloatingPanel */.ES)(I), A = (0,floating/* useFloatingPanelProps */.U8)(), [u, M] = (0,react.useState)(null), f = (0,use_sync_refs/* useSyncRefs */.T)(g, I ? h : null, (0,use_event/* useEvent */.z)((e)=>t.send({
            type: C.SetItemsElement,
            element: e
        })), M), [m, E] = (0,react_glue/* useSlice */.M)(t, (e)=>[
            e.menuState,
            e.buttonElement
        ]), H = (0,use_owner/* useOwnerDocument */.i)(E), D = (0,use_owner/* useOwnerDocument */.i)(u);
    I && (s = !0);
    let O = (0,open_closed/* useOpenClosed */.oJ)(), [F, k] = (0,use_transition/* useTransition */.Y)(b, u, O !== null ? (O & open_closed/* State */.ZM.Open) === open_closed/* State */.ZM.Open : m === menu_machine_P.Open);
    (0,use_on_disappear/* useOnDisappear */.m)(F, E, ()=>{
        t.send({
            type: C.CloseMenu
        });
    });
    let U = (0,react_glue/* useSlice */.M)(t, (e)=>e.__demoMode), N = U ? !1 : n && m === menu_machine_P.Open;
    (0,use_scroll_lock/* useScrollLock */.P)(N, D);
    let B = U ? !1 : n && m === menu_machine_P.Open;
    (0,use_inert_others/* useInertOthers */.s)(B, {
        allowed: (0,react.useCallback)(()=>[
                E,
                u
            ], [
            E,
            u
        ])
    });
    let G = (0,react_glue/* useSlice */.M)(t, t.selectors.didButtonMove) ? !1 : F;
    (0,react.useEffect)(()=>{
        let e = u;
        e && m === menu_machine_P.Open && e !== (D == null ? void 0 : D.activeElement) && e.focus({
            preventScroll: !0
        });
    }, [
        m,
        u,
        D
    ]), (0,use_tree_walker/* useTreeWalker */.B)(m === menu_machine_P.Open, {
        container: u,
        accept (e) {
            return e.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : e.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
        },
        walk (e) {
            e.setAttribute("role", "none");
        }
    });
    let q = (0,use_disposables/* useDisposables */.G)(), o = (0,use_event/* useEvent */.z)((e)=>{
        var w, ee, te;
        switch(q.dispose(), e.key){
            case keyboard/* Keys */.R.Space:
                if (t.state.searchQuery !== "") return e.preventDefault(), e.stopPropagation(), t.send({
                    type: C.Search,
                    value: e.key
                });
            case keyboard/* Keys */.R.Enter:
                if (e.preventDefault(), e.stopPropagation(), t.state.activeItemIndex !== null) {
                    let { dataRef: de } = t.state.items[t.state.activeItemIndex];
                    (ee = (w = de.current) == null ? void 0 : w.domRef.current) == null || ee.click();
                }
                t.send({
                    type: C.CloseMenu
                }), (0,focus_management/* restoreFocusIfNecessary */.wI)(t.state.buttonElement);
                break;
            case keyboard/* Keys */.R.ArrowDown:
                return e.preventDefault(), e.stopPropagation(), t.send({
                    type: C.GoToItem,
                    focus: calculate_active_index/* Focus */.T.Next
                });
            case keyboard/* Keys */.R.ArrowUp:
                return e.preventDefault(), e.stopPropagation(), t.send({
                    type: C.GoToItem,
                    focus: calculate_active_index/* Focus */.T.Previous
                });
            case keyboard/* Keys */.R.Home:
            case keyboard/* Keys */.R.PageUp:
                return e.preventDefault(), e.stopPropagation(), t.send({
                    type: C.GoToItem,
                    focus: calculate_active_index/* Focus */.T.First
                });
            case keyboard/* Keys */.R.End:
            case keyboard/* Keys */.R.PageDown:
                return e.preventDefault(), e.stopPropagation(), t.send({
                    type: C.GoToItem,
                    focus: calculate_active_index/* Focus */.T.Last
                });
            case keyboard/* Keys */.R.Escape:
                e.preventDefault(), e.stopPropagation(), (0,react_dom.flushSync)(()=>t.send({
                        type: C.CloseMenu
                    })), (te = t.state.buttonElement) == null || te.focus({
                    preventScroll: !0
                });
                break;
            case keyboard/* Keys */.R.Tab:
                e.preventDefault(), e.stopPropagation(), (0,react_dom.flushSync)(()=>t.send({
                        type: C.CloseMenu
                    })), (0,focus_management/* focusFrom */.EO)(t.state.buttonElement, e.shiftKey ? focus_management/* Focus */.TO.Previous : focus_management/* Focus */.TO.Next);
                break;
            default:
                e.key.length === 1 && (t.send({
                    type: C.Search,
                    value: e.key
                }), q.setTimeout(()=>t.send({
                        type: C.ClearSearch
                    }), 350));
                break;
        }
    }), x = (0,use_event/* useEvent */.z)((e)=>{
        switch(e.key){
            case keyboard/* Keys */.R.Space:
                e.preventDefault();
                break;
        }
    }), ie = (0,use_slot/* useSlot */.x)({
        open: m === menu_machine_P.Open
    }), ue = (0,render/* mergeProps */.dG)(I ? A() : {}, {
        "aria-activedescendant": (0,react_glue/* useSlice */.M)(t, t.selectors.activeDescendantId),
        "aria-labelledby": (0,react_glue/* useSlice */.M)(t, (e)=>{
            var w;
            return (w = e.buttonElement) == null ? void 0 : w.id;
        }),
        id: a,
        onKeyDown: o,
        onKeyUp: x,
        role: "menu",
        tabIndex: m === menu_machine_P.Open ? 0 : void 0,
        ref: f,
        style: {
            ...P.style,
            ...R,
            "--button-width": (0,use_element_size/* useElementSize */.h)(F, E, !0).width
        },
        ...(0,use_transition/* transitionDataAttributes */.X)(k)
    }), me = (0,render/* useRender */.L6)();
    return /*#__PURE__*/ react.createElement(portal/* Portal */.h_, {
        enabled: s ? T.static || F : !1,
        ownerDocument: H
    }, me({
        ourProps: ue,
        theirProps: P,
        slot: ie,
        defaultTag: nt,
        features: rt,
        visible: G,
        name: "Menu.Items"
    }));
}
let st = react.Fragment;
function lt(T, g) {
    let l = (0,react.useId)(), { id: a = "headlessui-menu-item-".concat(l), disabled: p = !1, ...s } = T, n = menu_machine_glue_p("Menu.Item"), b = (0,react_glue/* useSlice */.M)(n, (i)=>n.selectors.isActive(i, a)), P = (0,react.useRef)(null), I = (0,use_sync_refs/* useSyncRefs */.T)(g, P), t = (0,react_glue/* useSlice */.M)(n, (i)=>n.selectors.shouldScrollIntoView(i, a));
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        if (t) return (0,disposables/* disposables */.k)().requestAnimationFrame(()=>{
            var i, G;
            (G = (i = P.current) == null ? void 0 : i.scrollIntoView) == null || G.call(i, {
                block: "nearest"
            });
        });
    }, [
        t,
        P
    ]);
    let h = (0,use_text_value/* useTextValue */.x)(P), R = (0,react.useRef)({
        disabled: p,
        domRef: P,
        get textValue () {
            return h();
        }
    });
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        R.current.disabled = p;
    }, [
        R,
        p
    ]), (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>(n.actions.registerItem(a, R), ()=>n.actions.unregisterItem(a)), [
        R,
        a
    ]);
    let A = (0,use_event/* useEvent */.z)(()=>{
        n.send({
            type: C.CloseMenu
        });
    }), u = (0,use_event/* useEvent */.z)((i)=>{
        if (p) return i.preventDefault();
        n.send({
            type: C.CloseMenu
        }), (0,focus_management/* restoreFocusIfNecessary */.wI)(n.state.buttonElement);
    }), M = (0,use_event/* useEvent */.z)(()=>{
        if (p) return n.send({
            type: C.GoToItem,
            focus: calculate_active_index/* Focus */.T.Nothing
        });
        n.send({
            type: C.GoToItem,
            focus: calculate_active_index/* Focus */.T.Specific,
            id: a
        });
    }), f = (0,use_tracked_pointer/* useTrackedPointer */.g)(), m = (0,use_event/* useEvent */.z)((i)=>f.update(i)), E = (0,use_event/* useEvent */.z)((i)=>{
        f.wasMoved(i) && (p || b || n.send({
            type: C.GoToItem,
            focus: calculate_active_index/* Focus */.T.Specific,
            id: a,
            trigger: menu_machine_D.Pointer
        }));
    }), H = (0,use_event/* useEvent */.z)((i)=>{
        f.wasMoved(i) && (p || b && n.state.activationTrigger === menu_machine_D.Pointer && n.send({
            type: C.GoToItem,
            focus: calculate_active_index/* Focus */.T.Nothing
        }));
    }), [D, O] = (0,label/* useLabels */.bE)(), [F, k] = (0,description/* useDescriptions */.fw)(), U = (0,use_slot/* useSlot */.x)({
        active: b,
        focus: b,
        disabled: p,
        close: A
    }), N = {
        id: a,
        ref: I,
        role: "menuitem",
        tabIndex: p === !0 ? void 0 : -1,
        "aria-disabled": p === !0 ? !0 : void 0,
        "aria-labelledby": D,
        "aria-describedby": F,
        disabled: void 0,
        onClick: u,
        onFocus: M,
        onPointerEnter: m,
        onMouseEnter: m,
        onPointerMove: E,
        onMouseMove: E,
        onPointerLeave: H,
        onMouseLeave: H
    }, B = (0,render/* useRender */.L6)();
    return /*#__PURE__*/ react.createElement(O, null, /*#__PURE__*/ react.createElement(k, null, B({
        ourProps: N,
        theirProps: s,
        slot: U,
        defaultTag: st,
        name: "Menu.Item"
    })));
}
let pt = "div";
function it(T, g) {
    let [l, a] = (0,label/* useLabels */.bE)(), p = T, s = {
        ref: g,
        "aria-labelledby": l,
        role: "group"
    }, n = (0,render/* useRender */.L6)();
    return /*#__PURE__*/ react.createElement(a, null, n({
        ourProps: s,
        theirProps: p,
        slot: {},
        defaultTag: pt,
        name: "Menu.Section"
    }));
}
let ut = "header";
function mt(T, g) {
    let l = (0,react.useId)(), { id: a = "headlessui-menu-heading-".concat(l), ...p } = T, s = (0,label/* useLabelContext */.t0)();
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>s.register(a), [
        a,
        s.register
    ]);
    let n = {
        id: a,
        ref: g,
        role: "presentation",
        ...s.props
    };
    return (0,render/* useRender */.L6)()({
        ourProps: n,
        theirProps: p,
        slot: {},
        defaultTag: ut,
        name: "Menu.Heading"
    });
}
let dt = "div";
function ct(T, g) {
    let l = T, a = {
        ref: g,
        role: "separator"
    };
    return (0,render/* useRender */.L6)()({
        ourProps: a,
        theirProps: l,
        slot: {},
        defaultTag: dt,
        name: "Menu.Separator"
    });
}
let Tt = (0,render/* forwardRefWithAs */.yV)(et), ft = (0,render/* forwardRefWithAs */.yV)(ot), yt = (0,render/* forwardRefWithAs */.yV)(at), Pt = (0,render/* forwardRefWithAs */.yV)(lt), Et = (0,render/* forwardRefWithAs */.yV)(it), gt = (0,render/* forwardRefWithAs */.yV)(mt), Mt = (0,render/* forwardRefWithAs */.yV)(ct), lo = Object.assign(Tt, {
    Button: ft,
    Items: yt,
    Item: Pt,
    Section: Et,
    Heading: gt,
    Separator: Mt
});


// EXTERNAL MODULE: ../../node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/mdx-components/anchor.js + 1 modules
var mdx_components_anchor = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/mdx-components/anchor.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/components/button.js + 1 modules
var components_button = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/components/button.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/hooks/use-fs-route.js
var use_fs_route = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-fs-route.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/icons/arrow-right.js
var arrow_right = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/icons/arrow-right.js");
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/icons/menu.js


const SvgMenu = (props) => {
  const $ = (0,dist.c)(5);
  let t0;
  let t1;
  let t2;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,jsx_runtime.jsx)("g", { children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M4 6h16" }) });
    t1 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M4 12h16" });
    t2 = /* @__PURE__ */ (0,jsx_runtime.jsx)("g", { children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M4 18h16" }) });
    $[0] = t0;
    $[1] = t1;
    $[2] = t2;
  } else {
    t0 = $[0];
    t1 = $[1];
    t2 = $[2];
  }
  let t3;
  if ($[3] !== props) {
    t3 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", ...props, children: [
      t0,
      t1,
      t2
    ] });
    $[3] = props;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  return t3;
};


// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/config.js + 1 modules
var config = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/config.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/theme-config.js
var theme_config = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/theme-config.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/menu.js
var stores_menu = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/menu.js");
;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/components/navbar/index.client.js
/* __next_internal_client_entry_do_not_use__ ClientNavbar auto */ 







const classes = {
    link: (0,clsx/* default */.Z)("x:text-sm x:contrast-more:text-gray-700 x:contrast-more:dark:text-gray-100 x:whitespace-nowrap", "x:text-gray-600 x:hover:text-black x:dark:text-gray-400 x:dark:hover:text-gray-200", "x:ring-inset x:transition-colors")
};
const NavbarMenu = (t0)=>{
    const $ = (0,dist.c)(19);
    const { menu, children } = t0;
    let t1;
    if ($[0] !== menu.children) {
        t1 = Object.fromEntries((menu.children || []).map(_temp));
        $[0] = menu.children;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    const routes = t1;
    let t2;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t2 = /* @__PURE__ */ (0,jsx_runtime.jsx)(arrow_right/* ReactComponent */.r, {
            height: "14",
            className: "x:*:origin-center x:*:transition-transform x:*:rotate-90"
        });
        $[2] = t2;
    } else {
        t2 = $[2];
    }
    let t3;
    if ($[3] !== children) {
        t3 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(ft, {
            className: _temp2,
            children: [
                children,
                t2
            ]
        });
        $[3] = children;
        $[4] = t3;
    } else {
        t3 = $[4];
    }
    let t4;
    let t5;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
        t4 = (0,clsx/* default */.Z)("x:focus-visible:nextra-focus", "nextra-scrollbar x:motion-reduce:transition-none", "x:origin-top x:transition x:duration-200 x:ease-out x:data-closed:scale-95 x:data-closed:opacity-0", "x:border x:border-black/5 x:dark:border-white/20", "x:z-30 x:rounded-md x:py-1 x:text-sm x:shadow-lg", "x:backdrop-blur-md x:bg-nextra-bg/70", "x:max-h-[min(calc(100vh-5rem),256px)]!");
        t5 = {
            to: "bottom",
            gap: 10,
            padding: 16
        };
        $[5] = t4;
        $[6] = t5;
    } else {
        t4 = $[5];
        t5 = $[6];
    }
    let t6;
    if ($[7] !== menu.items || $[8] !== routes) {
        let t72;
        if ($[10] !== menu.items) {
            t72 = menu.items || {};
            $[10] = menu.items;
            $[11] = t72;
        } else {
            t72 = $[11];
        }
        let t82;
        if ($[12] !== routes) {
            t82 = (t9)=>{
                var _routes_key;
                const [key, item] = t9;
                return /* @__PURE__ */ (0,jsx_runtime.jsx)(Pt, {
                    as: mdx_components_anchor/* Anchor */.e,
                    href: item.href || ((_routes_key = routes[key]) === null || _routes_key === void 0 ? void 0 : _routes_key.route),
                    className: _temp3,
                    children: item.title
                }, key);
            };
            $[12] = routes;
            $[13] = t82;
        } else {
            t82 = $[13];
        }
        t6 = Object.entries(t72).map(t82);
        $[7] = menu.items;
        $[8] = routes;
        $[9] = t6;
    } else {
        t6 = $[9];
    }
    let t7;
    if ($[14] !== t6) {
        t7 = /* @__PURE__ */ (0,jsx_runtime.jsx)(yt, {
            transition: true,
            className: t4,
            anchor: t5,
            children: t6
        });
        $[14] = t6;
        $[15] = t7;
    } else {
        t7 = $[15];
    }
    let t8;
    if ($[16] !== t3 || $[17] !== t7) {
        t8 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(lo, {
            children: [
                t3,
                t7
            ]
        });
        $[16] = t3;
        $[17] = t7;
        $[18] = t8;
    } else {
        t8 = $[18];
    }
    return t8;
};
const isMenu = (page)=>page.type === "menu";
const ClientNavbar = (t0)=>{
    const $ = (0,dist.c)(21);
    const { children, className } = t0;
    const items = (0,config.useConfig)().normalizePagesResult.topLevelNavbarItems;
    const themeConfig = (0,theme_config.useThemeConfig)();
    const pathname = (0,use_fs_route.useFSRoute)();
    const menu = (0,stores_menu/* useMenu */.H)();
    let t1;
    if ($[0] !== className) {
        t1 = (0,clsx/* default */.Z)("x:flex x:gap-4 x:overflow-x-auto nextra-scrollbar x:py-1.5 x:max-md:hidden", className);
        $[0] = className;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    let t2;
    if ($[2] !== items || $[3] !== pathname) {
        let t32;
        if ($[5] !== pathname) {
            t32 = (page, _index, arr)=>{
                if ("display" in page && page.display === "hidden") {
                    return;
                }
                if (isMenu(page)) {
                    return /* @__PURE__ */ (0,jsx_runtime.jsx)(NavbarMenu, {
                        menu: page,
                        children: page.title
                    }, page.name);
                }
                const href = ("frontMatter" in page ? page.route : page.firstChildRoute) || page.href || page.route;
                const isCurrentPage = href === pathname || pathname.startsWith(page.route + "/") && arr.every((item)=>!("href" in item) || item.href !== pathname) || void 0;
                return /* @__PURE__ */ (0,jsx_runtime.jsx)(mdx_components_anchor/* Anchor */.e, {
                    href,
                    className: (0,clsx/* default */.Z)(classes.link, "x:aria-[current]:font-medium x:aria-[current]:subpixel-antialiased x:aria-[current]:text-current"),
                    "aria-current": isCurrentPage,
                    children: page.title
                }, page.name);
            };
            $[5] = pathname;
            $[6] = t32;
        } else {
            t32 = $[6];
        }
        t2 = items.map(t32);
        $[2] = items;
        $[3] = pathname;
        $[4] = t2;
    } else {
        t2 = $[4];
    }
    let t3;
    if ($[7] !== t1 || $[8] !== t2) {
        t3 = /* @__PURE__ */ (0,jsx_runtime.jsx)("div", {
            className: t1,
            children: t2
        });
        $[7] = t1;
        $[8] = t2;
        $[9] = t3;
    } else {
        t3 = $[9];
    }
    let t4;
    if ($[10] !== themeConfig.search) {
        t4 = themeConfig.search && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", {
            className: "x:max-md:hidden",
            children: themeConfig.search
        });
        $[10] = themeConfig.search;
        $[11] = t4;
    } else {
        t4 = $[11];
    }
    let t5;
    if ($[12] !== menu) {
        t5 = (0,clsx/* default */.Z)({
            open: menu
        });
        $[12] = menu;
        $[13] = t5;
    } else {
        t5 = $[13];
    }
    let t6;
    if ($[14] !== t5) {
        t6 = /* @__PURE__ */ (0,jsx_runtime.jsx)(components_button.Button, {
            "aria-label": "Menu",
            className: _temp4,
            onClick: _temp6,
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(SvgMenu, {
                height: "24",
                className: t5
            })
        });
        $[14] = t5;
        $[15] = t6;
    } else {
        t6 = $[15];
    }
    let t7;
    if ($[16] !== children || $[17] !== t3 || $[18] !== t4 || $[19] !== t6) {
        t7 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                t3,
                t4,
                children,
                t6
            ]
        });
        $[16] = children;
        $[17] = t3;
        $[18] = t4;
        $[19] = t6;
        $[20] = t7;
    } else {
        t7 = $[20];
    }
    return t7;
};
function _temp(route) {
    return [
        route.name,
        route
    ];
}
function _temp2(t0) {
    const { focus } = t0;
    return (0,clsx/* default */.Z)(classes.link, "x:items-center x:flex x:gap-1.5 x:cursor-pointer", focus && "x:nextra-focus");
}
function _temp3(t0) {
    const { focus: focus_0 } = t0;
    return (0,clsx/* default */.Z)("x:block x:py-1.5 x:transition-colors x:ps-3 x:pe-9", focus_0 ? "x:text-gray-900 x:dark:text-gray-100" : "x:text-gray-600 x:dark:text-gray-400");
}
function _temp4(t0) {
    const { active } = t0;
    return (0,clsx/* default */.Z)("nextra-hamburger x:md:hidden", active && "x:bg-gray-400/20");
}
function _temp5(prev) {
    return !prev;
}
function _temp6() {
    return (0,stores_menu/* setMenu */.K)(_temp5);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/components/sidebar.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  MobileNav: function() { return /* binding */ MobileNav; },
  Sidebar: function() { return /* binding */ Sidebar; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ./node_modules/next/dist/api/navigation.js
var navigation = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/api/navigation.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/mdx-components/anchor.js + 1 modules
var mdx_components_anchor = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/mdx-components/anchor.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/components/button.js + 1 modules
var components_button = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/components/button.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/components/collapse.js
var collapse = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/components/collapse.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/hooks/use-fs-route.js
var use_fs_route = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-fs-route.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/hooks/use-hash.js
var use_hash = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-hash.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/icons/arrow-right.js
var arrow_right = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/icons/arrow-right.js");
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/icons/expand.js


const SvgExpand = (props) => {
  const $ = (0,dist.c)(4);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M4.177 7.823l2.396-2.396A.25.25 0 017 5.604v4.792a.25.25 0 01-.427.177L4.177 8.177a.25.25 0 010-.354z" });
    t1 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", d: "M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v12.5A1.75 1.75 0 0114.25 16H1.75A1.75 1.75 0 010 14.25V1.75zm1.75-.25a.25.25 0 00-.25.25v12.5c0 .138.112.25.25.25H9.5v-13H1.75zm12.5 13H11v-13h3.25a.25.25 0 01.25.25v12.5a.25.25 0 01-.25.25z" });
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  let t2;
  if ($[2] !== props) {
    t2 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { viewBox: "0 0 16 16", fill: "currentColor", ...props, children: [
      t0,
      t1
    ] });
    $[2] = props;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
};


// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
// EXTERNAL MODULE: ../../node_modules/scroll-into-view-if-needed/dist/index.js + 1 modules
var scroll_into_view_if_needed_dist = __webpack_require__("(app-pages-browser)/../../node_modules/scroll-into-view-if-needed/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/zustand/esm/react.mjs + 1 modules
var esm_react = __webpack_require__("(app-pages-browser)/../../node_modules/zustand/esm/react.mjs");
;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/stores/focused-route.js
"use no memo";

const useFocusedRouteStore = (0,esm_react/* create */.U)(()=>({
        focused: ""
    }));
const useFocusedRoute = ()=>useFocusedRouteStore((state)=>state.focused);
const setFocusedRoute = (focused)=>{
    useFocusedRouteStore.setState({
        focused
    });
};


// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/theme-config.js
var theme_config = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/theme-config.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/menu.js
var stores_menu = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/menu.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/active-anchor.js
var active_anchor = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/active-anchor.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/config.js + 1 modules
var config = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/config.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/toc.js
var stores_toc = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/toc.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/components/locale-switch.js + 1 modules
var locale_switch = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/components/locale-switch.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/components/theme-switch.js + 2 modules
var theme_switch = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/components/theme-switch.js");
;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/components/sidebar.js
/* __next_internal_client_entry_do_not_use__ MobileNav,Sidebar auto */ 











const TreeState = /* @__PURE__ */ Object.create(null);
const classes = {
    link: (0,clsx/* default */.Z)("x:flex x:rounded x:px-2 x:py-1.5 x:text-sm x:transition-colors x:[word-break:break-word]", "x:cursor-pointer x:contrast-more:border"),
    inactive: (0,clsx/* default */.Z)("x:text-gray-600 x:hover:bg-gray-100 x:hover:text-gray-900", "x:dark:text-neutral-400 x:dark:hover:bg-primary-100/5 x:dark:hover:text-gray-50", "x:contrast-more:text-gray-900 x:contrast-more:dark:text-gray-50", "x:contrast-more:border-transparent x:contrast-more:hover:border-gray-900 x:contrast-more:dark:hover:border-gray-50"),
    active: (0,clsx/* default */.Z)("x:bg-primary-100 x:font-semibold x:text-primary-800 x:dark:bg-primary-400/10 x:dark:text-primary-600", "x:contrast-more:border-primary-500!"),
    list: (0,clsx/* default */.Z)("x:grid x:gap-1"),
    border: (0,clsx/* default */.Z)("x:relative x:before:absolute x:before:inset-y-1", 'x:before:w-px x:before:bg-gray-200 x:before:content-[""] x:dark:before:bg-neutral-800', "x:ps-3 x:before:start-0 x:pt-1 x:ms-3"),
    wrapper: (0,clsx/* default */.Z)("x:p-4 x:overflow-y-auto nextra-scrollbar nextra-mask"),
    footer: (0,clsx/* default */.Z)("nextra-sidebar-footer x:border-t nextra-border x:flex x:items-center x:gap-2 x:py-4 x:mx-4")
};
const Folder = (t0)=>{
    const $ = (0,dist.c)(10);
    const { item: _item, anchors, onFocus, level } = t0;
    const routeOriginal = (0,use_fs_route.useFSRoute)();
    let t1;
    if ($[0] !== routeOriginal) {
        t1 = routeOriginal.split("#", 1);
        $[0] = routeOriginal;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    const route = t1[0];
    let t2;
    if ($[2] !== _item) {
        t2 = _item.type === "menu" ? getMenuChildren(_item) : _item.children;
        $[2] = _item;
        $[3] = t2;
    } else {
        t2 = $[3];
    }
    const item = {
        ..._item,
        children: t2
    };
    const hasRoute = !!item.route;
    const active = hasRoute && [
        route,
        route + "/"
    ].includes(item.route + "/");
    const activeRouteInside = active || hasRoute && route.startsWith(item.route + "/");
    const focusedRoute = useFocusedRoute();
    const focusedRouteInside = focusedRoute.startsWith(item.route + "/");
    const { theme } = item;
    const { defaultMenuCollapseLevel, autoCollapse } = (0,theme_config.useThemeConfig)().sidebar;
    const open = TreeState[item.route] === void 0 ? active || activeRouteInside || focusedRouteInside || (theme && "collapsed" in theme ? !theme.collapsed : level < defaultMenuCollapseLevel) : TreeState[item.route] || focusedRouteInside;
    const [, rerender] = (0,react.useState)();
    const handleClick2 = (event)=>{
        const el = event.currentTarget;
        const isClickOnIcon = el !== event.target;
        if (isClickOnIcon) {
            event.preventDefault();
        }
        const isOpen = el.parentElement.classList.contains("open");
        TreeState[item.route] = isLink && !isClickOnIcon && !active || !isOpen;
        rerender({});
    };
    (0,react.useEffect)(()=>{
        const updateTreeState = function updateTreeState2() {
            if (activeRouteInside || focusedRouteInside) {
                TreeState[item.route] = true;
            }
        };
        const updateAndPruneTreeState = function updateAndPruneTreeState2() {
            if (activeRouteInside && focusedRouteInside) {
                TreeState[item.route] = true;
            } else {
                delete TreeState[item.route];
            }
        };
        if (autoCollapse) {
            updateAndPruneTreeState();
        } else {
            updateTreeState();
        }
    }, [
        activeRouteInside,
        focusedRouteInside,
        item.route,
        autoCollapse
    ]);
    const isLink = "frontMatter" in item;
    const ComponentToUse = isLink ? mdx_components_anchor/* Anchor */.e : components_button.Button;
    const t3 = (0,clsx/* default */.Z)({
        open,
        active
    });
    const t4 = !isLink && "x:text-start x:w-full";
    const t5 = active ? classes.active : classes.inactive;
    let t6;
    if ($[4] !== t4 || $[5] !== t5) {
        t6 = (0,clsx/* default */.Z)("x:items-center x:justify-between x:gap-2", t4, classes.link, t5);
        $[4] = t4;
        $[5] = t5;
        $[6] = t6;
    } else {
        t6 = $[6];
    }
    const t7 = item.title;
    const T0 = arrow_right/* ReactComponent */.r;
    const t8 = "18";
    const t9 = (0,clsx/* default */.Z)("x:shrink-0", "x:rounded-sm x:p-0.5 x:hover:bg-gray-800/5 x:dark:hover:bg-gray-100/5", "x:motion-reduce:transition-none x:origin-center x:transition-all x:rtl:-rotate-180", open && "x:ltr:rotate-90 x:rtl:-rotate-270");
    let t10;
    if ($[7] !== T0 || $[8] !== t9) {
        t10 = /* @__PURE__ */ (0,jsx_runtime.jsx)(T0, {
            height: t8,
            className: t9
        });
        $[7] = T0;
        $[8] = t9;
        $[9] = t10;
    } else {
        t10 = $[9];
    }
    return /* @__PURE__ */ (0,jsx_runtime.jsxs)("li", {
        className: t3,
        children: [
            /* @__PURE__ */ (0,jsx_runtime.jsxs)(ComponentToUse, {
                ...isLink ? {
                    href: item.route,
                    prefetch: false
                } : {
                    "data-href": item.route
                },
                className: t6,
                onClick: handleClick2,
                onFocus,
                children: [
                    t7,
                    t10
                ]
            }),
            item.children && /* @__PURE__ */ (0,jsx_runtime.jsx)(collapse/* Collapse */.U, {
                isOpen: open,
                children: /* @__PURE__ */ (0,jsx_runtime.jsx)(Menu, {
                    className: classes.border,
                    directories: item.children,
                    anchors,
                    level
                })
            })
        ]
    });
};
function getMenuChildren(menu) {
    const routes = Object.fromEntries((menu.children || []).map((route)=>[
            route.name,
            route
        ]));
    return Object.entries(menu.items || {}).map((param)=>{
        let [key, item] = param;
        return {
            ...routes[key] || {
                name: key
            },
            ...item
        };
    });
}
const Separator = (t0)=>{
    const $ = (0,dist.c)(7);
    const { title } = t0;
    const t1 = title ? "x:not-first:mt-5 x:mb-2 x:px-2 x:py-1.5 x:text-sm x:font-semibold x:text-gray-900 x:dark:text-gray-100" : "x:my-4";
    let t2;
    if ($[0] !== t1) {
        t2 = (0,clsx/* default */.Z)("[word-break:break-word]", t1);
        $[0] = t1;
        $[1] = t2;
    } else {
        t2 = $[1];
    }
    let t3;
    if ($[2] !== title) {
        t3 = title || /* @__PURE__ */ (0,jsx_runtime.jsx)("hr", {
            className: "x:mx-2 x:border-t nextra-border"
        });
        $[2] = title;
        $[3] = t3;
    } else {
        t3 = $[3];
    }
    let t4;
    if ($[4] !== t2 || $[5] !== t3) {
        t4 = /* @__PURE__ */ (0,jsx_runtime.jsx)("li", {
            className: t2,
            children: t3
        });
        $[4] = t2;
        $[5] = t3;
        $[6] = t4;
    } else {
        t4 = $[6];
    }
    return t4;
};
const handleClick = ()=>{
    (0,stores_menu/* setMenu */.K)(false);
};
const File = (t0)=>{
    const $ = (0,dist.c)(22);
    const { item, anchors, onFocus } = t0;
    const route = (0,use_fs_route.useFSRoute)();
    let t1;
    if ($[0] !== item.route || $[1] !== route) {
        t1 = item.route && [
            route,
            route + "/"
        ].includes(item.route + "/");
        $[0] = item.route;
        $[1] = route;
        $[2] = t1;
    } else {
        t1 = $[2];
    }
    const active = t1;
    const activeSlug = (0,active_anchor/* useActiveAnchor */.t)();
    if (item.type === "separator") {
        let t22;
        if ($[3] !== item.title) {
            t22 = /* @__PURE__ */ (0,jsx_runtime.jsx)(Separator, {
                title: item.title
            });
            $[3] = item.title;
            $[4] = t22;
        } else {
            t22 = $[4];
        }
        return t22;
    }
    const href = item.href || item.route;
    let t2;
    if ($[5] !== active) {
        t2 = (0,clsx/* default */.Z)({
            active
        });
        $[5] = active;
        $[6] = t2;
    } else {
        t2 = $[6];
    }
    const t3 = active ? classes.active : classes.inactive;
    let t4;
    if ($[7] !== t3) {
        t4 = (0,clsx/* default */.Z)(classes.link, t3);
        $[7] = t3;
        $[8] = t4;
    } else {
        t4 = $[8];
    }
    let t5;
    if ($[9] !== href || $[10] !== item.title || $[11] !== onFocus || $[12] !== t4) {
        t5 = /* @__PURE__ */ (0,jsx_runtime.jsx)(mdx_components_anchor/* Anchor */.e, {
            href,
            className: t4,
            onFocus,
            prefetch: false,
            children: item.title
        });
        $[9] = href;
        $[10] = item.title;
        $[11] = onFocus;
        $[12] = t4;
        $[13] = t5;
    } else {
        t5 = $[13];
    }
    let t6;
    if ($[14] !== active || $[15] !== activeSlug || $[16] !== anchors) {
        t6 = active && anchors.length > 0 && /* @__PURE__ */ (0,jsx_runtime.jsx)("ul", {
            className: (0,clsx/* default */.Z)(classes.list, classes.border),
            children: anchors.map((t72)=>{
                const { id, value } = t72;
                return /* @__PURE__ */ (0,jsx_runtime.jsx)("li", {
                    children: /* @__PURE__ */ (0,jsx_runtime.jsx)("a", {
                        href: "#".concat(id),
                        className: (0,clsx/* default */.Z)(classes.link, 'x:focus-visible:nextra-focus x:flex x:gap-2 x:before:opacity-25 x:before:content-["#"]', id === activeSlug ? classes.active : classes.inactive),
                        onClick: handleClick,
                        children: value
                    })
                }, id);
            })
        });
        $[14] = active;
        $[15] = activeSlug;
        $[16] = anchors;
        $[17] = t6;
    } else {
        t6 = $[17];
    }
    let t7;
    if ($[18] !== t2 || $[19] !== t5 || $[20] !== t6) {
        t7 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("li", {
            className: t2,
            children: [
                t5,
                t6
            ]
        });
        $[18] = t2;
        $[19] = t5;
        $[20] = t6;
        $[21] = t7;
    } else {
        t7 = $[21];
    }
    return t7;
};
const handleFocus = (event)=>{
    const route = event.target.getAttribute("href") || event.target.dataset.href || "";
    setFocusedRoute(route);
};
const Menu = /*#__PURE__*/ (0,react.forwardRef)((t0, forwardedRef)=>{
    const $ = (0,dist.c)(13);
    const { directories, anchors, className, level } = t0;
    let t1;
    if ($[0] !== className) {
        t1 = (0,clsx/* default */.Z)(classes.list, className);
        $[0] = className;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    let t2;
    if ($[2] !== anchors || $[3] !== directories || $[4] !== level) {
        let t32;
        if ($[6] !== anchors || $[7] !== level) {
            t32 = (item)=>{
                var _item_children;
                const ComponentToUse = item.type === "menu" || ((_item_children = item.children) === null || _item_children === void 0 ? void 0 : _item_children.length) ? Folder : File;
                return /* @__PURE__ */ (0,jsx_runtime.jsx)(ComponentToUse, {
                    item,
                    anchors,
                    onFocus: handleFocus,
                    level: level + 1
                }, item.name);
            };
            $[6] = anchors;
            $[7] = level;
            $[8] = t32;
        } else {
            t32 = $[8];
        }
        t2 = directories.map(t32);
        $[2] = anchors;
        $[3] = directories;
        $[4] = level;
        $[5] = t2;
    } else {
        t2 = $[5];
    }
    let t3;
    if ($[9] !== forwardedRef || $[10] !== t1 || $[11] !== t2) {
        t3 = /* @__PURE__ */ (0,jsx_runtime.jsx)("ul", {
            className: t1,
            ref: forwardedRef,
            children: t2
        });
        $[9] = forwardedRef;
        $[10] = t1;
        $[11] = t2;
        $[12] = t3;
    } else {
        t3 = $[12];
    }
    return t3;
});
Menu.displayName = "Menu";
const MobileNav = ()=>{
    const $ = (0,dist.c)(22);
    const { directories } = (0,config.useConfig)().normalizePagesResult;
    const toc = (0,stores_toc.useTOC)();
    const menu = (0,stores_menu/* useMenu */.H)();
    const pathname = (0,navigation.usePathname)();
    const hash = (0,use_hash.useHash)();
    let t0;
    if ($[0] !== hash || $[1] !== pathname) {
        t0 = [
            pathname,
            hash
        ];
        $[0] = hash;
        $[1] = pathname;
        $[2] = t0;
    } else {
        t0 = $[2];
    }
    (0,react.useEffect)(_temp, t0);
    let t1;
    if ($[3] !== toc) {
        t1 = toc.filter(_temp2);
        $[3] = toc;
        $[4] = t1;
    } else {
        t1 = $[4];
    }
    const anchors = t1;
    const sidebarRef = (0,react.useRef)(null);
    let t2;
    let t3;
    if ($[5] !== menu) {
        t2 = ()=>{
            const sidebar = sidebarRef.current;
            const activeLink = sidebar.querySelector("li.active");
            if (activeLink && menu) {
                (0,scroll_into_view_if_needed_dist/* default */.Z)(activeLink, {
                    block: "center",
                    inline: "center",
                    scrollMode: "always",
                    boundary: sidebar.parentNode
                });
            }
        };
        t3 = [
            menu
        ];
        $[5] = menu;
        $[6] = t2;
        $[7] = t3;
    } else {
        t2 = $[6];
        t3 = $[7];
    }
    (0,react.useEffect)(t2, t3);
    const themeConfig = (0,theme_config.useThemeConfig)();
    const hasI18n = themeConfig.i18n.length > 0;
    const hasMenu = themeConfig.darkMode || hasI18n;
    const t4 = menu ? "x:[transform:translate3d(0,0,0)]" : "x:[transform:translate3d(0,-100%,0)]";
    let t5;
    if ($[8] !== t4) {
        t5 = (0,clsx/* default */.Z)("nextra-mobile-nav", "x:flex x:flex-col", "x:fixed x:inset-0 x:pt-(--nextra-navbar-height) x:z-20 x:overscroll-contain", "x:[contain:layout_style]", "x:md:hidden", "x:[.nextra-banner:not([class$=hidden])~&]:pt-[calc(var(--nextra-banner-height)+var(--nextra-navbar-height))]", "x:bg-nextra-bg", t4);
        $[8] = t4;
        $[9] = t5;
    } else {
        t5 = $[9];
    }
    let t6;
    if ($[10] !== themeConfig.search) {
        t6 = themeConfig.search && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", {
            className: "x:px-4 x:pt-4",
            children: themeConfig.search
        });
        $[10] = themeConfig.search;
        $[11] = t6;
    } else {
        t6 = $[11];
    }
    let t7;
    if ($[12] !== anchors || $[13] !== directories) {
        t7 = /* @__PURE__ */ (0,jsx_runtime.jsx)(Menu, {
            ref: sidebarRef,
            className: classes.wrapper,
            directories,
            anchors,
            level: 0
        });
        $[12] = anchors;
        $[13] = directories;
        $[14] = t7;
    } else {
        t7 = $[14];
    }
    let t8;
    if ($[15] !== hasMenu) {
        t8 = hasMenu && /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", {
            className: (0,clsx/* default */.Z)(classes.footer, "x:mt-auto"),
            children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(theme_switch.ThemeSwitch, {
                    className: "x:grow"
                }),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(locale_switch.LocaleSwitch, {
                    className: "x:grow x:justify-end"
                })
            ]
        });
        $[15] = hasMenu;
        $[16] = t8;
    } else {
        t8 = $[16];
    }
    let t9;
    if ($[17] !== t5 || $[18] !== t6 || $[19] !== t7 || $[20] !== t8) {
        t9 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("aside", {
            className: t5,
            children: [
                t6,
                t7,
                t8
            ]
        });
        $[17] = t5;
        $[18] = t6;
        $[19] = t7;
        $[20] = t8;
        $[21] = t9;
    } else {
        t9 = $[21];
    }
    return t9;
};
let lastScrollPosition = 0;
const handleScrollEnd = (event)=>{
    lastScrollPosition = event.currentTarget.scrollTop;
};
const Sidebar = ()=>{
    const $ = (0,dist.c)(36);
    const toc = (0,stores_toc.useTOC)();
    const { normalizePagesResult, hideSidebar } = (0,config.useConfig)();
    const themeConfig = (0,theme_config.useThemeConfig)();
    const [isExpanded, setIsExpanded] = (0,react.useState)(themeConfig.sidebar.defaultOpen);
    const [showToggleAnimation, setToggleAnimation] = (0,react.useState)(false);
    const sidebarRef = (0,react.useRef)(null);
    const sidebarControlsId = (0,react.useId)();
    const { docsDirectories, activeThemeContext } = normalizePagesResult;
    const includePlaceholder = activeThemeContext.layout === "default";
    let t0;
    let t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = ()=>{
            if (window.innerWidth < 768) {
                return;
            }
            const sidebar = sidebarRef.current;
            if (lastScrollPosition) {
                sidebar.scrollTop = lastScrollPosition;
                return;
            }
            const activeLink = sidebar.querySelector("li.active");
            if (activeLink) {
                (0,scroll_into_view_if_needed_dist/* default */.Z)(activeLink, {
                    block: "center",
                    inline: "center",
                    scrollMode: "always",
                    boundary: sidebar.parentNode
                });
            }
        };
        t1 = [];
        $[0] = t0;
        $[1] = t1;
    } else {
        t0 = $[0];
        t1 = $[1];
    }
    (0,react.useEffect)(t0, t1);
    let t2;
    if ($[2] !== themeConfig.toc.float || $[3] !== toc) {
        t2 = themeConfig.toc.float ? [] : toc.filter(_temp3);
        $[2] = themeConfig.toc.float;
        $[3] = toc;
        $[4] = t2;
    } else {
        t2 = $[4];
    }
    const anchors = t2;
    const hasI18n = themeConfig.i18n.length > 0;
    const hasMenu = themeConfig.darkMode || hasI18n || themeConfig.sidebar.toggleButton;
    let t3;
    if ($[5] !== hideSidebar || $[6] !== includePlaceholder) {
        t3 = includePlaceholder && hideSidebar && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", {
            className: "x:max-xl:hidden x:h-0 x:w-64 x:shrink-0"
        });
        $[5] = hideSidebar;
        $[6] = includePlaceholder;
        $[7] = t3;
    } else {
        t3 = $[7];
    }
    const t4 = isExpanded ? "x:w-64" : "x:w-20";
    const t5 = hideSidebar ? "x:hidden" : "x:sticky";
    let t6;
    if ($[8] !== t4 || $[9] !== t5) {
        t6 = (0,clsx/* default */.Z)("nextra-sidebar x:print:hidden", "x:transition-all x:ease-in-out", "x:max-md:hidden x:flex x:flex-col", "x:h-[calc(100dvh-var(--nextra-navbar-height))]", "x:top-(--nextra-navbar-height) x:shrink-0", t4, t5);
        $[8] = t4;
        $[9] = t5;
        $[10] = t6;
    } else {
        t6 = $[10];
    }
    const t7 = !isExpanded && "no-scrollbar";
    let t8;
    if ($[11] !== t7) {
        t8 = (0,clsx/* default */.Z)(classes.wrapper, "x:grow", t7);
        $[11] = t7;
        $[12] = t8;
    } else {
        t8 = $[12];
    }
    let t9;
    if ($[13] !== anchors || $[14] !== docsDirectories || $[15] !== hideSidebar || $[16] !== isExpanded) {
        t9 = (!hideSidebar || !isExpanded) && /* @__PURE__ */ (0,jsx_runtime.jsx)(collapse/* Collapse */.U, {
            isOpen: isExpanded,
            horizontal: true,
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(Menu, {
                directories: docsDirectories,
                anchors,
                level: 0
            })
        });
        $[13] = anchors;
        $[14] = docsDirectories;
        $[15] = hideSidebar;
        $[16] = isExpanded;
        $[17] = t9;
    } else {
        t9 = $[17];
    }
    let t10;
    if ($[18] !== t8 || $[19] !== t9) {
        t10 = /* @__PURE__ */ (0,jsx_runtime.jsx)("div", {
            className: t8,
            ref: sidebarRef,
            onScrollEnd: handleScrollEnd,
            children: t9
        });
        $[18] = t8;
        $[19] = t9;
        $[20] = t10;
    } else {
        t10 = $[20];
    }
    let t11;
    if ($[21] !== hasI18n || $[22] !== hasMenu || $[23] !== isExpanded || $[24] !== showToggleAnimation || $[25] !== sidebarControlsId || $[26] !== themeConfig.sidebar.toggleButton) {
        t11 = hasMenu && /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", {
            className: (0,clsx/* default */.Z)("x:sticky x:bottom-0 x:bg-nextra-bg", classes.footer, !isExpanded && "x:flex-wrap x:justify-center", showToggleAnimation && [
                "x:*:opacity-0",
                isExpanded ? "x:*:animate-[fade-in_1s_ease_.2s_forwards]" : "x:*:animate-[fade-in2_1s_ease_.2s_forwards]"
            ]),
            children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(locale_switch.LocaleSwitch, {
                    lite: !isExpanded,
                    className: isExpanded ? "x:grow" : ""
                }),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(theme_switch.ThemeSwitch, {
                    lite: !isExpanded || hasI18n,
                    className: !isExpanded || hasI18n ? "" : "x:grow"
                }),
                themeConfig.sidebar.toggleButton && /* @__PURE__ */ (0,jsx_runtime.jsx)(components_button.Button, {
                    "aria-expanded": isExpanded,
                    "aria-controls": sidebarControlsId,
                    title: isExpanded ? "Collapse sidebar" : "Expand sidebar",
                    className: _temp4,
                    onClick: ()=>{
                        setIsExpanded(_temp5);
                        setToggleAnimation(true);
                    },
                    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(SvgExpand, {
                        height: "12",
                        className: (0,clsx/* default */.Z)(!isExpanded && "x:*:first:origin-[35%] x:*:first:rotate-180")
                    })
                })
            ]
        });
        $[21] = hasI18n;
        $[22] = hasMenu;
        $[23] = isExpanded;
        $[24] = showToggleAnimation;
        $[25] = sidebarControlsId;
        $[26] = themeConfig.sidebar.toggleButton;
        $[27] = t11;
    } else {
        t11 = $[27];
    }
    let t12;
    if ($[28] !== sidebarControlsId || $[29] !== t10 || $[30] !== t11 || $[31] !== t6) {
        t12 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("aside", {
            id: sidebarControlsId,
            className: t6,
            children: [
                t10,
                t11
            ]
        });
        $[28] = sidebarControlsId;
        $[29] = t10;
        $[30] = t11;
        $[31] = t6;
        $[32] = t12;
    } else {
        t12 = $[32];
    }
    let t13;
    if ($[33] !== t12 || $[34] !== t3) {
        t13 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                t3,
                t12
            ]
        });
        $[33] = t12;
        $[34] = t3;
        $[35] = t13;
    } else {
        t13 = $[35];
    }
    return t13;
};
function _temp() {
    (0,stores_menu/* setMenu */.K)(false);
}
function _temp2(v) {
    return v.depth === 2;
}
function _temp3(v) {
    return v.depth === 2;
}
function _temp4(t0) {
    const { hover } = t0;
    return (0,clsx/* default */.Z)("x:rounded-md x:p-2", hover ? "x:bg-gray-200 x:text-gray-900 x:dark:bg-primary-100/5 x:dark:text-gray-50" : "x:text-gray-600 x:dark:text-gray-400");
}
function _temp5(prev) {
    return !prev;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/components/theme-switch.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ThemeSwitch: function() { return /* binding */ ThemeSwitch; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ../../node_modules/next-themes/dist/index.mjs
var next_themes_dist = __webpack_require__("(app-pages-browser)/../../node_modules/next-themes/dist/index.mjs");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/components/select.js + 3 modules
var components_select = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/components/select.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/hooks/use-mounted.js
var use_mounted = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-mounted.js");
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/icons/moon.js


const SvgMoon = (props) => {
  const $ = (0,dist.c)(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { strokeLinejoin: "round", strokeWidth: 2, d: "M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { fill: "currentColor", viewBox: "2 2 20 20", stroke: "currentColor", ...props, children: t0 });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
};


;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/icons/sun.js


const SvgSun = (props) => {
  const $ = (0,dist.c)(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { strokeLinecap: "round", strokeWidth: 2, d: "M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { fill: "currentColor", viewBox: "2 2 20 20", stroke: "currentColor", ...props, children: t0 });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
};


// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/theme-config.js
var theme_config = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/theme-config.js");
;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/components/theme-switch.js
/* __next_internal_client_entry_do_not_use__ ThemeSwitch auto */ 







const ThemeSwitch = (t0)=>{
    const $ = (0,dist.c)(23);
    const { lite, className } = t0;
    const { setTheme, resolvedTheme, theme } = (0,next_themes_dist/* useTheme */.F)();
    const mounted = (0,use_mounted.useMounted)();
    const { darkMode, themeSwitch } = (0,theme_config.useThemeConfig)();
    if (!darkMode) {
        return null;
    }
    const IconToUse = mounted && resolvedTheme === "dark" ? SvgMoon : SvgSun;
    const id = mounted ? theme : "light";
    let t1;
    if ($[0] !== className) {
        t1 = (0,clsx/* default */.Z)("x:flex x:items-center x:gap-2", className);
        $[0] = className;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    let t2;
    if ($[2] !== themeSwitch.light) {
        t2 = {
            id: "light",
            name: themeSwitch.light
        };
        $[2] = themeSwitch.light;
        $[3] = t2;
    } else {
        t2 = $[3];
    }
    let t3;
    if ($[4] !== themeSwitch.dark) {
        t3 = {
            id: "dark",
            name: themeSwitch.dark
        };
        $[4] = themeSwitch.dark;
        $[5] = t3;
    } else {
        t3 = $[5];
    }
    let t4;
    if ($[6] !== themeSwitch.system) {
        t4 = {
            id: "system",
            name: themeSwitch.system
        };
        $[6] = themeSwitch.system;
        $[7] = t4;
    } else {
        t4 = $[7];
    }
    let t5;
    if ($[8] !== t2 || $[9] !== t3 || $[10] !== t4) {
        t5 = [
            t2,
            t3,
            t4
        ];
        $[8] = t2;
        $[9] = t3;
        $[10] = t4;
        $[11] = t5;
    } else {
        t5 = $[11];
    }
    let t6;
    if ($[12] !== IconToUse) {
        t6 = /* @__PURE__ */ (0,jsx_runtime.jsx)(IconToUse, {
            height: "12"
        });
        $[12] = IconToUse;
        $[13] = t6;
    } else {
        t6 = $[13];
    }
    const t7 = !lite && themeSwitch[id];
    let t8;
    if ($[14] !== t6 || $[15] !== t7) {
        t8 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                t6,
                t7
            ]
        });
        $[14] = t6;
        $[15] = t7;
        $[16] = t8;
    } else {
        t8 = $[16];
    }
    let t9;
    if ($[17] !== id || $[18] !== setTheme || $[19] !== t1 || $[20] !== t5 || $[21] !== t8) {
        t9 = /* @__PURE__ */ (0,jsx_runtime.jsx)(components_select.Select, {
            className: t1,
            title: "Change theme",
            options: t5,
            onChange: setTheme,
            value: id,
            selectedOption: t8
        });
        $[17] = id;
        $[18] = setTheme;
        $[19] = t1;
        $[20] = t5;
        $[21] = t8;
        $[22] = t9;
    } else {
        t9 = $[22];
    }
    return t9;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/components/toc.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  TOC: function() { return /* binding */ TOC; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/mdx-components/anchor.js + 1 modules
var mdx_components_anchor = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/mdx-components/anchor.js");
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
// EXTERNAL MODULE: ../../node_modules/scroll-into-view-if-needed/dist/index.js + 1 modules
var scroll_into_view_if_needed_dist = __webpack_require__("(app-pages-browser)/../../node_modules/scroll-into-view-if-needed/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/active-anchor.js
var active_anchor = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/active-anchor.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/theme-config.js
var theme_config = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/theme-config.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/toc.js
var stores_toc = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/toc.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/config.js + 1 modules
var config = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/config.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/utils/get-git-issue-url.js
var get_git_issue_url = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/utils/get-git-issue-url.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/utils/git-url-parse.js
var git_url_parse = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/utils/git-url-parse.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/components/button.js + 1 modules
var components_button = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/components/button.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/icons/arrow-right.js
var arrow_right = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/icons/arrow-right.js");
;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/components/back-to-top.js





const SCROLL_TO_OPTIONS = {
    top: 0,
    behavior: "smooth"
};
const scrollToTop = (event)=>{
    const buttonElement = event.currentTarget;
    const tocElement = buttonElement.parentElement.parentElement;
    window.scrollTo(SCROLL_TO_OPTIONS);
    tocElement.scrollTo(SCROLL_TO_OPTIONS);
    buttonElement.disabled = true;
};
const BackToTop = (t0)=>{
    const $ = (0,dist.c)(8);
    const { children, className, hidden } = t0;
    const t1 = hidden ? "true" : void 0;
    let t2;
    if ($[0] !== className) {
        t2 = (t32)=>{
            const { disabled } = t32;
            return (0,clsx/* default */.Z)("x:flex x:items-center x:gap-1.5", "x:whitespace-nowrap", disabled ? "x:opacity-0" : "x:opacity-100", className);
        };
        $[0] = className;
        $[1] = t2;
    } else {
        t2 = $[1];
    }
    let t3;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = /* @__PURE__ */ (0,jsx_runtime.jsx)(arrow_right/* ReactComponent */.r, {
            height: "1.1em",
            className: "x:-rotate-90 x:border x:rounded-full x:border-current"
        });
        $[2] = t3;
    } else {
        t3 = $[2];
    }
    let t4;
    if ($[3] !== children || $[4] !== hidden || $[5] !== t1 || $[6] !== t2) {
        t4 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(components_button.Button, {
            "aria-hidden": t1,
            onClick: scrollToTop,
            disabled: hidden,
            className: t2,
            children: [
                children,
                t3
            ]
        });
        $[3] = children;
        $[4] = hidden;
        $[5] = t1;
        $[6] = t2;
        $[7] = t4;
    } else {
        t4 = $[7];
    }
    return t4;
};


;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/components/toc.js
/* __next_internal_client_entry_do_not_use__ TOC auto */ 








const linkClassName = (0,clsx/* default */.Z)("x:text-xs x:font-medium x:transition", "x:text-gray-600 x:dark:text-gray-400", "x:hover:text-gray-800 x:dark:hover:text-gray-200", "x:contrast-more:text-gray-700 x:contrast-more:dark:text-gray-100");
const TOC = (t0)=>{
    const $ = (0,dist.c)(34);
    const { filePath, pageTitle } = t0;
    const activeSlug = (0,active_anchor/* useActiveAnchor */.t)();
    const tocRef = (0,react.useRef)(null);
    const themeConfig = (0,theme_config.useThemeConfig)();
    const toc = (0,stores_toc.useTOC)();
    const hasMetaInfo = themeConfig.feedback.content || themeConfig.editLink || themeConfig.toc.extraContent || themeConfig.toc.backToTop;
    const { activeType } = (0,config.useConfig)().normalizePagesResult;
    let t1;
    if ($[0] !== activeType || $[1] !== themeConfig.toc.float || $[2] !== toc) {
        t1 = themeConfig.toc.float || activeType === "page" ? toc : [];
        $[0] = activeType;
        $[1] = themeConfig.toc.float;
        $[2] = toc;
        $[3] = t1;
    } else {
        t1 = $[3];
    }
    const anchors = t1;
    const hasHeadings = anchors.length > 0;
    let t2;
    if ($[4] !== activeSlug) {
        t2 = (t32)=>{
            const { id } = t32;
            return id === activeSlug;
        };
        $[4] = activeSlug;
        $[5] = t2;
    } else {
        t2 = $[5];
    }
    const activeIndex = toc.findIndex(t2);
    let t3;
    let t4;
    if ($[6] !== activeSlug) {
        t3 = ()=>{
            var _tocRef_current;
            if (!activeSlug) {
                return;
            }
            const anchor = (_tocRef_current = tocRef.current) === null || _tocRef_current === void 0 ? void 0 : _tocRef_current.querySelector('a[href="#'.concat(activeSlug, '"]'));
            if (!anchor) {
                return;
            }
            (0,scroll_into_view_if_needed_dist/* default */.Z)(anchor, {
                behavior: "smooth",
                block: "center",
                inline: "center",
                scrollMode: "if-needed",
                boundary: tocRef.current
            });
        };
        t4 = [
            activeSlug
        ];
        $[6] = activeSlug;
        $[7] = t3;
        $[8] = t4;
    } else {
        t3 = $[7];
        t4 = $[8];
    }
    (0,react.useEffect)(t3, t4);
    let t5;
    if ($[9] !== pageTitle || $[10] !== themeConfig.docsRepositoryBase || $[11] !== themeConfig.feedback.labels || $[12] !== themeConfig.feedback.link) {
        var _themeConfig_feedback_link;
        t5 = (_themeConfig_feedback_link = themeConfig.feedback.link) !== null && _themeConfig_feedback_link !== void 0 ? _themeConfig_feedback_link : (0,get_git_issue_url/* getGitIssueUrl */.K)({
            labels: themeConfig.feedback.labels,
            repository: themeConfig.docsRepositoryBase,
            title: "Feedback for “".concat(pageTitle, "”")
        });
        $[9] = pageTitle;
        $[10] = themeConfig.docsRepositoryBase;
        $[11] = themeConfig.feedback.labels;
        $[12] = themeConfig.feedback.link;
        $[13] = t5;
    } else {
        t5 = $[13];
    }
    const feedbackLink = t5;
    let t6;
    if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
        t6 = (0,clsx/* default */.Z)("x:grid x:grid-rows-[min-content_1fr_min-content]", "x:sticky x:top-(--nextra-navbar-height) x:text-sm", "x:max-h-[calc(100vh-var(--nextra-navbar-height))]");
        $[14] = t6;
    } else {
        t6 = $[14];
    }
    let t7;
    if ($[15] !== activeSlug || $[16] !== anchors || $[17] !== hasHeadings || $[18] !== themeConfig.toc.title) {
        t7 = hasHeadings && /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)("p", {
                    className: "x:pt-6 x:px-4 x:font-semibold x:tracking-tight",
                    children: themeConfig.toc.title
                }),
                /* @__PURE__ */ (0,jsx_runtime.jsx)("ul", {
                    ref: tocRef,
                    className: (0,clsx/* default */.Z)("x:p-4 nextra-scrollbar x:overscroll-y-contain x:overflow-y-auto x:hyphens-auto", "nextra-mask"),
                    children: anchors.map((t82)=>{
                        const { id: id_0, value, depth } = t82;
                        return /* @__PURE__ */ (0,jsx_runtime.jsx)("li", {
                            className: "x:my-2 x:scroll-my-6 x:scroll-py-6",
                            children: /* @__PURE__ */ (0,jsx_runtime.jsx)("a", {
                                href: "#".concat(id_0),
                                className: (0,clsx/* default */.Z)("x:focus-visible:nextra-focus", {
                                    2: "x:font-semibold",
                                    3: "x:ms-3",
                                    4: "x:ms-6",
                                    5: "x:ms-9",
                                    6: "x:ms-12"
                                }[depth], "x:block x:transition-colors x:subpixel-antialiased", id_0 === activeSlug ? "x:text-primary-600 x:contrast-more:text-primary-600!" : "x:text-gray-600 x:hover:text-gray-900 x:dark:text-gray-400 x:dark:hover:text-gray-300", "x:contrast-more:text-gray-900 x:contrast-more:underline x:contrast-more:dark:text-gray-50 x:break-words"),
                                children: value
                            })
                        }, id_0);
                    })
                })
            ]
        });
        $[15] = activeSlug;
        $[16] = anchors;
        $[17] = hasHeadings;
        $[18] = themeConfig.toc.title;
        $[19] = t7;
    } else {
        t7 = $[19];
    }
    let t8;
    if ($[20] !== activeIndex || $[21] !== feedbackLink || $[22] !== filePath || $[23] !== hasHeadings || $[24] !== hasMetaInfo || $[25] !== themeConfig.docsRepositoryBase || $[26] !== themeConfig.editLink || $[27] !== themeConfig.feedback.content || $[28] !== themeConfig.toc.backToTop || $[29] !== themeConfig.toc.extraContent) {
        t8 = hasMetaInfo && /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", {
            className: (0,clsx/* default */.Z)("x:grid x:gap-2 x:py-4 x:mx-4", hasHeadings && "x:border-t nextra-border"),
            children: [
                themeConfig.feedback.content && /* @__PURE__ */ (0,jsx_runtime.jsx)(mdx_components_anchor/* Anchor */.e, {
                    className: linkClassName,
                    href: feedbackLink,
                    children: themeConfig.feedback.content
                }),
                filePath && themeConfig.editLink && /* @__PURE__ */ (0,jsx_runtime.jsx)(mdx_components_anchor/* Anchor */.e, {
                    className: linkClassName,
                    href: filePath.startsWith("http") ? filePath : "".concat((0,git_url_parse/* gitUrlParse */.Y)(themeConfig.docsRepositoryBase).href, "/").concat(filePath),
                    children: themeConfig.editLink
                }),
                themeConfig.toc.extraContent,
                themeConfig.toc.backToTop && /* @__PURE__ */ (0,jsx_runtime.jsx)(BackToTop, {
                    className: linkClassName,
                    hidden: activeIndex < 2,
                    children: themeConfig.toc.backToTop
                })
            ]
        });
        $[20] = activeIndex;
        $[21] = feedbackLink;
        $[22] = filePath;
        $[23] = hasHeadings;
        $[24] = hasMetaInfo;
        $[25] = themeConfig.docsRepositoryBase;
        $[26] = themeConfig.editLink;
        $[27] = themeConfig.feedback.content;
        $[28] = themeConfig.toc.backToTop;
        $[29] = themeConfig.toc.extraContent;
        $[30] = t8;
    } else {
        t8 = $[30];
    }
    let t9;
    if ($[31] !== t7 || $[32] !== t8) {
        t9 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", {
            className: t6,
            children: [
                t7,
                t8
            ]
        });
        $[31] = t7;
        $[32] = t8;
        $[33] = t9;
    } else {
        t9 = $[33];
    }
    return t9;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/mdx-components/heading-anchor.client.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HeadingAnchor: function() { return /* binding */ HeadingAnchor; }
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/active-anchor.js");
/* __next_internal_client_entry_do_not_use__ HeadingAnchor auto */ 



const callback = (entries)=>{
    const entry = entries.find((entry2)=>entry2.isIntersecting);
    if (entry) {
        const slug = entry.target.hash.slice(1);
        (0,_stores__WEBPACK_IMPORTED_MODULE_3__/* .setActiveSlug */ .Z)(decodeURI(slug));
    }
};
const observer = typeof window === "undefined" ? null : new IntersectionObserver(callback, {
    rootMargin: "-".concat(getComputedStyle(document.body).getPropertyValue("--nextra-navbar-height") || // can be '' on 404 page
    "0%", " 0% -80%")
});
const HeadingAnchor = (t0)=>{
    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(4);
    const { id } = t0;
    const anchorRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);
    let t1;
    let t2;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = ()=>{
            const el = anchorRef.current;
            observer.observe(el);
            return ()=>{
                observer.unobserve(el);
            };
        };
        t2 = [];
        $[0] = t1;
        $[1] = t2;
    } else {
        t1 = $[0];
        t2 = $[1];
    }
    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t1, t2);
    const t3 = "#".concat(id);
    let t4;
    if ($[2] !== t3) {
        t4 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("a", {
            href: t3,
            className: "x:focus-visible:nextra-focus subheading-anchor",
            "aria-label": "Permalink for this section",
            ref: anchorRef
        });
        $[2] = t3;
        $[3] = t4;
    } else {
        t4 = $[3];
    }
    return t4;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/mdx-components/wrapper.client.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ClientWrapper: function() { return /* binding */ ClientWrapper; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/components/toc.js + 1 modules
var toc = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/components/toc.js");
// EXTERNAL MODULE: ./node_modules/next/dist/api/link.js
var api_link = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/api/link.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/icons/arrow-right.js
var arrow_right = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/icons/arrow-right.js");
;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/utils/extract-only-strings-from-react-node.js
function extractStringsFromReactNode(node) {
    var _node_props;
    if (typeof node === "string") return node;
    if (typeof node === "number") return String(node);
    if (Array.isArray(node)) return node.map((n)=>extractStringsFromReactNode(n)).join("");
    const children = node === null || node === void 0 ? void 0 : (_node_props = node.props) === null || _node_props === void 0 ? void 0 : _node_props.children;
    if (!children) return "";
    return extractStringsFromReactNode(children);
}


;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/components/breadcrumb.js







const Breadcrumb = (t0)=>{
    const $ = (0,dist.c)(4);
    const { activePath } = t0;
    let t1;
    if ($[0] !== activePath) {
        t1 = activePath.map(_temp);
        $[0] = activePath;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    let t2;
    if ($[2] !== t1) {
        t2 = /* @__PURE__ */ (0,jsx_runtime.jsx)("div", {
            className: "nextra-breadcrumb x:mt-1.5 x:flex x:items-center x:gap-1 x:overflow-hidden x:text-sm x:text-gray-600 x:dark:text-gray-400 x:contrast-more:text-current",
            children: t1
        });
        $[2] = t1;
        $[3] = t2;
    } else {
        t2 = $[3];
    }
    return t2;
};
function _temp(item, index, arr) {
    const nextItem = arr[index + 1];
    const href = nextItem ? "frontMatter" in item ? item.route : item.children[0].route === nextItem.route ? "" : item.children[0].route : "";
    const ComponentToUse = href ? api_link["default"] : "span";
    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(react.Fragment, {
        children: [
            index > 0 && /* @__PURE__ */ (0,jsx_runtime.jsx)(arrow_right/* ReactComponent */.r, {
                height: "14",
                className: "x:shrink-0 x:rtl:rotate-180"
            }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)(ComponentToUse, {
                className: (0,clsx/* default */.Z)("x:whitespace-nowrap x:transition-colors", nextItem ? "x:min-w-6 x:overflow-hidden x:text-ellipsis" : "x:font-medium x:text-black x:dark:text-gray-100", href && "x:focus-visible:nextra-focus x:ring-inset x:hover:text-gray-900 x:dark:hover:text-gray-100"),
                title: extractStringsFromReactNode(item.title),
                ...href && {
                    href,
                    prefetch: false
                },
                children: item.title
            })
        ]
    }, item.route + item.name);
}


// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/components/button.js + 1 modules
var components_button = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/components/button.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/components/select.js + 3 modules
var components_select = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/components/select.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/hooks/use-copy.js
var use_copy = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-copy.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/icons/link-arrow.js
var link_arrow = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/icons/link-arrow.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/icons/copy.js
var icons_copy = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/icons/copy.js");
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/icons/chatgpt.js


const SvgChatgpt = (props) => {
  const $ = (0,dist.c)(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M11.2475 18.25C10.6975 18.25 10.175 18.1455 9.67999 17.9365C9.18499 17.7275 8.74499 17.436 8.35999 17.062C7.94199 17.205 7.50749 17.2765 7.05649 17.2765C6.31949 17.2765 5.63749 17.095 5.01049 16.732C4.38349 16.369 3.87749 15.874 3.49249 15.247C3.11849 14.62 2.93149 13.9215 2.93149 13.1515C2.93149 12.8325 2.97549 12.486 3.06349 12.112C2.62349 11.705 2.28249 11.2375 2.04049 10.7095C1.79849 10.1705 1.67749 9.6095 1.67749 9.0265C1.67749 8.4325 1.80399 7.8605 2.05699 7.3105C2.30999 6.7605 2.66199 6.2875 3.11299 5.8915C3.57499 5.4845 4.10849 5.204 4.71349 5.05C4.83449 4.423 5.08749 3.862 5.47249 3.367C5.86849 2.861 6.35249 2.465 6.92449 2.179C7.49649 1.893 8.10699 1.75 8.75599 1.75C9.30599 1.75 9.82849 1.8545 10.3235 2.0635C10.8185 2.2725 11.2585 2.564 11.6435 2.938C12.0615 2.795 12.496 2.7235 12.947 2.7235C13.684 2.7235 14.366 2.905 14.993 3.268C15.62 3.631 16.1205 4.126 16.4945 4.753C16.8795 5.38 17.072 6.0785 17.072 6.8485C17.072 7.1675 17.028 7.514 16.94 7.888C17.38 8.295 17.721 8.768 17.963 9.307C18.205 9.835 18.326 10.3905 18.326 10.9735C18.326 11.5675 18.1995 12.1395 17.9465 12.6895C17.6935 13.2395 17.336 13.718 16.874 14.125C16.423 14.521 15.895 14.796 15.29 14.95C15.169 15.577 14.9105 16.138 14.5145 16.633C14.1295 17.139 13.651 17.535 13.079 17.821C12.507 18.107 11.8965 18.25 11.2475 18.25ZM7.17199 16.1875C7.72199 16.1875 8.20049 16.072 8.60749 15.841L11.7095 14.059C11.8195 13.982 11.8745 13.8775 11.8745 13.7455V12.3265L7.88149 14.62C7.63949 14.763 7.39749 14.763 7.15549 14.62L4.03699 12.8215C4.03699 12.8545 4.03149 12.893 4.02049 12.937C4.02049 12.981 4.02049 13.047 4.02049 13.135C4.02049 13.696 4.15249 14.213 4.41649 14.686C4.69149 15.148 5.07099 15.511 5.55499 15.775C6.03899 16.05 6.57799 16.1875 7.17199 16.1875ZM7.33699 13.498C7.40299 13.531 7.46349 13.5475 7.51849 13.5475C7.57349 13.5475 7.62849 13.531 7.68349 13.498L8.92099 12.7885L4.94449 10.4785C4.70249 10.3355 4.58149 10.121 4.58149 9.835V6.2545C4.03149 6.4965 3.59149 6.8705 3.26149 7.3765C2.93149 7.8715 2.76649 8.4215 2.76649 9.0265C2.76649 9.5655 2.90399 10.0825 3.17899 10.5775C3.45399 11.0725 3.81149 11.4465 4.25149 11.6995L7.33699 13.498ZM11.2475 17.161C11.8305 17.161 12.3585 17.029 12.8315 16.765C13.3045 16.501 13.6785 16.138 13.9535 15.676C14.2285 15.214 14.366 14.697 14.366 14.125V10.561C14.366 10.429 14.311 10.33 14.201 10.264L12.947 9.538V14.1415C12.947 14.4275 12.826 14.642 12.584 14.785L9.46549 16.5835C10.0045 16.9685 10.5985 17.161 11.2475 17.161ZM11.8745 11.122V8.878L10.01 7.822L8.12899 8.878V11.122L10.01 12.178L11.8745 11.122ZM7.05649 5.8585C7.05649 5.5725 7.17749 5.358 7.41949 5.215L10.538 3.4165C9.99899 3.0315 9.40499 2.839 8.75599 2.839C8.17299 2.839 7.64499 2.971 7.17199 3.235C6.69899 3.499 6.32499 3.862 6.04999 4.324C5.78599 4.786 5.65399 5.303 5.65399 5.875V9.4225C5.65399 9.5545 5.70899 9.659 5.81899 9.736L7.05649 10.462V5.8585ZM15.4385 13.7455C15.9885 13.5035 16.423 13.1295 16.742 12.6235C17.072 12.1175 17.237 11.5675 17.237 10.9735C17.237 10.4345 17.0995 9.9175 16.8245 9.4225C16.5495 8.9275 16.192 8.5535 15.752 8.3005L12.6665 6.5185C12.6005 6.4745 12.54 6.458 12.485 6.469C12.43 6.469 12.375 6.4855 12.32 6.5185L11.0825 7.2115L15.0755 9.538C15.1965 9.604 15.2845 9.692 15.3395 9.802C15.4055 9.901 15.4385 10.022 15.4385 10.165V13.7455ZM12.122 5.3635C12.364 5.2095 12.606 5.2095 12.848 5.3635L15.983 7.195C15.983 7.118 15.983 7.019 15.983 6.898C15.983 6.37 15.851 5.8695 15.587 5.3965C15.334 4.9125 14.9655 4.5275 14.4815 4.2415C14.0085 3.9555 13.4585 3.8125 12.8315 3.8125C12.2815 3.8125 11.803 3.928 11.396 4.159L8.29399 5.941C8.18399 6.018 8.12899 6.1225 8.12899 6.2545V7.6735L12.122 5.3635Z" });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 20 20", fill: "currentColor", ...props, children: t0 });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
};


;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/icons/claude.js


const SvgClaude = (props) => {
  const $ = (0,dist.c)(14);
  let t0;
  let t1;
  let t10;
  let t11;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M96.0000 40.0000 L99.5002 42.0000 L99.5002 43.5000 L98.5000 47.0000 L56.0000 57.0000 L52.0040 47.0708 L96.0000 40.0000 M96.0000 40.0000 " });
    t1 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M80.1032 10.5903 L84.9968 11.6171 L86.2958 13.2179 L87.5346 17.0540 L87.0213 19.5007 L58.5000 58.5000 L49.0000 49.0000 L75.3008 14.4873 L80.1032 10.5903 M80.1032 10.5903 " });
    t2 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M55.5002 4.5000 L58.5005 2.5000 L61.0002 3.5000 L63.5002 7.0000 L56.6511 48.1620 L52.0005 45.0000 L50.0005 39.5000 L53.5003 8.5000 L55.5002 4.5000 M55.5002 4.5000 " });
    t3 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M23.4253 5.1588 L26.5075 1.2217 L28.5175 0.7632 L32.5063 1.3458 L34.4748 2.8868 L48.8202 34.6902 L54.0089 49.8008 L47.9378 53.1760 L24.8009 11.1886 L23.4253 5.1588 M23.4253 5.1588 " });
    t4 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M8.4990 27.0019 L7.4999 23.0001 L10.5003 19.5001 L14.0003 20.0001 L15.0003 20.0001 L36.0000 35.5000 L42.5000 40.5000 L51.5000 47.5000 L46.5000 56.0000 L42.0002 52.5000 L39.0001 49.5000 L10.0000 29.0001 L8.4990 27.0019 M8.4990 27.0019 " });
    t5 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M2.5003 53.0000 L0.2370 50.5000 L0.2373 48.2759 L2.5003 47.5000 L28.0000 49.0000 L53.0000 51.0000 L52.1885 55.9782 L4.5000 53.5000 L2.5003 53.0000 M2.5003 53.0000 " });
    t6 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M17.5002 79.0264 L12.5005 79.0264 L10.5124 76.7369 L10.5124 74.0000 L19.0005 68.0000 L53.5082 46.0337 L57.0005 52.0000 L17.5002 79.0264 M17.5002 79.0264 " });
    t7 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M27.0004 92.9999 L25.0003 93.4999 L22.0003 91.9999 L22.5004 89.4999 L52.0003 50.5000 L56.0004 55.9999 L34.0003 85.0000 L27.0004 92.9999 M27.0004 92.9999 " });
    t8 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M51.9998 98.0000 L50.5002 100.0000 L47.5002 101.0000 L45.0001 99.0000 L43.5000 96.0000 L51.0003 55.4999 L55.5001 55.9999 L51.9998 98.0000 M51.9998 98.0000 " });
    t9 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M77.5007 86.9997 L77.5007 90.9997 L77.0006 92.4997 L75.0004 93.4997 L71.5006 93.0339 L47.4669 57.2642 L56.9998 50.0002 L64.9994 64.5004 L65.7507 69.7497 L77.5007 86.9997 M77.5007 86.9997 " });
    t10 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M89.0008 80.9991 L89.5008 83.4991 L88.0008 85.4991 L86.5007 84.9991 L78.0007 78.9991 L65.0007 67.4991 L55.0007 60.4991 L58.0000 51.0000 L62.9999 54.0001 L66.0007 59.4991 L89.0008 80.9991 M89.0008 80.9991 " });
    t11 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M82.5003 55.5000 L95.0003 56.5000 L98.0003 58.5000 L100.0000 61.5000 L100.0000 63.6587 L94.5003 66.0000 L66.5005 59.0000 L55.0003 58.5000 L58.0000 48.0000 L66.0005 54.0000 L82.5003 55.5000 M82.5003 55.5000 " });
    $[0] = t0;
    $[1] = t1;
    $[2] = t10;
    $[3] = t11;
    $[4] = t2;
    $[5] = t3;
    $[6] = t4;
    $[7] = t5;
    $[8] = t6;
    $[9] = t7;
    $[10] = t8;
    $[11] = t9;
  } else {
    t0 = $[0];
    t1 = $[1];
    t10 = $[2];
    t11 = $[3];
    t2 = $[4];
    t3 = $[5];
    t4 = $[6];
    t5 = $[7];
    t6 = $[8];
    t7 = $[9];
    t8 = $[10];
    t9 = $[11];
  }
  let t12;
  if ($[12] !== props) {
    t12 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { viewBox: "0 0 100 101", fill: "currentColor", ...props, children: [
      t0,
      t1,
      t2,
      t3,
      t4,
      t5,
      t6,
      t7,
      t8,
      t9,
      t10,
      t11
    ] });
    $[12] = props;
    $[13] = t12;
  } else {
    t12 = $[13];
  }
  return t12;
};


;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/components/copy-page.js






const Item = (t0)=>{
    const $ = (0,dist.c)(15);
    const { icon: Icon, title, description, isExternal } = t0;
    let t1;
    if ($[0] !== Icon) {
        t1 = /* @__PURE__ */ (0,jsx_runtime.jsx)(Icon, {
            width: "16"
        });
        $[0] = Icon;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    let t2;
    if ($[2] !== isExternal) {
        t2 = isExternal && /* @__PURE__ */ (0,jsx_runtime.jsx)(link_arrow/* ReactComponent */.r, {
            height: "1em"
        });
        $[2] = isExternal;
        $[3] = t2;
    } else {
        t2 = $[3];
    }
    let t3;
    if ($[4] !== t2 || $[5] !== title) {
        t3 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("span", {
            className: "x:font-medium x:flex x:gap-1",
            children: [
                title,
                t2
            ]
        });
        $[4] = t2;
        $[5] = title;
        $[6] = t3;
    } else {
        t3 = $[6];
    }
    let t4;
    if ($[7] !== description) {
        t4 = /* @__PURE__ */ (0,jsx_runtime.jsx)("span", {
            className: "x:text-xs",
            children: description
        });
        $[7] = description;
        $[8] = t4;
    } else {
        t4 = $[8];
    }
    let t5;
    if ($[9] !== t3 || $[10] !== t4) {
        t5 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", {
            className: "x:flex x:flex-col",
            children: [
                t3,
                t4
            ]
        });
        $[9] = t3;
        $[10] = t4;
        $[11] = t5;
    } else {
        t5 = $[11];
    }
    let t6;
    if ($[12] !== t1 || $[13] !== t5) {
        t6 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", {
            className: "x:flex x:gap-3 x:items-center",
            children: [
                t1,
                t5
            ]
        });
        $[12] = t1;
        $[13] = t5;
        $[14] = t6;
    } else {
        t6 = $[14];
    }
    return t6;
};
const CopyPage = (t0)=>{
    const $ = (0,dist.c)(20);
    const { sourceCode } = t0;
    const { copy, isCopied } = (0,use_copy.useCopy)();
    let t1;
    if ($[0] !== copy || $[1] !== sourceCode) {
        t1 = function handleCopy2() {
            copy(sourceCode);
        };
        $[0] = copy;
        $[1] = sourceCode;
        $[2] = t1;
    } else {
        t1 = $[2];
    }
    const handleCopy = t1;
    let t2;
    if ($[3] !== isCopied) {
        t2 = (t32)=>{
            const { hover } = t32;
            return (0,clsx/* default */.Z)("x:ps-2 x:pe-1 x:flex x:gap-2 x:text-sm x:font-medium x:items-center", isCopied && "x:opacity-70", hover && "x:bg-gray-200 x:text-gray-900 x:dark:bg-primary-100/5 x:dark:text-gray-50");
        };
        $[3] = isCopied;
        $[4] = t2;
    } else {
        t2 = $[4];
    }
    let t3;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = /* @__PURE__ */ (0,jsx_runtime.jsx)(icons_copy/* ReactComponent */.r, {
            width: "16"
        });
        $[5] = t3;
    } else {
        t3 = $[5];
    }
    const t4 = isCopied ? "Copied" : "Copy page";
    let t5;
    if ($[6] !== handleCopy || $[7] !== t2 || $[8] !== t4) {
        t5 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(components_button.Button, {
            className: t2,
            onClick: handleCopy,
            children: [
                t3,
                t4
            ]
        });
        $[6] = handleCopy;
        $[7] = t2;
        $[8] = t4;
        $[9] = t5;
    } else {
        t5 = $[9];
    }
    let t6;
    if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
        t6 = {
            to: "bottom end",
            gap: 10
        };
        $[10] = t6;
    } else {
        t6 = $[10];
    }
    let t7;
    if ($[11] === Symbol.for("react.memo_cache_sentinel")) {
        t7 = {
            id: "copy",
            name: /* @__PURE__ */ (0,jsx_runtime.jsx)(Item, {
                icon: icons_copy/* ReactComponent */.r,
                title: "Copy page",
                description: "Copy page as Markdown for LLMs"
            })
        };
        $[11] = t7;
    } else {
        t7 = $[11];
    }
    let t8;
    if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
        t8 = {
            id: "chatgpt",
            name: /* @__PURE__ */ (0,jsx_runtime.jsx)(Item, {
                icon: SvgChatgpt,
                title: "Open in ChatGPT",
                description: "Ask questions about this page",
                isExternal: true
            })
        };
        $[12] = t8;
    } else {
        t8 = $[12];
    }
    let t9;
    if ($[13] === Symbol.for("react.memo_cache_sentinel")) {
        t9 = [
            t7,
            t8,
            {
                id: "claude",
                name: /* @__PURE__ */ (0,jsx_runtime.jsx)(Item, {
                    icon: SvgClaude,
                    title: "Open in Claude",
                    description: "Ask questions about this page",
                    isExternal: true
                })
            }
        ];
        $[13] = t9;
    } else {
        t9 = $[13];
    }
    let t10;
    if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
        t10 = /* @__PURE__ */ (0,jsx_runtime.jsx)(arrow_right/* ReactComponent */.r, {
            width: "12",
            className: "x:rotate-90"
        });
        $[14] = t10;
    } else {
        t10 = $[14];
    }
    let t11;
    if ($[15] !== handleCopy) {
        t11 = /* @__PURE__ */ (0,jsx_runtime.jsx)(components_select.Select, {
            anchor: t6,
            className: "x:rounded-none",
            options: t9,
            value: "",
            selectedOption: t10,
            onChange: (value)=>{
                if (value === "copy") {
                    handleCopy();
                    return;
                }
                const url = value === "chatgpt" ? "chatgpt.com/?hints=search&prompt" : "claude.ai/new?q";
                const query = "Read from ".concat(location.href, " so I can ask questions about it.");
                window.open("https://".concat(url, "=").concat(encodeURIComponent(query)), "_blank");
            }
        });
        $[15] = handleCopy;
        $[16] = t11;
    } else {
        t11 = $[16];
    }
    let t12;
    if ($[17] !== t11 || $[18] !== t5) {
        t12 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", {
            className: "x:border x:inline-flex x:rounded-md x:items-stretch nextra-border x:float-end x:overflow-hidden",
            children: [
                t5,
                t11
            ]
        });
        $[17] = t11;
        $[18] = t5;
        $[19] = t12;
    } else {
        t12 = $[19];
    }
    return t12;
};


// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/config.js + 1 modules
var config = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/config.js");
// EXTERNAL MODULE: ../../node_modules/nextra-theme-docs/dist/stores/theme-config.js
var theme_config = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/theme-config.js");
;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/components/pagination.js







const classes = {
    link: (0,clsx/* default */.Z)("x:focus-visible:nextra-focus x:text-gray-600 x:dark:text-gray-400", "x:hover:text-gray-800 x:dark:hover:text-gray-200", "x:contrast-more:text-gray-700 x:contrast-more:dark:text-gray-100", "x:flex x:max-w-[50%] x:items-center x:gap-1 x:py-4 x:text-base x:font-medium x:transition-colors x:[word-break:break-word] x:md:text-lg"),
    icon: (0,clsx/* default */.Z)("x:inline x:shrink-0")
};
const Pagination = ()=>{
    const $ = (0,dist.c)(8);
    const { flatDocsDirectories, activeIndex } = (0,config.useConfig)().normalizePagesResult;
    const { navigation } = (0,theme_config.useThemeConfig)();
    let prev = navigation.prev && flatDocsDirectories[activeIndex - 1];
    let next = navigation.next && flatDocsDirectories[activeIndex + 1];
    if (prev && !prev.isUnderCurrentDocsTree) {
        prev = false;
    }
    if (next && !next.isUnderCurrentDocsTree) {
        next = false;
    }
    if (!prev && !next) {
        return null;
    }
    let t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = (0,clsx/* default */.Z)("x:mb-8 x:flex x:items-center x:border-t x:pt-8 nextra-border", "x:print:hidden");
        $[0] = t0;
    } else {
        t0 = $[0];
    }
    let t1;
    if ($[1] !== prev) {
        t1 = prev && /* @__PURE__ */ (0,jsx_runtime.jsxs)(api_link["default"], {
            href: prev.route,
            title: extractStringsFromReactNode(prev.title),
            className: (0,clsx/* default */.Z)(classes.link, "x:pe-4"),
            prefetch: false,
            children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(arrow_right/* ReactComponent */.r, {
                    height: "20",
                    className: (0,clsx/* default */.Z)(classes.icon, "x:ltr:rotate-180")
                }),
                prev.title
            ]
        });
        $[1] = prev;
        $[2] = t1;
    } else {
        t1 = $[2];
    }
    let t2;
    if ($[3] !== next) {
        t2 = next && /* @__PURE__ */ (0,jsx_runtime.jsxs)(api_link["default"], {
            href: next.route,
            title: extractStringsFromReactNode(next.title),
            className: (0,clsx/* default */.Z)(classes.link, "x:ps-4 x:ms-auto x:text-end"),
            prefetch: false,
            children: [
                next.title,
                /* @__PURE__ */ (0,jsx_runtime.jsx)(arrow_right/* ReactComponent */.r, {
                    height: "20",
                    className: (0,clsx/* default */.Z)(classes.icon, "x:rtl:rotate-180")
                })
            ]
        });
        $[3] = next;
        $[4] = t2;
    } else {
        t2 = $[4];
    }
    let t3;
    if ($[5] !== t1 || $[6] !== t2) {
        t3 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", {
            className: t0,
            children: [
                t1,
                t2
            ]
        });
        $[5] = t1;
        $[6] = t2;
        $[7] = t3;
    } else {
        t3 = $[7];
    }
    return t3;
};


;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/mdx-components/wrapper.client.js
/* __next_internal_client_entry_do_not_use__ ClientWrapper auto */ 





const ClientWrapper = (t0)=>{
    const $ = (0,dist.c)(29);
    const { children, metadata, bottomContent, sourceCode } = t0;
    const { activeType, activeThemeContext: themeContext, activePath } = (0,config.useConfig)().normalizePagesResult;
    const themeConfig = (0,theme_config.useThemeConfig)();
    const date = themeContext.timestamp && metadata.timestamp;
    let t1;
    if ($[0] !== metadata || $[1] !== themeContext.layout || $[2] !== themeContext.toc) {
        t1 = (themeContext.layout === "default" || themeContext.toc) && /* @__PURE__ */ (0,jsx_runtime.jsx)("nav", {
            className: "nextra-toc x:order-last x:max-xl:hidden x:w-64 x:shrink-0 x:print:hidden",
            "aria-label": "table of contents",
            children: themeContext.toc && /* @__PURE__ */ (0,jsx_runtime.jsx)(toc.TOC, {
                filePath: metadata.filePath,
                pageTitle: metadata.title
            })
        });
        $[0] = metadata;
        $[1] = themeContext.layout;
        $[2] = themeContext.toc;
        $[3] = t1;
    } else {
        t1 = $[3];
    }
    const t2 = themeContext.typesetting === "article" && "nextra-body-typesetting-article";
    let t3;
    if ($[4] !== t2) {
        t3 = (0,clsx/* default */.Z)("x:w-full x:min-w-0 x:break-words x:min-h-[calc(100vh-var(--nextra-navbar-height))]", "x:text-slate-700 x:dark:text-slate-200 x:pb-8 x:px-4 x:pt-4 x:md:px-12", t2);
        $[4] = t2;
        $[5] = t3;
    } else {
        t3 = $[5];
    }
    let t4;
    if ($[6] !== activePath || $[7] !== activeType || $[8] !== themeContext.breadcrumb) {
        t4 = themeContext.breadcrumb && activeType !== "page" && /* @__PURE__ */ (0,jsx_runtime.jsx)(Breadcrumb, {
            activePath
        });
        $[6] = activePath;
        $[7] = activeType;
        $[8] = themeContext.breadcrumb;
        $[9] = t4;
    } else {
        t4 = $[9];
    }
    let t5;
    if ($[10] !== sourceCode) {
        t5 = sourceCode && /* @__PURE__ */ (0,jsx_runtime.jsx)(CopyPage, {
            sourceCode
        });
        $[10] = sourceCode;
        $[11] = t5;
    } else {
        t5 = $[11];
    }
    let t6;
    if ($[12] !== date || $[13] !== themeConfig) {
        t6 = date ? /* @__PURE__ */ (0,jsx_runtime.jsx)("div", {
            className: "x:mt-12 x:mb-8 x:text-xs x:text-gray-600 x:text-end x:dark:text-gray-400",
            children: /*#__PURE__*/ (0,react.cloneElement)(themeConfig.lastUpdated, {
                date: new Date(date)
            })
        }) : /* @__PURE__ */ (0,jsx_runtime.jsx)("div", {
            className: "x:mt-16"
        });
        $[12] = date;
        $[13] = themeConfig;
        $[14] = t6;
    } else {
        t6 = $[14];
    }
    let t7;
    if ($[15] !== activeType || $[16] !== themeContext.pagination) {
        t7 = themeContext.pagination && activeType !== "page" && /* @__PURE__ */ (0,jsx_runtime.jsx)(Pagination, {});
        $[15] = activeType;
        $[16] = themeContext.pagination;
        $[17] = t7;
    } else {
        t7 = $[17];
    }
    let t8;
    if ($[18] !== bottomContent || $[19] !== children || $[20] !== t3 || $[21] !== t4 || $[22] !== t5 || $[23] !== t6 || $[24] !== t7) {
        t8 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("article", {
            className: t3,
            children: [
                t4,
                t5,
                children,
                t6,
                t7,
                bottomContent
            ]
        });
        $[18] = bottomContent;
        $[19] = children;
        $[20] = t3;
        $[21] = t4;
        $[22] = t5;
        $[23] = t6;
        $[24] = t7;
        $[25] = t8;
    } else {
        t8 = $[25];
    }
    let t9;
    if ($[26] !== t1 || $[27] !== t8) {
        t9 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                t1,
                t8
            ]
        });
        $[26] = t1;
        $[27] = t8;
        $[28] = t9;
    } else {
        t9 = $[28];
    }
    return t9;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/active-anchor.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: function() { return /* binding */ setActiveSlug; },
/* harmony export */   t: function() { return /* binding */ useActiveAnchor; }
/* harmony export */ });
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/zustand/esm/react.mjs");
"use no memo";

const useActiveAnchorStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__/* .create */ .U)(()=>({
        activeSlug: ""
    }));
const useActiveAnchor = ()=>useActiveAnchorStore((state)=>state.activeSlug);
const setActiveSlug = (activeSlug)=>{
    useActiveAnchorStore.setState({
        activeSlug
    });
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/config.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ConfigProvider: function() { return /* binding */ ConfigProvider; },
  useConfig: function() { return /* binding */ useConfig; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/hooks/use-fs-route.js
var use_fs_route = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-fs-route.js");
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/normalize-pages.js
"use no memo";
const DEFAULT_PAGE_THEME = {
  breadcrumb: true,
  collapsed: void 0,
  footer: true,
  layout: "default",
  navbar: true,
  pagination: true,
  sidebar: true,
  timestamp: true,
  toc: true,
  typesetting: "default"
};
function extendMeta(_meta = {}, fallback, metadata = {}) {
  const theme = {
    ...fallback.theme,
    ..._meta.theme,
    ...metadata.theme
  };
  return {
    ...fallback,
    ..._meta,
    display: metadata.display || _meta.display || fallback.display,
    theme
  };
}
function findFirstRoute(items) {
  for (const item of items) {
    if (item.route) return item.route;
    if (item.children) {
      const route = findFirstRoute(item.children);
      if (route) return route;
    }
  }
}
function normalizePages({
  list,
  route,
  /** @default '' */
  docsRoot = "",
  /** @default DEFAULT_PAGE_THEME */
  pageThemeContext = DEFAULT_PAGE_THEME
}) {
  const underCurrentDocsRoot = route.startsWith(docsRoot);
  const directories = [];
  const docsDirectories = [];
  const flatDocsDirectories = [];
  const topLevelNavbarItems = [];
  const firstItem = list[0];
  const meta = "data" in firstItem ? firstItem.data : {};
  const items = "data" in firstItem ? list.slice(1) : list;
  const fallbackMeta = meta["*"] || {};
  let activeType = fallbackMeta.type;
  let activeIndex = 0;
  let activeThemeContext = {
    ...pageThemeContext,
    ...fallbackMeta.theme
  };
  let activePath = [];
  for (const currentItem of items) {
    const extendedMeta = extendMeta(meta[currentItem.name], fallbackMeta, currentItem.frontMatter);
    const {
      display,
      type = "doc"
    } = extendedMeta;
    const extendedPageThemeContext = {
      ...pageThemeContext,
      ...extendedMeta.theme
    };
    const normalizedChildren = "children" in currentItem && normalizePages({
      list: currentItem.children,
      route,
      docsRoot: type === "page" || type === "menu" ? currentItem.route : docsRoot,
      underCurrentDocsRoot,
      pageThemeContext: extendedPageThemeContext
    });
    const getItem = () => ({
      ...currentItem,
      type,
      ..."title" in currentItem && {
        title: currentItem.title
      },
      ...display && {
        display
      },
      ...normalizedChildren && {
        children: []
      }
    });
    const item = getItem();
    const docsItem = getItem();
    if ("children" in docsItem) {
      const {
        collapsed
      } = extendedMeta.theme;
      if (typeof collapsed === "boolean") {
        docsItem.theme = {
          collapsed
        };
      }
    }
    const pageItem = getItem();
    docsItem.isUnderCurrentDocsTree = underCurrentDocsRoot;
    if (type === "separator") {
      item.isUnderCurrentDocsTree = underCurrentDocsRoot;
    }
    if (currentItem.route === route) {
      activePath = [item];
      activeType = type;
      activeThemeContext = {
        ...activeThemeContext,
        ...extendedPageThemeContext
      };
      switch (type) {
        case "page":
        case "menu":
          activeIndex = topLevelNavbarItems.length;
          break;
        case "doc":
          activeIndex = flatDocsDirectories.length;
      }
    }
    const isHidden = display === "hidden";
    if (normalizedChildren) {
      if (
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- fixme
        normalizedChildren.activeIndex !== void 0 && normalizedChildren.activeType !== void 0
      ) {
        activeThemeContext = normalizedChildren.activeThemeContext;
        activeType = normalizedChildren.activeType;
        if (isHidden) {
          continue;
        }
        activePath = [
          item,
          // Do not include folder which shows only his children
          ...normalizedChildren.activePath.filter((item2) => item2.display !== "children")
        ];
        switch (activeType) {
          case "page":
          case "menu":
            activeIndex = topLevelNavbarItems.length + normalizedChildren.activeIndex;
            break;
          case "doc":
            activeIndex = flatDocsDirectories.length + normalizedChildren.activeIndex;
            break;
        }
        if ("frontMatter" in currentItem && type === "doc") {
          activeIndex++;
        }
      }
      switch (type) {
        case "page":
        case "menu":
          pageItem.children.push(...normalizedChildren.directories);
          docsDirectories.push(...normalizedChildren.docsDirectories);
          if (normalizedChildren.flatDocsDirectories.length) {
            const route2 = findFirstRoute(normalizedChildren.flatDocsDirectories);
            if (route2) pageItem.firstChildRoute = route2;
            topLevelNavbarItems.push(pageItem);
          } else if ("frontMatter" in pageItem) {
            topLevelNavbarItems.push(pageItem);
          }
          break;
        case "doc":
          docsItem.children.push(...normalizedChildren.docsDirectories);
          if ("frontMatter" in item && display !== "children") {
            flatDocsDirectories.push(docsItem);
          }
      }
      flatDocsDirectories.push(...normalizedChildren.flatDocsDirectories);
      item.children.push(...normalizedChildren.directories);
    } else {
      if (isHidden) {
        continue;
      }
      switch (type) {
        case "page":
        case "menu":
          topLevelNavbarItems.push(pageItem);
          break;
        case "doc": {
          const withHrefProp = "href" in item;
          if (!withHrefProp) {
            flatDocsDirectories.push(docsItem);
          }
        }
      }
    }
    if (isHidden) {
      continue;
    }
    if (type === "doc" && display === "children") {
      if (docsItem.children) {
        directories.push(...docsItem.children);
        docsDirectories.push(...docsItem.children);
      }
    } else {
      directories.push(item);
    }
    switch (type) {
      case "page":
      case "menu":
        docsDirectories.push(pageItem);
        break;
      case "doc":
        if (display !== "children") {
          docsDirectories.push(docsItem);
        }
        break;
      case "separator":
        docsDirectories.push(item);
    }
  }
  const activeMetadata = activePath.at(-1)?.frontMatter;
  const result = {
    activeType,
    activeIndex,
    activeThemeContext,
    activeMetadata,
    activePath,
    directories,
    docsDirectories: docsDirectories.filter((item) => item.isUnderCurrentDocsTree),
    flatDocsDirectories,
    topLevelNavbarItems
  };
  return result;
}


// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
;// CONCATENATED MODULE: ../../node_modules/nextra-theme-docs/dist/stores/config.js
/* __next_internal_client_entry_do_not_use__ ConfigProvider,useConfig auto */ 




const ConfigContext = /*#__PURE__*/ (0,react.createContext)(null);
function useConfig() {
    const $ = (0,dist.c)(3);
    const normalizePagesResult = (0,react.useContext)(ConfigContext);
    if (!normalizePagesResult) {
        throw new Error("Missing ConfigContext.Provider");
    }
    const { activeThemeContext, activeType } = normalizePagesResult;
    const t0 = !activeThemeContext.sidebar || activeType === "page";
    let t1;
    if ($[0] !== normalizePagesResult || $[1] !== t0) {
        t1 = {
            normalizePagesResult,
            hideSidebar: t0
        };
        $[0] = normalizePagesResult;
        $[1] = t0;
        $[2] = t1;
    } else {
        t1 = $[2];
    }
    return t1;
}
const ConfigProvider = (t0)=>{
    const $ = (0,dist.c)(8);
    const { children, pageMap, navbar, footer } = t0;
    const pathname = (0,use_fs_route.useFSRoute)();
    let t1;
    if ($[0] !== pageMap || $[1] !== pathname) {
        t1 = normalizePages({
            list: pageMap,
            route: pathname
        });
        $[0] = pageMap;
        $[1] = pathname;
        $[2] = t1;
    } else {
        t1 = $[2];
    }
    const normalizedPages = t1;
    const { activeThemeContext } = normalizedPages;
    const t2 = activeThemeContext.navbar && navbar;
    const t3 = activeThemeContext.footer && footer;
    let t4;
    if ($[3] !== children || $[4] !== normalizedPages || $[5] !== t2 || $[6] !== t3) {
        t4 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(ConfigContext.Provider, {
            value: normalizedPages,
            children: [
                t2,
                children,
                t3
            ]
        });
        $[3] = children;
        $[4] = normalizedPages;
        $[5] = t2;
        $[6] = t3;
        $[7] = t4;
    } else {
        t4 = $[7];
    }
    return t4;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/menu.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: function() { return /* binding */ useMenu; },
/* harmony export */   K: function() { return /* binding */ setMenu; }
/* harmony export */ });
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/zustand/esm/react.mjs");
"use no memo";

const useMenuStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__/* .create */ .U)(()=>({
        hasMenu: false
    }));
const useMenu = ()=>useMenuStore((state)=>state.hasMenu);
const setMenu = (fn)=>{
    useMenuStore.setState((state)=>{
        const hasMenu = typeof fn === "function" ? fn(state.hasMenu) : fn;
        document.documentElement.classList.toggle("x:max-md:overflow-hidden", hasMenu);
        return {
            hasMenu
        };
    });
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/theme-config.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ThemeConfigProvider: function() { return /* binding */ ThemeConfigProvider; },
/* harmony export */   useThemeConfig: function() { return /* binding */ useThemeConfig; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* __next_internal_client_entry_do_not_use__ ThemeConfigProvider,useThemeConfig auto */ 
const ThemeConfigContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
const useThemeConfig = ()=>{
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeConfigContext);
};
const ThemeConfigProvider = (props)=>/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ThemeConfigContext.Provider, props);



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/stores/toc.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TOCProvider: function() { return /* binding */ TOCProvider; },
/* harmony export */   useTOC: function() { return /* binding */ useTOC; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* __next_internal_client_entry_do_not_use__ TOCProvider,useTOC auto */ "use no memo";

const TOCContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)([]);
const useTOC = ()=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TOCContext);
const TOCProvider = (props)=>/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(TOCContext.Provider, props);



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/utils/get-git-issue-url.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: function() { return /* binding */ getGitIssueUrl; }
/* harmony export */ });
/* harmony import */ var _git_url_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/utils/git-url-parse.js");
"use no memo";

function getGitIssueUrl(param) {
    let { repository = "", title, labels } = param;
    const repo = (0,_git_url_parse__WEBPACK_IMPORTED_MODULE_0__/* .gitUrlParse */ .Y)(repository);
    if (repo.origin.includes("gitlab")) {
        return "".concat(repo.origin, "/").concat(repo.owner, "/").concat(repo.name, "/-/issues/new?issue[title]=").concat(encodeURIComponent(title)).concat(labels ? "&issue[description]=/label".concat(encodeURIComponent(" ~".concat(labels, "\n"))) : "");
    }
    if (repo.origin.includes("github")) {
        return "".concat(repo.origin, "/").concat(repo.owner, "/").concat(repo.name, "/issues/new?title=").concat(encodeURIComponent(title), "&labels=").concat(labels || "");
    }
    return "#";
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/utils/git-url-parse.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: function() { return /* binding */ gitUrlParse; }
/* harmony export */ });
"use no memo";
function gitUrlParse(url) {
    const { href, origin, pathname } = new URL(url);
    const [, owner, name] = pathname.split("/", 3);
    return {
        href,
        origin,
        owner,
        name
    };
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/components/button.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Button: function() { return /* binding */ Button; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/button/button.js
var button_button = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/button/button.js");
// EXTERNAL MODULE: ../../node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/mdx-components/pre/index.js






const classes = {
  border: (0,clsx/* default */.Z)("x:border x:border-gray-300 x:dark:border-neutral-700", "x:contrast-more:border-gray-900 x:contrast-more:dark:border-gray-50")
};
const Pre = (t0) => {
  const $ = _c(36);
  let children;
  let className;
  let copy;
  let filename;
  let hasWordWrap;
  let icon;
  let pagefindIgnore;
  let props;
  if ($[0] !== t0) {
    const {
      children: t12,
      className: t22,
      "data-filename": t32,
      "data-copy": t42,
      "data-language": _language,
      "data-word-wrap": t52,
      "data-pagefind-ignore": t62,
      icon: t72,
      ...t82
    } = t0;
    children = t12;
    className = t22;
    filename = t32;
    copy = t42;
    hasWordWrap = t52;
    pagefindIgnore = t62;
    icon = t72;
    props = t82;
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = copy;
    $[4] = filename;
    $[5] = hasWordWrap;
    $[6] = icon;
    $[7] = pagefindIgnore;
    $[8] = props;
  } else {
    children = $[1];
    className = $[2];
    copy = $[3];
    filename = $[4];
    hasWordWrap = $[5];
    icon = $[6];
    pagefindIgnore = $[7];
    props = $[8];
  }
  let t1;
  if ($[9] !== copy || $[10] !== filename) {
    t1 = copy === "" && /* @__PURE__ */ jsx(CopyToClipboard, { className: filename ? "x:ms-auto x:text-sm" : "" });
    $[9] = copy;
    $[10] = filename;
    $[11] = t1;
  } else {
    t1 = $[11];
  }
  const copyButton = t1;
  let t2;
  if ($[12] !== copyButton || $[13] !== filename || $[14] !== icon) {
    t2 = filename && /* @__PURE__ */ jsxs("div", { className: cn("x:px-4 x:text-xs x:text-gray-700 x:dark:text-gray-200", "x:bg-gray-100 x:dark:bg-neutral-900", "x:flex x:items-center x:h-12 x:gap-2 x:rounded-t-md", classes.border, "x:border-b-0"), children: [
      icon,
      /* @__PURE__ */ jsx("span", { className: "x:truncate", children: filename }),
      copyButton
    ] });
    $[12] = copyButton;
    $[13] = filename;
    $[14] = icon;
    $[15] = t2;
  } else {
    t2 = $[15];
  }
  const t3 = filename ? "x:rounded-b-md" : "x:rounded-md";
  let t4;
  if ($[16] !== className || $[17] !== t3) {
    t4 = cn("x:group", "x:focus-visible:nextra-focus", "x:overflow-x-auto x:subpixel-antialiased x:text-[.9em]", "x:bg-white x:dark:bg-black x:py-4", "x:ring-1 x:ring-inset x:ring-gray-300 x:dark:ring-neutral-700", "x:contrast-more:ring-gray-900 x:contrast-more:dark:ring-gray-50", "x:contrast-more:contrast-150", t3, "not-prose", className);
    $[16] = className;
    $[17] = t3;
    $[18] = t4;
  } else {
    t4 = $[18];
  }
  const t5 = filename ? "x:top-14" : "x:top-2";
  let t6;
  if ($[19] !== t5) {
    t6 = cn("x:group-hover:opacity-100", "x:group-focus:opacity-100", "x:opacity-0 x:transition x:focus-within:opacity-100", "x:flex x:gap-1 x:absolute x:right-4", t5);
    $[19] = t5;
    $[20] = t6;
  } else {
    t6 = $[20];
  }
  let t7;
  if ($[21] !== hasWordWrap) {
    t7 = hasWordWrap === "" && /* @__PURE__ */ jsx(ToggleWordWrapButton, { children: /* @__PURE__ */ jsx(WordWrapIcon, { height: "1em" }) });
    $[21] = hasWordWrap;
    $[22] = t7;
  } else {
    t7 = $[22];
  }
  const t8 = !filename && copyButton;
  let t9;
  if ($[23] !== t6 || $[24] !== t7 || $[25] !== t8) {
    t9 = /* @__PURE__ */ jsxs("div", { className: t6, children: [
      t7,
      t8
    ] });
    $[23] = t6;
    $[24] = t7;
    $[25] = t8;
    $[26] = t9;
  } else {
    t9 = $[26];
  }
  let t10;
  if ($[27] !== children || $[28] !== props || $[29] !== t4 || $[30] !== t9) {
    t10 = /* @__PURE__ */ jsxs("pre", { className: t4, ...props, children: [
      t9,
      children
    ] });
    $[27] = children;
    $[28] = props;
    $[29] = t4;
    $[30] = t9;
    $[31] = t10;
  } else {
    t10 = $[31];
  }
  let t11;
  if ($[32] !== pagefindIgnore || $[33] !== t10 || $[34] !== t2) {
    t11 = /* @__PURE__ */ jsxs("div", { "data-pagefind-ignore": pagefindIgnore, className: "nextra-code x:relative x:not-first:mt-[1.25em]", children: [
      t2,
      t10
    ] });
    $[32] = pagefindIgnore;
    $[33] = t10;
    $[34] = t2;
    $[35] = t11;
  } else {
    t11 = $[35];
  }
  return t11;
};


;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/components/button.js
/* __next_internal_client_entry_do_not_use__ Button auto */ 




const Button = (t0)=>{
    const $ = (0,dist.c)(12);
    let children;
    let className;
    let props;
    let t1;
    if ($[0] !== t0) {
        ({ children, className, variant: t1, ...props } = t0);
        $[0] = t0;
        $[1] = children;
        $[2] = className;
        $[3] = props;
        $[4] = t1;
    } else {
        children = $[1];
        className = $[2];
        props = $[3];
        t1 = $[4];
    }
    const variant = t1 === void 0 ? "default" : t1;
    let t2;
    if ($[5] !== className || $[6] !== variant) {
        t2 = (args)=>(0,clsx/* default */.Z)("x:transition x:cursor-pointer", args.focus && "x:nextra-focus", variant === "outline" && [
                classes.border,
                "x:rounded-md x:p-1.5"
            ], typeof className === "function" ? className(args) : className);
        $[5] = className;
        $[6] = variant;
        $[7] = t2;
    } else {
        t2 = $[7];
    }
    let t3;
    if ($[8] !== children || $[9] !== props || $[10] !== t2) {
        t3 = /* @__PURE__ */ (0,jsx_runtime.jsx)(button_button/* Button */.z, {
            className: t2,
            ...props,
            children
        });
        $[8] = children;
        $[9] = props;
        $[10] = t2;
        $[11] = t3;
    } else {
        t3 = $[11];
    }
    return t3;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/components/collapse.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: function() { return /* binding */ Collapse; }
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* __next_internal_client_entry_do_not_use__ Collapse auto */ 



const Collapse = (t0)=>{
    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(24);
    const { className, children, isOpen, horizontal: t1, openDuration: t2, closeDuration: t3 } = t0;
    const horizontal = t1 === void 0 ? false : t1;
    const openDuration = t2 === void 0 ? 500 : t2;
    const closeDuration = t3 === void 0 ? 300 : t3;
    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);
    const [initialOpen] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(isOpen);
    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(0);
    const initialRender = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(true);
    let t4;
    let t5;
    if ($[0] !== horizontal || $[1] !== isOpen || $[2] !== openDuration) {
        t4 = ()=>{
            const animation = animationRef.current;
            const container = containerRef.current;
            if (animation) {
                clearTimeout(animation);
                animationRef.current = 0;
            }
            if (initialRender.current) {
                return;
            }
            const child = container.children[0];
            if (horizontal) {
                child.style.width = "".concat(child.clientWidth, "px");
                container.style.width = "".concat(child.clientWidth, "px");
            } else {
                container.style.height = "".concat(child.clientHeight, "px");
            }
            if (isOpen) {
                animationRef.current = window.setTimeout(()=>{
                    container.style.removeProperty("height");
                }, openDuration);
            } else {
                requestAnimationFrame(()=>{
                    if (horizontal) {
                        container.style.width = "0";
                    } else {
                        container.style.height = "0";
                    }
                });
            }
        };
        t5 = [
            horizontal,
            isOpen,
            openDuration
        ];
        $[0] = horizontal;
        $[1] = isOpen;
        $[2] = openDuration;
        $[3] = t4;
        $[4] = t5;
    } else {
        t4 = $[3];
        t5 = $[4];
    }
    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t4, t5);
    let t6;
    let t7;
    if ($[5] !== horizontal || $[6] !== isOpen) {
        t6 = ()=>{
            if (isOpen || !horizontal) {
                initialRender.current = false;
            }
        };
        t7 = [
            horizontal,
            isOpen
        ];
        $[5] = horizontal;
        $[6] = isOpen;
        $[7] = t6;
        $[8] = t7;
    } else {
        t6 = $[7];
        t7 = $[8];
    }
    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t6, t7);
    let t8;
    if ($[9] !== children) {
        t8 = react__WEBPACK_IMPORTED_MODULE_2__.Children.count(children) === 1 && children && typeof children === "object" && "type" in children ? children : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
            children
        });
        $[9] = children;
        $[10] = t8;
    } else {
        t8 = $[10];
    }
    const newChildren = t8;
    const t9 = isOpen ? "x:opacity-100" : "x:opacity-0 x:overflow-hidden";
    let t10;
    if ($[11] !== className || $[12] !== t9) {
        t10 = (0,clsx__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)("x:transform-gpu x:transition-all x:ease-in-out x:motion-reduce:transition-none", t9, className);
        $[11] = className;
        $[12] = t9;
        $[13] = t10;
    } else {
        t10 = $[13];
    }
    let t11;
    if ($[14] !== horizontal || $[15] !== initialOpen) {
        t11 = initialOpen || horizontal ? void 0 : {
            height: 0
        };
        $[14] = horizontal;
        $[15] = initialOpen;
        $[16] = t11;
    } else {
        t11 = $[16];
    }
    const t12 = (isOpen ? openDuration : closeDuration) + "ms";
    let t13;
    if ($[17] !== t11 || $[18] !== t12) {
        t13 = {
            ...t11,
            transitionDuration: t12
        };
        $[17] = t11;
        $[18] = t12;
        $[19] = t13;
    } else {
        t13 = $[19];
    }
    let t14;
    if ($[20] !== newChildren || $[21] !== t10 || $[22] !== t13) {
        t14 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
            ref: containerRef,
            className: t10,
            style: t13,
            children: newChildren
        });
        $[20] = newChildren;
        $[21] = t10;
        $[22] = t13;
        $[23] = t14;
    } else {
        t14 = $[23];
    }
    return t14;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/components/image-zoom.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ImageZoom: function() { return /* binding */ ImageZoom; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/index.js
var react_dom = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js");
;// CONCATENATED MODULE: ../../node_modules/react-medium-image-zoom/dist/index.js
/* __next_internal_client_entry_do_not_use__ Controlled,default auto */ 

function ICompress() {
    return /*#__PURE__*/ react.createElement("svg", {
        "aria-hidden": "true",
        "data-rmiz-btn-unzoom-icon": true,
        fill: "currentColor",
        focusable: "false",
        viewBox: "0 0 16 16",
        xmlns: "http://www.w3.org/2000/svg"
    }, /*#__PURE__*/ react.createElement("path", {
        d: "M 14.144531 1.148438 L 9 6.292969 L 9 3 L 8 3 L 8 8 L 13 8 L 13 7 L 9.707031 7 L 14.855469 1.851563 Z M 8 8 L 3 8 L 3 9 L 6.292969 9 L 1.148438 14.144531 L 1.851563 14.855469 L 7 9.707031 L 7 13 L 8 13 Z"
    }));
}
function IEnlarge() {
    return /*#__PURE__*/ react.createElement("svg", {
        "aria-hidden": "true",
        "data-rmiz-btn-zoom-icon": true,
        fill: "currentColor",
        focusable: "false",
        viewBox: "0 0 16 16",
        xmlns: "http://www.w3.org/2000/svg"
    }, /*#__PURE__*/ react.createElement("path", {
        d: "M 9 1 L 9 2 L 12.292969 2 L 2 12.292969 L 2 9 L 1 9 L 1 14 L 6 14 L 6 13 L 2.707031 13 L 13 2.707031 L 13 6 L 14 6 L 14 1 Z"
    }));
}
const testElType = (type, el)=>{
    var _el_tagName_toUpperCase, _el_tagName;
    return type === (el === null || el === void 0 ? void 0 : (_el_tagName = el.tagName) === null || _el_tagName === void 0 ? void 0 : (_el_tagName_toUpperCase = _el_tagName.toUpperCase) === null || _el_tagName_toUpperCase === void 0 ? void 0 : _el_tagName_toUpperCase.call(_el_tagName));
};
const testDiv = (el)=>testElType("DIV", el) || testElType("SPAN", el);
const testImg = (el)=>testElType("IMG", el);
const testImgLoaded = (el)=>el.complete && el.naturalHeight !== 0;
const testSvg = (el)=>testElType("SVG", el);
const getScaleToWindow = (param)=>{
    let { height, offset, width } = param;
    return Math.min((window.innerWidth - offset * 2) / width, (window.innerHeight - offset * 2) / height);
};
const getScaleToWindowMax = (param)=>{
    let { containerHeight, containerWidth, offset, targetHeight, targetWidth } = param;
    const scale = getScaleToWindow({
        height: targetHeight,
        offset,
        width: targetWidth
    });
    const ratio = targetWidth > targetHeight ? targetWidth / containerWidth : targetHeight / containerHeight;
    return scale > 1 ? ratio : scale * ratio;
};
const getScale = (param)=>{
    let { containerHeight, containerWidth, hasScalableSrc, offset, targetHeight, targetWidth } = param;
    if (!containerHeight || !containerWidth) {
        return 1;
    }
    return !hasScalableSrc && targetHeight && targetWidth ? getScaleToWindowMax({
        containerHeight,
        containerWidth,
        offset,
        targetHeight,
        targetWidth
    }) : getScaleToWindow({
        height: containerHeight,
        offset,
        width: containerWidth
    });
};
const URL_REGEX = /url(?:\(['"]?)(.*?)(?:['"]?\))/;
const getImgSrc = (imgEl)=>{
    if (imgEl) {
        if (testImg(imgEl)) {
            return imgEl.currentSrc;
        } else if (testDiv(imgEl)) {
            const bgImg = window.getComputedStyle(imgEl).backgroundImage;
            if (bgImg) {
                var _URL_REGEX_exec;
                return (_URL_REGEX_exec = URL_REGEX.exec(bgImg)) === null || _URL_REGEX_exec === void 0 ? void 0 : _URL_REGEX_exec[1];
            }
        }
    }
};
const getImgAlt = (imgEl)=>{
    if (imgEl) {
        if (testImg(imgEl)) {
            var _imgEl_alt;
            return (_imgEl_alt = imgEl.alt) !== null && _imgEl_alt !== void 0 ? _imgEl_alt : undefined;
        } else {
            var _imgEl_getAttribute;
            return (_imgEl_getAttribute = imgEl.getAttribute("aria-label")) !== null && _imgEl_getAttribute !== void 0 ? _imgEl_getAttribute : undefined;
        }
    }
};
const getImgRegularStyle = (param)=>{
    let { containerHeight, containerLeft, containerTop, containerWidth, hasScalableSrc, offset, targetHeight, targetWidth } = param;
    const scale = getScale({
        containerHeight,
        containerWidth,
        hasScalableSrc,
        offset,
        targetHeight,
        targetWidth
    });
    return {
        top: containerTop,
        left: containerLeft,
        width: containerWidth * scale,
        height: containerHeight * scale,
        transform: "translate(0,0) scale(".concat(1 / scale, ")")
    };
};
const parsePosition = (param)=>{
    let { position, relativeNum } = param;
    const positionNum = parseFloat(position);
    return position.endsWith("%") ? relativeNum * positionNum / 100 : positionNum;
};
const getImgObjectFitStyle = (param)=>{
    let { containerHeight, containerLeft, containerTop, containerWidth, hasScalableSrc, objectFit, objectPosition, offset, targetHeight, targetWidth } = param;
    if (objectFit === "scale-down") {
        if (targetWidth <= containerWidth && targetHeight <= containerHeight) {
            objectFit = "none";
        } else {
            objectFit = "contain";
        }
    }
    if (objectFit === "cover" || objectFit === "contain") {
        const widthRatio = containerWidth / targetWidth;
        const heightRatio = containerHeight / targetHeight;
        const ratio = objectFit === "cover" ? Math.max(widthRatio, heightRatio) : Math.min(widthRatio, heightRatio);
        const [posLeft = "50%", posTop = "50%"] = objectPosition.split(" ");
        const posX = parsePosition({
            position: posLeft,
            relativeNum: containerWidth - targetWidth * ratio
        });
        const posY = parsePosition({
            position: posTop,
            relativeNum: containerHeight - targetHeight * ratio
        });
        const scale = getScale({
            containerHeight: targetHeight * ratio,
            containerWidth: targetWidth * ratio,
            hasScalableSrc,
            offset,
            targetHeight,
            targetWidth
        });
        return {
            top: containerTop + posY,
            left: containerLeft + posX,
            width: targetWidth * ratio * scale,
            height: targetHeight * ratio * scale,
            transform: "translate(0,0) scale(".concat(1 / scale, ")")
        };
    } else if (objectFit === "none") {
        const [posLeft = "50%", posTop = "50%"] = objectPosition.split(" ");
        const posX = parsePosition({
            position: posLeft,
            relativeNum: containerWidth - targetWidth
        });
        const posY = parsePosition({
            position: posTop,
            relativeNum: containerHeight - targetHeight
        });
        const scale = getScale({
            containerHeight: targetHeight,
            containerWidth: targetWidth,
            hasScalableSrc,
            offset,
            targetHeight,
            targetWidth
        });
        return {
            top: containerTop + posY,
            left: containerLeft + posX,
            width: targetWidth * scale,
            height: targetHeight * scale,
            transform: "translate(0,0) scale(".concat(1 / scale, ")")
        };
    } else if (objectFit === "fill") {
        const widthRatio = containerWidth / targetWidth;
        const heightRatio = containerHeight / targetHeight;
        const ratio = Math.max(widthRatio, heightRatio);
        const scale = getScale({
            containerHeight: targetHeight * ratio,
            containerWidth: targetWidth * ratio,
            hasScalableSrc,
            offset,
            targetHeight,
            targetWidth
        });
        return {
            width: containerWidth * scale,
            height: containerHeight * scale,
            transform: "translate(0,0) scale(".concat(1 / scale, ")")
        };
    } else {
        return {};
    }
};
const getDivImgStyle = (param)=>{
    let { backgroundPosition, backgroundSize, containerHeight, containerLeft, containerTop, containerWidth, hasScalableSrc, offset, targetHeight, targetWidth } = param;
    if (backgroundSize === "cover" || backgroundSize === "contain") {
        const widthRatio = containerWidth / targetWidth;
        const heightRatio = containerHeight / targetHeight;
        const ratio = backgroundSize === "cover" ? Math.max(widthRatio, heightRatio) : Math.min(widthRatio, heightRatio);
        const [posLeft = "50%", posTop = "50%"] = backgroundPosition.split(" ");
        const posX = parsePosition({
            position: posLeft,
            relativeNum: containerWidth - targetWidth * ratio
        });
        const posY = parsePosition({
            position: posTop,
            relativeNum: containerHeight - targetHeight * ratio
        });
        const scale = getScale({
            containerHeight: targetHeight * ratio,
            containerWidth: targetWidth * ratio,
            hasScalableSrc,
            offset,
            targetHeight,
            targetWidth
        });
        return {
            top: containerTop + posY,
            left: containerLeft + posX,
            width: targetWidth * ratio * scale,
            height: targetHeight * ratio * scale,
            transform: "translate(0,0) scale(".concat(1 / scale, ")")
        };
    } else if (backgroundSize === "auto") {
        const [posLeft = "50%", posTop = "50%"] = backgroundPosition.split(" ");
        const posX = parsePosition({
            position: posLeft,
            relativeNum: containerWidth - targetWidth
        });
        const posY = parsePosition({
            position: posTop,
            relativeNum: containerHeight - targetHeight
        });
        const scale = getScale({
            containerHeight: targetHeight,
            containerWidth: targetWidth,
            hasScalableSrc,
            offset,
            targetHeight,
            targetWidth
        });
        return {
            top: containerTop + posY,
            left: containerLeft + posX,
            width: targetWidth * scale,
            height: targetHeight * scale,
            transform: "translate(0,0) scale(".concat(1 / scale, ")")
        };
    } else {
        const [sizeW = "50%", sizeH = "50%"] = backgroundSize.split(" ");
        const sizeWidth = parsePosition({
            position: sizeW,
            relativeNum: containerWidth
        });
        const sizeHeight = parsePosition({
            position: sizeH,
            relativeNum: containerHeight
        });
        const widthRatio = sizeWidth / targetWidth;
        const heightRatio = sizeHeight / targetHeight;
        const ratio = Math.min(widthRatio, heightRatio);
        const [posLeft = "50%", posTop = "50%"] = backgroundPosition.split(" ");
        const posX = parsePosition({
            position: posLeft,
            relativeNum: containerWidth - targetWidth * ratio
        });
        const posY = parsePosition({
            position: posTop,
            relativeNum: containerHeight - targetHeight * ratio
        });
        const scale = getScale({
            containerHeight: targetHeight * ratio,
            containerWidth: targetWidth * ratio,
            hasScalableSrc,
            offset,
            targetHeight,
            targetWidth
        });
        return {
            top: containerTop + posY,
            left: containerLeft + posX,
            width: targetWidth * ratio * scale,
            height: targetHeight * ratio * scale,
            transform: "translate(0,0) scale(".concat(1 / scale, ")")
        };
    }
};
const SRC_SVG_REGEX = /\.svg$/i;
const getStyleModalImg = (param)=>{
    let { hasZoomImg, imgSrc, isSvg, isZoomed, loadedImgEl, offset, shouldRefresh, targetEl } = param;
    var _imgSrc_slice;
    const hasScalableSrc = isSvg || (imgSrc === null || imgSrc === void 0 ? void 0 : (_imgSrc_slice = imgSrc.slice) === null || _imgSrc_slice === void 0 ? void 0 : _imgSrc_slice.call(imgSrc, 0, 18)) === "data:image/svg+xml" || hasZoomImg || !!(imgSrc && SRC_SVG_REGEX.test(imgSrc));
    const imgRect = targetEl.getBoundingClientRect();
    const targetElComputedStyle = window.getComputedStyle(targetEl);
    const isDivImg = loadedImgEl != null && testDiv(targetEl);
    const isImgObjectFit = loadedImgEl != null && !isDivImg;
    const styleImgRegular = getImgRegularStyle({
        containerHeight: imgRect.height,
        containerLeft: imgRect.left,
        containerTop: imgRect.top,
        containerWidth: imgRect.width,
        hasScalableSrc,
        offset,
        targetHeight: (loadedImgEl === null || loadedImgEl === void 0 ? void 0 : loadedImgEl.naturalHeight) || imgRect.height,
        targetWidth: (loadedImgEl === null || loadedImgEl === void 0 ? void 0 : loadedImgEl.naturalWidth) || imgRect.width
    });
    const styleImgObjectFit = isImgObjectFit ? getImgObjectFitStyle({
        containerHeight: imgRect.height,
        containerLeft: imgRect.left,
        containerTop: imgRect.top,
        containerWidth: imgRect.width,
        hasScalableSrc,
        objectFit: targetElComputedStyle.objectFit,
        objectPosition: targetElComputedStyle.objectPosition,
        offset,
        targetHeight: (loadedImgEl === null || loadedImgEl === void 0 ? void 0 : loadedImgEl.naturalHeight) || imgRect.height,
        targetWidth: (loadedImgEl === null || loadedImgEl === void 0 ? void 0 : loadedImgEl.naturalWidth) || imgRect.width
    }) : undefined;
    const styleDivImg = isDivImg ? getDivImgStyle({
        backgroundPosition: targetElComputedStyle.backgroundPosition,
        backgroundSize: targetElComputedStyle.backgroundSize,
        containerHeight: imgRect.height,
        containerLeft: imgRect.left,
        containerTop: imgRect.top,
        containerWidth: imgRect.width,
        hasScalableSrc,
        offset,
        targetHeight: (loadedImgEl === null || loadedImgEl === void 0 ? void 0 : loadedImgEl.naturalHeight) || imgRect.height,
        targetWidth: (loadedImgEl === null || loadedImgEl === void 0 ? void 0 : loadedImgEl.naturalWidth) || imgRect.width
    }) : undefined;
    const style = Object.assign({}, styleImgRegular, styleImgObjectFit, styleDivImg);
    if (isZoomed) {
        const viewportX = window.innerWidth / 2;
        const viewportY = window.innerHeight / 2;
        const childCenterX = parseFloat(String(style.left || 0)) + parseFloat(String(style.width || 0)) / 2;
        const childCenterY = parseFloat(String(style.top || 0)) + parseFloat(String(style.height || 0)) / 2;
        const translateX = viewportX - childCenterX;
        const translateY = viewportY - childCenterY;
        if (shouldRefresh) {
            style.transitionDuration = "0.01ms";
        }
        style.transform = "translate(".concat(translateX, "px,").concat(translateY, "px) scale(1)");
    }
    return style;
};
const getStyleGhost = (imgEl)=>{
    if (!imgEl) {
        return {};
    }
    if (testSvg(imgEl)) {
        const parentEl = imgEl.parentElement;
        const rect = imgEl.getBoundingClientRect();
        if (parentEl) {
            const parentRect = parentEl.getBoundingClientRect();
            return {
                height: rect.height,
                left: parentRect.left - rect.left,
                top: parentRect.top - rect.top,
                width: rect.width
            };
        } else {
            return {
                height: rect.height,
                left: rect.left,
                width: rect.width,
                top: rect.top
            };
        }
    } else {
        return {
            height: imgEl.offsetHeight,
            left: imgEl.offsetLeft,
            width: imgEl.offsetWidth,
            top: imgEl.offsetTop
        };
    }
};
const adjustSvgIDs = (svgEl)=>{
    const newIdSuffix = "-zoom";
    const attrs = [
        "clip-path",
        "fill",
        "mask",
        "marker-start",
        "marker-mid",
        "marker-end"
    ];
    const idMap = new Map();
    if (svgEl.hasAttribute("id")) {
        const oldId = svgEl.id;
        const newId = oldId + newIdSuffix;
        idMap.set(oldId, newId);
        svgEl.id = newId;
    }
    svgEl.querySelectorAll("[id]").forEach((el)=>{
        const oldId = el.id;
        const newId = oldId + newIdSuffix;
        idMap.set(oldId, newId);
        el.id = newId;
    });
    idMap.forEach((newId, oldId)=>{
        const urlOldID = "url(#".concat(oldId, ")");
        const urlNewID = "url(#".concat(newId, ")");
        const attrsQuery = attrs.map((attr)=>"[".concat(attr, '="').concat(urlOldID, '"]')).join(", ");
        svgEl.querySelectorAll(attrsQuery).forEach((usedEl)=>{
            attrs.forEach((attr)=>{
                if (usedEl.getAttribute(attr) === urlOldID) {
                    usedEl.setAttribute(attr, urlNewID);
                }
            });
        });
    });
    svgEl.querySelectorAll("style").forEach((styleEl)=>{
        idMap.forEach((newId, oldId)=>{
            if (styleEl.textContent) {
                styleEl.textContent = styleEl.textContent.replaceAll("#".concat(oldId), "#".concat(newId));
            }
        });
    });
};
const IMAGE_QUERY = [
    "img",
    "svg",
    '[role="img"]',
    "[data-zoom]"
].map((x)=>"".concat(x, ':not([aria-hidden="true"])')).join(",");
const defaultBodyAttrs = {
    overflow: "",
    width: ""
};
function Controlled(props) {
    return /*#__PURE__*/ react.createElement(ControlledBase, {
        ...props
    });
}
class ControlledBase extends react.Component {
    render() {
        const { handleBtnUnzoomClick, handleDialogCancel, handleDialogClick, handleDialogClose, handleUnzoom, handleZoom, imgEl, props: { a11yNameButtonUnzoom, a11yNameButtonZoom, children, classDialog, IconUnzoom, IconZoom, isZoomed, wrapElement: WrapElement, ZoomContent, zoomImg, zoomMargin }, refContent, refDialog, refModalContent, refModalImg, refWrap, state: { id, isZoomImgLoaded, loadedImgEl, modalState, shouldRefresh, styleGhost } } = this;
        const idModal = "rmiz-modal-".concat(id);
        const idModalImg = "rmiz-modal-img-".concat(id);
        const isDiv = testDiv(imgEl);
        const isImg = testImg(imgEl);
        const isSvg = testSvg(imgEl);
        const imgAlt = getImgAlt(imgEl);
        const imgSrc = getImgSrc(imgEl);
        const imgSizes = isImg ? imgEl.sizes : undefined;
        const imgSrcSet = isImg ? imgEl.srcset : undefined;
        const imgCrossOrigin = isImg ? imgEl.crossOrigin : undefined;
        const hasZoomImg = !!(zoomImg === null || zoomImg === void 0 ? void 0 : zoomImg.src);
        const hasImage = this.hasImage();
        const labelBtnZoom = imgAlt ? "".concat(a11yNameButtonZoom, ": ").concat(imgAlt) : a11yNameButtonZoom;
        const isModalActive = modalState === "LOADING" || modalState === "LOADED";
        const dataContentState = hasImage ? "found" : "not-found";
        const dataOverlayState = modalState === "UNLOADED" || modalState === "UNLOADING" ? "hidden" : "visible";
        const styleContent = {
            visibility: modalState === "UNLOADED" ? "visible" : "hidden"
        };
        this.styleModalImg = hasImage ? getStyleModalImg({
            hasZoomImg,
            imgSrc,
            isSvg,
            isZoomed: isZoomed && isModalActive,
            loadedImgEl,
            offset: zoomMargin,
            shouldRefresh,
            targetEl: imgEl
        }) : {};
        let modalContent = null;
        if (hasImage) {
            const modalImg = isImg || isDiv ? /*#__PURE__*/ react.createElement("img", {
                alt: imgAlt,
                crossOrigin: imgCrossOrigin,
                sizes: imgSizes,
                src: imgSrc,
                srcSet: imgSrcSet,
                ...isZoomImgLoaded && modalState === "LOADED" ? zoomImg : {},
                "data-rmiz-modal-img": "",
                height: this.styleModalImg.height || undefined,
                id: idModalImg,
                ref: refModalImg,
                style: this.styleModalImg,
                width: this.styleModalImg.width || undefined
            }) : isSvg ? /*#__PURE__*/ react.createElement("div", {
                "data-rmiz-modal-img": true,
                ref: refModalImg,
                style: this.styleModalImg
            }) : null;
            const modalBtnUnzoom = /*#__PURE__*/ react.createElement("button", {
                "aria-label": a11yNameButtonUnzoom,
                "data-rmiz-btn-unzoom": "",
                onClick: handleBtnUnzoomClick,
                type: "button"
            }, /*#__PURE__*/ react.createElement(IconUnzoom, null));
            modalContent = ZoomContent ? /*#__PURE__*/ react.createElement(ZoomContent, {
                buttonUnzoom: modalBtnUnzoom,
                modalState: modalState,
                img: modalImg,
                isZoomImgLoaded: isZoomImgLoaded,
                onUnzoom: handleUnzoom
            }) : /*#__PURE__*/ react.createElement(react.Fragment, null, modalImg, modalBtnUnzoom);
        }
        return /*#__PURE__*/ react.createElement(WrapElement, {
            "aria-owns": idModal,
            "data-rmiz": "",
            ref: refWrap
        }, /*#__PURE__*/ react.createElement(WrapElement, {
            "data-rmiz-content": dataContentState,
            ref: refContent,
            style: styleContent
        }, children), hasImage && /*#__PURE__*/ react.createElement(WrapElement, {
            "data-rmiz-ghost": "",
            style: styleGhost
        }, /*#__PURE__*/ react.createElement("button", {
            "aria-label": labelBtnZoom,
            "data-rmiz-btn-zoom": "",
            onClick: handleZoom,
            type: "button"
        }, /*#__PURE__*/ react.createElement(IconZoom, null))), hasImage && /*#__PURE__*/ react_dom.createPortal(/*#__PURE__*/ react.createElement("dialog", {
            "aria-labelledby": idModalImg,
            "aria-modal": "true",
            className: classDialog,
            "data-rmiz-modal": "",
            id: idModal,
            onClick: handleDialogClick,
            onClose: handleDialogClose,
            onCancel: handleDialogCancel,
            ref: refDialog,
            role: "dialog"
        }, /*#__PURE__*/ react.createElement("div", {
            "data-rmiz-modal-overlay": dataOverlayState
        }), /*#__PURE__*/ react.createElement("div", {
            "data-rmiz-modal-content": "",
            ref: refModalContent
        }, modalContent)), this.getDialogContainer()));
    }
    componentDidMount() {
        this.setId();
        this.setAndTrackImg();
        this.handleImgLoad();
        this.UNSAFE_handleSvg();
    }
    componentWillUnmount() {
        var _this_contentChangeObserver_disconnect, _this_contentChangeObserver, _this_contentNotFoundChangeObserver_disconnect, _this_contentNotFoundChangeObserver, _this_imgElResizeObserver_disconnect, _this_imgElResizeObserver, _this_imgEl_removeEventListener, _this_imgEl, _this_imgEl_removeEventListener1, _this_imgEl1, _this_refModalImg_current_removeEventListener, _this_refModalImg_current;
        if (this.state.modalState !== "UNLOADED") {
            this.bodyScrollEnable();
        }
        (_this_contentChangeObserver = this.contentChangeObserver) === null || _this_contentChangeObserver === void 0 ? void 0 : (_this_contentChangeObserver_disconnect = _this_contentChangeObserver.disconnect) === null || _this_contentChangeObserver_disconnect === void 0 ? void 0 : _this_contentChangeObserver_disconnect.call(_this_contentChangeObserver);
        (_this_contentNotFoundChangeObserver = this.contentNotFoundChangeObserver) === null || _this_contentNotFoundChangeObserver === void 0 ? void 0 : (_this_contentNotFoundChangeObserver_disconnect = _this_contentNotFoundChangeObserver.disconnect) === null || _this_contentNotFoundChangeObserver_disconnect === void 0 ? void 0 : _this_contentNotFoundChangeObserver_disconnect.call(_this_contentNotFoundChangeObserver);
        (_this_imgElResizeObserver = this.imgElResizeObserver) === null || _this_imgElResizeObserver === void 0 ? void 0 : (_this_imgElResizeObserver_disconnect = _this_imgElResizeObserver.disconnect) === null || _this_imgElResizeObserver_disconnect === void 0 ? void 0 : _this_imgElResizeObserver_disconnect.call(_this_imgElResizeObserver);
        (_this_imgEl = this.imgEl) === null || _this_imgEl === void 0 ? void 0 : (_this_imgEl_removeEventListener = _this_imgEl.removeEventListener) === null || _this_imgEl_removeEventListener === void 0 ? void 0 : _this_imgEl_removeEventListener.call(_this_imgEl, "load", this.handleImgLoad);
        (_this_imgEl1 = this.imgEl) === null || _this_imgEl1 === void 0 ? void 0 : (_this_imgEl_removeEventListener1 = _this_imgEl1.removeEventListener) === null || _this_imgEl_removeEventListener1 === void 0 ? void 0 : _this_imgEl_removeEventListener1.call(_this_imgEl1, "click", this.handleZoom);
        (_this_refModalImg_current = this.refModalImg.current) === null || _this_refModalImg_current === void 0 ? void 0 : (_this_refModalImg_current_removeEventListener = _this_refModalImg_current.removeEventListener) === null || _this_refModalImg_current_removeEventListener === void 0 ? void 0 : _this_refModalImg_current_removeEventListener.call(_this_refModalImg_current, "transitionend", this.handleImgTransitionEnd);
        window.removeEventListener("wheel", this.handleWheel);
        window.removeEventListener("touchstart", this.handleTouchStart);
        window.removeEventListener("touchmove", this.handleTouchMove);
        window.removeEventListener("touchend", this.handleTouchEnd);
        window.removeEventListener("touchcancel", this.handleTouchCancel);
        window.removeEventListener("resize", this.handleResize);
        document.removeEventListener("keydown", this.handleKeyDown, true);
    }
    componentDidUpdate(prevProps, prevState) {
        this.handleModalStateChange(prevState.modalState);
        this.UNSAFE_handleSvg();
        this.handleIfZoomChanged(prevProps.isZoomed);
    }
    constructor(){
        super(...arguments);
        this.state = {
            id: "",
            isZoomImgLoaded: false,
            loadedImgEl: undefined,
            modalState: "UNLOADED",
            shouldRefresh: false,
            styleGhost: {}
        };
        this.refContent = /*#__PURE__*/ react.createRef();
        this.refDialog = /*#__PURE__*/ react.createRef();
        this.refModalContent = /*#__PURE__*/ react.createRef();
        this.refModalImg = /*#__PURE__*/ react.createRef();
        this.refWrap = /*#__PURE__*/ react.createRef();
        this.imgEl = null;
        this.isScaling = false;
        this.prevBodyAttrs = defaultBodyAttrs;
        this.styleModalImg = {};
        this.handleModalStateChange = (prevModalState)=>{
            const { modalState } = this.state;
            if (prevModalState !== "LOADING" && modalState === "LOADING") {
                this.loadZoomImg();
                window.addEventListener("resize", this.handleResize, {
                    passive: true
                });
                window.addEventListener("touchstart", this.handleTouchStart, {
                    passive: true
                });
                window.addEventListener("touchmove", this.handleTouchMove, {
                    passive: true
                });
                window.addEventListener("touchend", this.handleTouchEnd, {
                    passive: true
                });
                window.addEventListener("touchcancel", this.handleTouchCancel, {
                    passive: true
                });
                document.addEventListener("keydown", this.handleKeyDown, true);
            } else if (prevModalState !== "LOADED" && modalState === "LOADED") {
                window.addEventListener("wheel", this.handleWheel, {
                    passive: true
                });
            } else if (prevModalState !== "UNLOADING" && modalState === "UNLOADING") {
                this.ensureImgTransitionEnd();
                window.removeEventListener("wheel", this.handleWheel);
                window.removeEventListener("touchstart", this.handleTouchStart);
                window.removeEventListener("touchmove", this.handleTouchMove);
                window.removeEventListener("touchend", this.handleTouchEnd);
                window.removeEventListener("touchcancel", this.handleTouchCancel);
                document.removeEventListener("keydown", this.handleKeyDown, true);
            } else if (prevModalState !== "UNLOADED" && modalState === "UNLOADED") {
                var _this_refModalImg_current_removeEventListener, _this_refModalImg_current, _this_refDialog_current_close, _this_refDialog_current;
                this.bodyScrollEnable();
                window.removeEventListener("resize", this.handleResize);
                (_this_refModalImg_current = this.refModalImg.current) === null || _this_refModalImg_current === void 0 ? void 0 : (_this_refModalImg_current_removeEventListener = _this_refModalImg_current.removeEventListener) === null || _this_refModalImg_current_removeEventListener === void 0 ? void 0 : _this_refModalImg_current_removeEventListener.call(_this_refModalImg_current, "transitionend", this.handleImgTransitionEnd);
                (_this_refDialog_current = this.refDialog.current) === null || _this_refDialog_current === void 0 ? void 0 : (_this_refDialog_current_close = _this_refDialog_current.close) === null || _this_refDialog_current_close === void 0 ? void 0 : _this_refDialog_current_close.call(_this_refDialog_current);
            }
        };
        this.getDialogContainer = ()=>{
            let el = document.querySelector("[data-rmiz-portal]");
            if (el == null) {
                el = document.createElement("div");
                el.setAttribute("data-rmiz-portal", "");
                document.body.appendChild(el);
            }
            return el;
        };
        this.setId = ()=>{
            const gen4 = ()=>Math.random().toString(16).slice(-4);
            this.setState({
                id: gen4() + gen4() + gen4()
            });
        };
        this.setAndTrackImg = ()=>{
            const contentEl = this.refContent.current;
            if (!contentEl) return;
            this.imgEl = contentEl.querySelector(IMAGE_QUERY);
            if (this.imgEl) {
                var _this_contentNotFoundChangeObserver_disconnect, _this_contentNotFoundChangeObserver;
                (_this_contentNotFoundChangeObserver = this.contentNotFoundChangeObserver) === null || _this_contentNotFoundChangeObserver === void 0 ? void 0 : (_this_contentNotFoundChangeObserver_disconnect = _this_contentNotFoundChangeObserver.disconnect) === null || _this_contentNotFoundChangeObserver_disconnect === void 0 ? void 0 : _this_contentNotFoundChangeObserver_disconnect.call(_this_contentNotFoundChangeObserver);
                this.imgEl.addEventListener("load", this.handleImgLoad);
                this.imgEl.addEventListener("click", this.handleZoom);
                if (!this.state.loadedImgEl) {
                    this.handleImgLoad();
                }
                this.imgElResizeObserver = new ResizeObserver((entries)=>{
                    const entry = entries[0];
                    if (entry === null || entry === void 0 ? void 0 : entry.target) {
                        this.imgEl = entry.target;
                        this.setState({
                            styleGhost: getStyleGhost(this.imgEl)
                        });
                    }
                });
                this.imgElResizeObserver.observe(this.imgEl);
                if (!this.contentChangeObserver) {
                    this.contentChangeObserver = new MutationObserver(()=>{
                        this.setState({
                            styleGhost: getStyleGhost(this.imgEl)
                        });
                    });
                    this.contentChangeObserver.observe(contentEl, {
                        attributes: true,
                        childList: true,
                        subtree: true
                    });
                }
            } else if (!this.contentNotFoundChangeObserver) {
                this.contentNotFoundChangeObserver = new MutationObserver(this.setAndTrackImg);
                this.contentNotFoundChangeObserver.observe(contentEl, {
                    childList: true,
                    subtree: true
                });
            }
        };
        this.handleIfZoomChanged = (prevIsZoomed)=>{
            const { isZoomed } = this.props;
            if (!prevIsZoomed && isZoomed) {
                this.zoom();
            } else if (prevIsZoomed && !isZoomed) {
                this.unzoom();
            }
        };
        this.handleImgLoad = ()=>{
            const imgSrc = getImgSrc(this.imgEl);
            if (!imgSrc) return;
            const img = new Image();
            if (testImg(this.imgEl)) {
                img.sizes = this.imgEl.sizes;
                img.srcset = this.imgEl.srcset;
                img.crossOrigin = this.imgEl.crossOrigin;
            }
            img.src = imgSrc;
            const setLoaded = ()=>{
                this.setState({
                    loadedImgEl: img,
                    styleGhost: getStyleGhost(this.imgEl)
                });
            };
            img.decode().then(setLoaded).catch(()=>{
                if (testImgLoaded(img)) {
                    setLoaded();
                    return;
                }
                img.onload = setLoaded;
            });
        };
        this.handleZoom = (e)=>{
            if (!this.props.isDisabled && this.hasImage()) {
                var _this_props_onZoomChange, _this_props;
                (_this_props_onZoomChange = (_this_props = this.props).onZoomChange) === null || _this_props_onZoomChange === void 0 ? void 0 : _this_props_onZoomChange.call(_this_props, true, {
                    event: e
                });
            }
        };
        this.handleUnzoom = (e)=>{
            if (!this.props.isDisabled) {
                var _this_props_onZoomChange, _this_props;
                (_this_props_onZoomChange = (_this_props = this.props).onZoomChange) === null || _this_props_onZoomChange === void 0 ? void 0 : _this_props_onZoomChange.call(_this_props, false, {
                    event: e
                });
            }
        };
        this.handleBtnUnzoomClick = (e)=>{
            e.preventDefault();
            e.stopPropagation();
            this.handleUnzoom(e);
        };
        this.handleDialogCancel = (e)=>{
            e.preventDefault();
        };
        this.handleDialogClick = (e)=>{
            if (e.target === this.refModalContent.current || e.target === this.refModalImg.current) {
                e.stopPropagation();
                this.handleUnzoom(e);
            }
        };
        this.handleDialogClose = (e)=>{
            e.stopPropagation();
            this.handleUnzoom(e);
        };
        this.handleKeyDown = (e)=>{
            if (e.key === "Escape" || e.keyCode === 27) {
                e.preventDefault();
                e.stopPropagation();
                this.handleUnzoom(e);
            }
        };
        this.handleWheel = (e)=>{
            if (e.ctrlKey) return;
            e.stopPropagation();
            queueMicrotask(()=>{
                this.handleUnzoom(e);
            });
        };
        this.handleTouchStart = (e)=>{
            if (e.touches.length > 1) {
                this.isScaling = true;
                return;
            }
            if (e.changedTouches.length === 1 && e.changedTouches[0]) {
                this.touchYStart = e.changedTouches[0].screenY;
            }
        };
        this.handleTouchMove = (e)=>{
            var _window_visualViewport;
            var _window_visualViewport_scale;
            const browserScale = (_window_visualViewport_scale = (_window_visualViewport = window.visualViewport) === null || _window_visualViewport === void 0 ? void 0 : _window_visualViewport.scale) !== null && _window_visualViewport_scale !== void 0 ? _window_visualViewport_scale : 1;
            if (this.props.canSwipeToUnzoom && !this.isScaling && browserScale <= 1 && this.touchYStart != null && e.changedTouches[0]) {
                this.touchYEnd = e.changedTouches[0].screenY;
                const max = Math.max(this.touchYStart, this.touchYEnd);
                const min = Math.min(this.touchYStart, this.touchYEnd);
                const delta = Math.abs(max - min);
                if (delta > this.props.swipeToUnzoomThreshold) {
                    this.touchYStart = undefined;
                    this.touchYEnd = undefined;
                    this.handleUnzoom(e);
                }
            }
        };
        this.handleTouchEnd = ()=>{
            this.isScaling = false;
            this.touchYStart = undefined;
            this.touchYEnd = undefined;
        };
        this.handleTouchCancel = ()=>{
            this.isScaling = false;
            this.touchYStart = undefined;
            this.touchYEnd = undefined;
        };
        this.handleResize = ()=>{
            this.setState({
                shouldRefresh: true
            });
        };
        this.hasImage = ()=>{
            return this.imgEl && (this.state.loadedImgEl || testSvg(this.imgEl)) && window.getComputedStyle(this.imgEl).display !== "none";
        };
        this.zoom = ()=>{
            var _this_refDialog_current_showModal, _this_refDialog_current, _this_refModalImg_current_addEventListener, _this_refModalImg_current;
            this.bodyScrollDisable();
            (_this_refDialog_current = this.refDialog.current) === null || _this_refDialog_current === void 0 ? void 0 : (_this_refDialog_current_showModal = _this_refDialog_current.showModal) === null || _this_refDialog_current_showModal === void 0 ? void 0 : _this_refDialog_current_showModal.call(_this_refDialog_current);
            (_this_refModalImg_current = this.refModalImg.current) === null || _this_refModalImg_current === void 0 ? void 0 : (_this_refModalImg_current_addEventListener = _this_refModalImg_current.addEventListener) === null || _this_refModalImg_current_addEventListener === void 0 ? void 0 : _this_refModalImg_current_addEventListener.call(_this_refModalImg_current, "transitionend", this.handleImgTransitionEnd);
            this.setState({
                modalState: "LOADING"
            });
        };
        this.unzoom = ()=>{
            this.setState({
                modalState: "UNLOADING"
            });
        };
        this.handleImgTransitionEnd = ()=>{
            clearTimeout(this.timeoutTransitionEnd);
            if (this.state.modalState === "LOADING") {
                this.setState({
                    modalState: "LOADED"
                });
            } else if (this.state.modalState === "UNLOADING") {
                this.setState({
                    shouldRefresh: false,
                    modalState: "UNLOADED"
                });
            }
        };
        this.ensureImgTransitionEnd = ()=>{
            if (this.refModalImg.current) {
                const td = window.getComputedStyle(this.refModalImg.current).transitionDuration;
                const tdFloat = parseFloat(td);
                if (tdFloat) {
                    const tdMs = tdFloat * (td.endsWith("ms") ? 1 : 1000) + 50;
                    this.timeoutTransitionEnd = setTimeout(this.handleImgTransitionEnd, tdMs);
                }
            }
        };
        this.bodyScrollDisable = ()=>{
            this.prevBodyAttrs = {
                overflow: document.body.style.overflow,
                width: document.body.style.width
            };
            const clientWidth = document.body.clientWidth;
            document.body.style.overflow = "hidden";
            document.body.style.width = "".concat(clientWidth, "px");
        };
        this.bodyScrollEnable = ()=>{
            document.body.style.width = this.prevBodyAttrs.width;
            document.body.style.overflow = this.prevBodyAttrs.overflow;
            this.prevBodyAttrs = defaultBodyAttrs;
        };
        this.loadZoomImg = ()=>{
            const { props: { zoomImg } } = this;
            const zoomImgSrc = zoomImg === null || zoomImg === void 0 ? void 0 : zoomImg.src;
            if (zoomImgSrc) {
                const img = new Image();
                var _zoomImg_sizes;
                img.sizes = (_zoomImg_sizes = zoomImg === null || zoomImg === void 0 ? void 0 : zoomImg.sizes) !== null && _zoomImg_sizes !== void 0 ? _zoomImg_sizes : "";
                var _zoomImg_srcSet;
                img.srcset = (_zoomImg_srcSet = zoomImg === null || zoomImg === void 0 ? void 0 : zoomImg.srcSet) !== null && _zoomImg_srcSet !== void 0 ? _zoomImg_srcSet : "";
                var _zoomImg_crossOrigin;
                img.crossOrigin = (_zoomImg_crossOrigin = zoomImg === null || zoomImg === void 0 ? void 0 : zoomImg.crossOrigin) !== null && _zoomImg_crossOrigin !== void 0 ? _zoomImg_crossOrigin : undefined;
                img.src = zoomImgSrc;
                const setLoaded = ()=>{
                    this.setState({
                        isZoomImgLoaded: true
                    });
                };
                img.decode().then(setLoaded).catch(()=>{
                    if (testImgLoaded(img)) {
                        setLoaded();
                        return;
                    }
                    img.onload = setLoaded;
                });
            }
        };
        this.UNSAFE_handleSvg = ()=>{
            const { imgEl, refModalImg, styleModalImg } = this;
            if (testSvg(imgEl)) {
                var _refModalImg_current_firstChild_remove, _refModalImg_current_firstChild, _refModalImg_current, _refModalImg_current_appendChild, _refModalImg_current1;
                const svgEl = imgEl.cloneNode(true);
                adjustSvgIDs(svgEl);
                svgEl.style.width = "".concat(styleModalImg.width || 0, "px");
                svgEl.style.height = "".concat(styleModalImg.height || 0, "px");
                svgEl.addEventListener("click", this.handleUnzoom);
                (_refModalImg_current = refModalImg.current) === null || _refModalImg_current === void 0 ? void 0 : (_refModalImg_current_firstChild = _refModalImg_current.firstChild) === null || _refModalImg_current_firstChild === void 0 ? void 0 : (_refModalImg_current_firstChild_remove = _refModalImg_current_firstChild.remove) === null || _refModalImg_current_firstChild_remove === void 0 ? void 0 : _refModalImg_current_firstChild_remove.call(_refModalImg_current_firstChild);
                (_refModalImg_current1 = refModalImg.current) === null || _refModalImg_current1 === void 0 ? void 0 : (_refModalImg_current_appendChild = _refModalImg_current1.appendChild) === null || _refModalImg_current_appendChild === void 0 ? void 0 : _refModalImg_current_appendChild.call(_refModalImg_current1, svgEl);
            }
        };
    }
}
ControlledBase.defaultProps = {
    a11yNameButtonUnzoom: "Minimize image",
    a11yNameButtonZoom: "Expand image",
    canSwipeToUnzoom: true,
    IconUnzoom: ICompress,
    IconZoom: IEnlarge,
    isDisabled: false,
    swipeToUnzoomThreshold: 10,
    wrapElement: "div",
    zoomMargin: 0
};
function Uncontrolled(param) {
    let { onZoomChange, ...props } = param;
    const [isZoomed, setIsZoomed] = react.useState(false);
    const handleZoomChange = react.useCallback((value, param)=>{
        let { event } = param;
        setIsZoomed(value);
        onZoomChange === null || onZoomChange === void 0 ? void 0 : onZoomChange(value, {
            event
        });
    }, [
        onZoomChange
    ]);
    return /*#__PURE__*/ react.createElement(Controlled, {
        ...props,
        isZoomed: isZoomed,
        onZoomChange: handleZoomChange
    });
}


// EXTERNAL MODULE: ./node_modules/next/dist/shared/lib/image-external.js
var image_external = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js");
var image_external_default = /*#__PURE__*/__webpack_require__.n(image_external);
;// CONCATENATED MODULE: ./node_modules/next/dist/api/image.js



//# sourceMappingURL=image.js.map
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/mdx-components/image.js




const image_Image = (0,react.forwardRef)((props, ref) => {
  const $ = (0,dist.c)(6);
  if (false) {}
  const ComponentToUse = typeof props.src === "object" ? (image_external_default()) : "img";
  let t0;
  if ($[2] !== ComponentToUse || $[3] !== props || $[4] !== ref) {
    t0 = /* @__PURE__ */ (0,jsx_runtime.jsx)(ComponentToUse, { ...props, ref, "data-pagefind-index-attrs": "title,alt" });
    $[2] = ComponentToUse;
    $[3] = props;
    $[4] = ref;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  return t0;
});
image_Image.displayName = "Image";


;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/components/image-zoom.js
/* __next_internal_client_entry_do_not_use__ ImageZoom auto */ 




function getImageSrc(src) {
    if (typeof src === "string") {
        return src;
    }
    if ("default" in src) {
        return src.default.src;
    }
    return src.src;
}
const ImageZoom = (props)=>{
    const $ = (0,dist.c)(12);
    const imgRef = (0,react.useRef)(null);
    const [isInsideAnchor, setIsInsideAnchor] = (0,react.useState)(false);
    let t0;
    let t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = ()=>{
            setIsInsideAnchor(imgRef.current.closest("a") !== null);
        };
        t1 = [];
        $[0] = t0;
        $[1] = t1;
    } else {
        t0 = $[0];
        t1 = $[1];
    }
    (0,react.useEffect)(t0, t1);
    let t2;
    if ($[2] !== props) {
        t2 = /* @__PURE__ */ (0,jsx_runtime.jsx)(image_Image, {
            ...props,
            ref: imgRef
        });
        $[2] = props;
        $[3] = t2;
    } else {
        t2 = $[3];
    }
    const img = t2;
    if (isInsideAnchor) {
        return img;
    }
    let t3;
    if ($[4] !== props.src) {
        t3 = getImageSrc(props.src);
        $[4] = props.src;
        $[5] = t3;
    } else {
        t3 = $[5];
    }
    let t4;
    if ($[6] !== props.alt || $[7] !== t3) {
        t4 = {
            src: t3,
            alt: props.alt
        };
        $[6] = props.alt;
        $[7] = t3;
        $[8] = t4;
    } else {
        t4 = $[8];
    }
    let t5;
    if ($[9] !== img || $[10] !== t4) {
        t5 = /* @__PURE__ */ (0,jsx_runtime.jsx)(Uncontrolled, {
            zoomMargin: 40,
            zoomImg: t4,
            wrapElement: "span",
            children: img
        });
        $[9] = img;
        $[10] = t4;
        $[11] = t5;
    } else {
        t5 = $[11];
    }
    return t5;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/components/select.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Select: function() { return /* binding */ Select; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/@react-aria/focus/dist/useFocusRing.mjs + 8 modules
var useFocusRing = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/focus/dist/useFocusRing.mjs");
// EXTERNAL MODULE: ../../node_modules/@react-aria/interactions/dist/useHover.mjs
var useHover = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/interactions/dist/useHover.mjs");
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/index.js
var react_dom = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-active-press.js
var use_active_press = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-active-press.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-by-comparator.js
var use_by_comparator = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-by-comparator.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-controllable.js
var use_controllable = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-controllable.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-default-value.js
var use_default_value = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-default-value.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
var use_disposables = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-disposables.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-element-size.js
var use_element_size = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-element-size.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-event.js
var use_event = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-inert-others.js
var use_inert_others = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-inert-others.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var use_iso_morphic_effect = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js
var use_latest_value = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-on-disappear.js
var use_on_disappear = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-on-disappear.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js + 1 modules
var use_outside_click = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-owner.js
var use_owner = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-owner.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-quick-release.js
var use_quick_release = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-quick-release.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
var use_resolve_button_type = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-scroll-lock.js + 7 modules
var use_scroll_lock = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-scroll-lock.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-slot.js
var use_slot = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-slot.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var use_sync_refs = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-text-value.js + 1 modules
var use_text_value = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-text-value.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js
var use_tracked_pointer = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-transition.js + 1 modules
var use_transition = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-transition.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/disabled.js
var disabled = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/disabled.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/floating.js
var floating = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/floating.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/form-fields.js
var form_fields = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/form-fields.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/frozen.js
var frozen = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/frozen.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/id.js
var id = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/id.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/open-closed.js
var open_closed = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/open-closed.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/machines/stack-machine.js
var stack_machine = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/machines/stack-machine.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/react-glue.js
var react_glue = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/react-glue.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/bugs.js
var bugs = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/bugs.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js
var calculate_active_index = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/disposables.js
var disposables = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/dom.js
var dom = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/focus-management.js
var focus_management = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/focus-management.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/form.js
var utils_form = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/form.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/match.js
var match = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/match.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/owner.js
var owner = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/owner.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/render.js + 1 modules
var render = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/render.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/description/description.js
var description = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/description/description.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/keyboard.js
var keyboard = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/keyboard.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/label/label.js
var label = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/label/label.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/mouse.js
var mouse = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/mouse.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/portal/portal.js + 1 modules
var portal = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/portal/portal.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/machine.js
var machine = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/machine.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/element-movement.js
var element_movement = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/element-movement.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/components/listbox/listbox-machine.js
var h = Object.defineProperty;
var y = (e, o, t)=>o in e ? h(e, o, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : e[o] = t;
var S = (e, o, t)=>(y(e, typeof o != "symbol" ? o + "" : o, t), t);






var listbox_machine_F = ((t)=>(t[t.Open = 0] = "Open", t[t.Closed = 1] = "Closed", t))(listbox_machine_F || {}), listbox_machine_C = ((t)=>(t[t.Single = 0] = "Single", t[t.Multi = 1] = "Multi", t))(listbox_machine_C || {}), P = ((t)=>(t[t.Pointer = 0] = "Pointer", t[t.Other = 1] = "Other", t))(P || {}), listbox_machine_k = ((s)=>(s[s.OpenListbox = 0] = "OpenListbox", s[s.CloseListbox = 1] = "CloseListbox", s[s.GoToOption = 2] = "GoToOption", s[s.Search = 3] = "Search", s[s.ClearSearch = 4] = "ClearSearch", s[s.RegisterOptions = 5] = "RegisterOptions", s[s.UnregisterOptions = 6] = "UnregisterOptions", s[s.SetButtonElement = 7] = "SetButtonElement", s[s.SetOptionsElement = 8] = "SetOptionsElement", s[s.SortOptions = 9] = "SortOptions", s[s.MarkButtonAsMoved = 10] = "MarkButtonAsMoved", s))(listbox_machine_k || {});
function m(e) {
    let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (t)=>t;
    let t = e.activeOptionIndex !== null ? e.options[e.activeOptionIndex] : null, n = (0,focus_management/* sortByDomNode */.z2)(o(e.options.slice()), (r)=>r.dataRef.current.domRef.current), i = t ? n.indexOf(t) : null;
    return i === -1 && (i = null), {
        options: n,
        activeOptionIndex: i
    };
}
let D = {
    [1] (e) {
        if (e.dataRef.current.disabled || e.listboxState === 1) return e;
        let o = e.buttonElement ? element_movement/* ElementPositionState */.On.Tracked((0,element_movement/* computeVisualPosition */.kn)(e.buttonElement)) : e.buttonPositionState;
        return {
            ...e,
            activeOptionIndex: null,
            pendingFocus: {
                focus: calculate_active_index/* Focus */.T.Nothing
            },
            listboxState: 1,
            __demoMode: !1,
            buttonPositionState: o
        };
    },
    [0] (e, o) {
        if (e.dataRef.current.disabled || e.listboxState === 0) return e;
        let t = e.activeOptionIndex, { isSelected: n } = e.dataRef.current, i = e.options.findIndex((r)=>n(r.dataRef.current.value));
        return i !== -1 && (t = i), {
            ...e,
            pendingFocus: o.focus,
            listboxState: 0,
            activeOptionIndex: t,
            __demoMode: !1,
            buttonPositionState: element_movement/* ElementPositionState */.On.Idle
        };
    },
    [2] (e, o) {
        var r, l, u, a, f;
        if (e.dataRef.current.disabled || e.listboxState === 1) return e;
        let t = {
            ...e,
            searchQuery: "",
            activationTrigger: (r = o.trigger) != null ? r : 1,
            __demoMode: !1
        };
        if (o.focus === calculate_active_index/* Focus */.T.Nothing) return {
            ...t,
            activeOptionIndex: null
        };
        if (o.focus === calculate_active_index/* Focus */.T.Specific) return {
            ...t,
            activeOptionIndex: e.options.findIndex((d)=>d.id === o.id)
        };
        if (o.focus === calculate_active_index/* Focus */.T.Previous) {
            let d = e.activeOptionIndex;
            if (d !== null) {
                let s = e.options[d].dataRef.current.domRef, x = (0,calculate_active_index/* calculateActiveIndex */.d)(o, {
                    resolveItems: ()=>e.options,
                    resolveActiveIndex: ()=>e.activeOptionIndex,
                    resolveId: (c)=>c.id,
                    resolveDisabled: (c)=>c.dataRef.current.disabled
                });
                if (x !== null) {
                    let c = e.options[x].dataRef.current.domRef;
                    if (((l = s.current) == null ? void 0 : l.previousElementSibling) === c.current || ((u = c.current) == null ? void 0 : u.previousElementSibling) === null) return {
                        ...t,
                        activeOptionIndex: x
                    };
                }
            }
        } else if (o.focus === calculate_active_index/* Focus */.T.Next) {
            let d = e.activeOptionIndex;
            if (d !== null) {
                let s = e.options[d].dataRef.current.domRef, x = (0,calculate_active_index/* calculateActiveIndex */.d)(o, {
                    resolveItems: ()=>e.options,
                    resolveActiveIndex: ()=>e.activeOptionIndex,
                    resolveId: (c)=>c.id,
                    resolveDisabled: (c)=>c.dataRef.current.disabled
                });
                if (x !== null) {
                    let c = e.options[x].dataRef.current.domRef;
                    if (((a = s.current) == null ? void 0 : a.nextElementSibling) === c.current || ((f = c.current) == null ? void 0 : f.nextElementSibling) === null) return {
                        ...t,
                        activeOptionIndex: x
                    };
                }
            }
        }
        let n = m(e), i = (0,calculate_active_index/* calculateActiveIndex */.d)(o, {
            resolveItems: ()=>n.options,
            resolveActiveIndex: ()=>n.activeOptionIndex,
            resolveId: (d)=>d.id,
            resolveDisabled: (d)=>d.dataRef.current.disabled
        });
        return {
            ...t,
            ...n,
            activeOptionIndex: i
        };
    },
    [3]: (e, o)=>{
        if (e.dataRef.current.disabled || e.listboxState === 1) return e;
        let n = e.searchQuery !== "" ? 0 : 1, i = e.searchQuery + o.value.toLowerCase(), l = (e.activeOptionIndex !== null ? e.options.slice(e.activeOptionIndex + n).concat(e.options.slice(0, e.activeOptionIndex + n)) : e.options).find((a)=>{
            var f;
            return !a.dataRef.current.disabled && ((f = a.dataRef.current.textValue) == null ? void 0 : f.startsWith(i));
        }), u = l ? e.options.indexOf(l) : -1;
        return u === -1 || u === e.activeOptionIndex ? {
            ...e,
            searchQuery: i
        } : {
            ...e,
            searchQuery: i,
            activeOptionIndex: u,
            activationTrigger: 1
        };
    },
    [4] (e) {
        return e.dataRef.current.disabled || e.listboxState === 1 || e.searchQuery === "" ? e : {
            ...e,
            searchQuery: ""
        };
    },
    [5]: (e, o)=>{
        let t = e.options.concat(o.options), n = e.activeOptionIndex;
        if (e.pendingFocus.focus !== calculate_active_index/* Focus */.T.Nothing && (n = (0,calculate_active_index/* calculateActiveIndex */.d)(e.pendingFocus, {
            resolveItems: ()=>t,
            resolveActiveIndex: ()=>e.activeOptionIndex,
            resolveId: (i)=>i.id,
            resolveDisabled: (i)=>i.dataRef.current.disabled
        })), e.activeOptionIndex === null) {
            let { isSelected: i } = e.dataRef.current;
            if (i) {
                let r = t.findIndex((l)=>i == null ? void 0 : i(l.dataRef.current.value));
                r !== -1 && (n = r);
            }
        }
        return {
            ...e,
            options: t,
            activeOptionIndex: n,
            pendingFocus: {
                focus: calculate_active_index/* Focus */.T.Nothing
            },
            pendingShouldSort: !0
        };
    },
    [6]: (e, o)=>{
        let t = e.options, n = [], i = new Set(o.options);
        for (let [r, l] of t.entries())if (i.has(l.id) && (n.push(r), i.delete(l.id), i.size === 0)) break;
        if (n.length > 0) {
            t = t.slice();
            for (let r of n.reverse())t.splice(r, 1);
        }
        return {
            ...e,
            options: t,
            activationTrigger: 1
        };
    },
    [7]: (e, o)=>e.buttonElement === o.element ? e : {
            ...e,
            buttonElement: o.element
        },
    [8]: (e, o)=>e.optionsElement === o.element ? e : {
            ...e,
            optionsElement: o.element
        },
    [9]: (e)=>e.pendingShouldSort ? {
            ...e,
            ...m(e),
            pendingShouldSort: !1
        } : e,
    [10] (e) {
        return e.buttonPositionState.kind !== "Tracked" ? e : {
            ...e,
            buttonPositionState: element_movement/* ElementPositionState */.On.Moved
        };
    }
};
class T extends machine/* Machine */.J {
    static new(param) {
        let { id: t, __demoMode: n = !1 } = param;
        return new T({
            id: t,
            dataRef: {
                current: {}
            },
            listboxState: n ? 0 : 1,
            options: [],
            searchQuery: "",
            activeOptionIndex: null,
            activationTrigger: 1,
            buttonElement: null,
            optionsElement: null,
            pendingShouldSort: !1,
            pendingFocus: {
                focus: calculate_active_index/* Focus */.T.Nothing
            },
            __demoMode: n,
            buttonPositionState: element_movement/* ElementPositionState */.On.Idle
        });
    }
    reduce(t, n) {
        return (0,match/* match */.E)(n.type, D, t, n);
    }
    constructor(t){
        super(t);
        S(this, "actions", {
            onChange: (t)=>{
                let { onChange: n, compare: i, mode: r, value: l } = this.state.dataRef.current;
                return (0,match/* match */.E)(r, {
                    [0]: ()=>n == null ? void 0 : n(t),
                    [1]: ()=>{
                        let u = l.slice(), a = u.findIndex((f)=>i(f, t));
                        return a === -1 ? u.push(t) : u.splice(a, 1), n == null ? void 0 : n(u);
                    }
                });
            },
            registerOption: (0,machine/* batch */.dC)(()=>{
                let t = [], n = new Set;
                return [
                    (i, r)=>{
                        n.has(r) || (n.add(r), t.push({
                            id: i,
                            dataRef: r
                        }));
                    },
                    ()=>(n.clear(), this.send({
                            type: 5,
                            options: t.splice(0)
                        }))
                ];
            }),
            unregisterOption: (0,machine/* batch */.dC)(()=>{
                let t = [];
                return [
                    (n)=>t.push(n),
                    ()=>{
                        this.send({
                            type: 6,
                            options: t.splice(0)
                        });
                    }
                ];
            }),
            goToOption: (0,machine/* batch */.dC)(()=>{
                let t = null;
                return [
                    (n, i)=>{
                        t = {
                            type: 2,
                            ...n,
                            trigger: i
                        };
                    },
                    ()=>t && this.send(t)
                ];
            }),
            closeListbox: ()=>{
                this.send({
                    type: 1
                });
            },
            openListbox: (t)=>{
                this.send({
                    type: 0,
                    focus: t
                });
            },
            selectActiveOption: ()=>{
                if (this.state.activeOptionIndex !== null) {
                    let { dataRef: t, id: n } = this.state.options[this.state.activeOptionIndex];
                    this.actions.onChange(t.current.value), this.send({
                        type: 2,
                        focus: calculate_active_index/* Focus */.T.Specific,
                        id: n
                    });
                }
            },
            selectOption: (t)=>{
                let n = this.state.options.find((i)=>i.id === t);
                n && this.actions.onChange(n.dataRef.current.value);
            },
            search: (t)=>{
                this.send({
                    type: 3,
                    value: t
                });
            },
            clearSearch: ()=>{
                this.send({
                    type: 4
                });
            },
            setButtonElement: (t)=>{
                this.send({
                    type: 7,
                    element: t
                });
            },
            setOptionsElement: (t)=>{
                this.send({
                    type: 8,
                    element: t
                });
            }
        });
        S(this, "selectors", {
            activeDescendantId (t) {
                var r;
                let n = t.activeOptionIndex, i = t.options;
                return n === null || (r = i[n]) == null ? void 0 : r.id;
            },
            isActive (t, n) {
                var l;
                let i = t.activeOptionIndex, r = t.options;
                return i !== null ? ((l = r[i]) == null ? void 0 : l.id) === n : !1;
            },
            shouldScrollIntoView (t, n) {
                return t.__demoMode || t.listboxState !== 0 || t.activationTrigger === 0 ? !1 : this.isActive(t, n);
            },
            didButtonMove (t) {
                return t.buttonPositionState.kind === "Moved";
            }
        });
        this.on(5, ()=>{
            requestAnimationFrame(()=>{
                this.send({
                    type: 9
                });
            });
        });
        {
            let n = this.state.id, i = stack_machine/* stackMachines */.n.get(null);
            this.disposables.add(i.on(stack_machine/* ActionTypes */.M.Push, (r)=>{
                !i.selectors.isTop(r, n) && this.state.listboxState === 0 && this.actions.closeListbox();
            })), this.on(0, ()=>i.actions.push(n)), this.on(1, ()=>i.actions.pop(n));
        }
        this.disposables.group((n)=>{
            this.on(1, (i)=>{
                i.buttonElement && (n.dispose(), n.add((0,element_movement/* detectMovement */.hS)(i.buttonElement, i.buttonPositionState, ()=>{
                    this.send({
                        type: 10
                    });
                })));
            });
        });
    }
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-on-unmount.js
var use_on_unmount = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-on-unmount.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/components/listbox/listbox-machine-glue.js



const listbox_machine_glue_c = /*#__PURE__*/ (0,react.createContext)(null);
function listbox_machine_glue_p(o) {
    let e = (0,react.useContext)(listbox_machine_glue_c);
    if (e === null) {
        let t = new Error("<".concat(o, " /> is missing a parent <Listbox /> component."));
        throw Error.captureStackTrace && Error.captureStackTrace(t, listbox_machine_glue_u), t;
    }
    return e;
}
function listbox_machine_glue_u(param) {
    let { id: o, __demoMode: e = !1 } = param;
    let t = (0,react.useMemo)(()=>T.new({
            id: o,
            __demoMode: e
        }), []);
    return (0,use_on_unmount/* useOnUnmount */.L)(()=>t.dispose()), t;
}


;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/components/listbox/listbox.js
/* __next_internal_client_entry_do_not_use__ Listbox,ListboxButton,ListboxLabel,ListboxOption,ListboxOptions,ListboxSelectedOption auto */ 

















































let ie = /*#__PURE__*/ (0,react.createContext)(null);
ie.displayName = "ListboxDataContext";
function ee(b) {
    let E = (0,react.useContext)(ie);
    if (E === null) {
        let y = new Error("<".concat(b, " /> is missing a parent <Listbox /> component."));
        throw Error.captureStackTrace && Error.captureStackTrace(y, ee), y;
    }
    return E;
}
let gt = react.Fragment;
function vt(b, E) {
    let y = (0,react.useId)(), u = (0,disabled/* useDisabled */.B)(), { value: p, defaultValue: a, form: _, name: i, onChange: m, by: n, invalid: x = !1, disabled: O = u || !1, horizontal: l = !1, multiple: t = !1, __demoMode: s = !1, ...F } = b;
    const h = l ? "horizontal" : "vertical";
    let k = (0,use_sync_refs/* useSyncRefs */.T)(E), C = (0,use_default_value/* useDefaultValue */.L)(a), [c = t ? [] : void 0, L] = (0,use_controllable/* useControllable */.q)(p, m, C), f = listbox_machine_glue_u({
        id: y,
        __demoMode: s
    }), U = (0,react.useRef)({
        static: !1,
        hold: !1
    }), H = (0,react.useRef)(new Map), B = (0,use_by_comparator/* useByComparator */.J)(n), V = (0,react.useCallback)((g)=>(0,match/* match */.E)(r.mode, {
            [listbox_machine_C.Multi]: ()=>c.some((J)=>B(J, g)),
            [listbox_machine_C.Single]: ()=>B(c, g)
        }), [
        c
    ]), r = (0,use_slot/* useSlot */.x)({
        value: c,
        disabled: O,
        invalid: x,
        mode: t ? listbox_machine_C.Multi : listbox_machine_C.Single,
        orientation: h,
        onChange: L,
        compare: B,
        isSelected: V,
        optionsPropsRef: U,
        listRef: H
    });
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        f.state.dataRef.current = r;
    }, [
        r
    ]);
    let P = (0,react_glue/* useSlice */.M)(f, (g)=>g.listboxState), N = stack_machine/* stackMachines */.n.get(null), G = (0,react_glue/* useSlice */.M)(N, (0,react.useCallback)((g)=>N.selectors.isTop(g, y), [
        N,
        y
    ])), [R, W] = (0,react_glue/* useSlice */.M)(f, (g)=>[
            g.buttonElement,
            g.optionsElement
        ]);
    (0,use_outside_click/* useOutsideClick */.O)(G, [
        R,
        W
    ], (g, J)=>{
        f.send({
            type: listbox_machine_k.CloseListbox
        }), (0,focus_management/* isFocusableElement */.sP)(J, focus_management/* FocusableMode */.tJ.Loose) || (g.preventDefault(), R == null || R.focus());
    });
    let X = (0,use_slot/* useSlot */.x)({
        open: P === listbox_machine_F.Open,
        disabled: O,
        invalid: x,
        value: c
    }), [j, te] = (0,label/* useLabels */.bE)({
        inherit: !0
    }), o = {
        ref: k
    }, w = (0,react.useCallback)(()=>{
        if (C !== void 0) return L == null ? void 0 : L(C);
    }, [
        L,
        C
    ]), se = (0,render/* useRender */.L6)();
    return /*#__PURE__*/ react.createElement(te, {
        value: j,
        props: {
            htmlFor: R == null ? void 0 : R.id
        },
        slot: {
            open: P === listbox_machine_F.Open,
            disabled: O
        }
    }, /*#__PURE__*/ react.createElement(floating/* FloatingProvider */.HO, null, /*#__PURE__*/ react.createElement(listbox_machine_glue_c.Provider, {
        value: f
    }, /*#__PURE__*/ react.createElement(ie.Provider, {
        value: r
    }, /*#__PURE__*/ react.createElement(open_closed/* OpenClosedProvider */.up, {
        value: (0,match/* match */.E)(P, {
            [listbox_machine_F.Open]: open_closed/* State */.ZM.Open,
            [listbox_machine_F.Closed]: open_closed/* State */.ZM.Closed
        })
    }, i != null && c != null && /*#__PURE__*/ react.createElement(form_fields/* FormFields */.Mt, {
        disabled: O,
        data: {
            [i]: c
        },
        form: _,
        onReset: w
    }), se({
        ourProps: o,
        theirProps: F,
        slot: X,
        defaultTag: gt,
        name: "Listbox"
    }))))));
}
let Et = "button";
function ht(b, E) {
    let y = (0,react.useId)(), u = (0,id/* useProvidedId */.Q)(), p = ee("Listbox.Button"), a = listbox_machine_glue_p("Listbox.Button"), { id: _ = u || "headlessui-listbox-button-".concat(y), disabled: i = p.disabled || !1, autoFocus: m = !1, ...n } = b, x = (0,use_sync_refs/* useSyncRefs */.T)(E, (0,floating/* useFloatingReference */.AZ)(), a.actions.setButtonElement), O = (0,floating/* useFloatingReferenceProps */.L)(), [l, t, s] = (0,react_glue/* useSlice */.M)(a, (o)=>[
            o.listboxState,
            o.buttonElement,
            o.optionsElement
        ]), F = l === listbox_machine_F.Open;
    (0,use_quick_release/* useQuickRelease */.G)(F, {
        trigger: t,
        action: (0,react.useCallback)((o)=>{
            if (t != null && t.contains(o.target)) return use_quick_release/* Action */.a.Ignore;
            let w = o.target.closest('[role="option"]:not([data-disabled])');
            return dom/* isHTMLElement */.Re(w) ? use_quick_release/* Action */.a.Select(w) : s != null && s.contains(o.target) ? use_quick_release/* Action */.a.Ignore : use_quick_release/* Action */.a.Close;
        }, [
            t,
            s
        ]),
        close: a.actions.closeListbox,
        select: a.actions.selectActiveOption
    });
    let h = (0,use_event/* useEvent */.z)((o)=>{
        switch(o.key){
            case keyboard/* Keys */.R.Enter:
                (0,utils_form/* attemptSubmit */.g)(o.currentTarget);
                break;
            case keyboard/* Keys */.R.Space:
            case keyboard/* Keys */.R.ArrowDown:
                o.preventDefault(), a.actions.openListbox({
                    focus: p.value ? calculate_active_index/* Focus */.T.Nothing : calculate_active_index/* Focus */.T.First
                });
                break;
            case keyboard/* Keys */.R.ArrowUp:
                o.preventDefault(), a.actions.openListbox({
                    focus: p.value ? calculate_active_index/* Focus */.T.Nothing : calculate_active_index/* Focus */.T.Last
                });
                break;
        }
    }), k = (0,use_event/* useEvent */.z)((o)=>{
        switch(o.key){
            case keyboard/* Keys */.R.Space:
                o.preventDefault();
                break;
        }
    }), C = (0,use_event/* useEvent */.z)((o)=>{
        var w;
        if (o.button === mouse/* MouseButton */.t.Left) {
            if ((0,bugs/* isDisabledReactIssue7711 */.P)(o.currentTarget)) return o.preventDefault();
            a.state.listboxState === listbox_machine_F.Open ? ((0,react_dom.flushSync)(()=>a.actions.closeListbox()), (w = a.state.buttonElement) == null || w.focus({
                preventScroll: !0
            })) : (o.preventDefault(), a.actions.openListbox({
                focus: calculate_active_index/* Focus */.T.Nothing
            }));
        }
    }), c = (0,react.useRef)(null), L = (0,use_event/* useEvent */.z)((o)=>{
        c.current = o.pointerType, o.pointerType === "mouse" && C(o);
    }), f = (0,use_event/* useEvent */.z)((o)=>{
        c.current !== "mouse" && C(o);
    }), U = (0,use_event/* useEvent */.z)((o)=>o.preventDefault()), H = (0,label/* useLabelledBy */.wp)([
        _
    ]), B = (0,description/* useDescribedBy */.zH)(), { isFocusVisible: V, focusProps: r } = (0,useFocusRing/* useFocusRing */.F)({
        autoFocus: m
    }), { isHovered: P, hoverProps: N } = (0,useHover/* useHover */.X)({
        isDisabled: i
    }), { pressed: G, pressProps: R } = (0,use_active_press/* useActivePress */.x)({
        disabled: i
    }), W = (0,use_slot/* useSlot */.x)({
        open: l === listbox_machine_F.Open,
        active: G || l === listbox_machine_F.Open,
        disabled: i,
        invalid: p.invalid,
        value: p.value,
        hover: P,
        focus: V,
        autofocus: m
    }), X = (0,react_glue/* useSlice */.M)(a, (o)=>o.listboxState === listbox_machine_F.Open), j = (0,render/* mergeProps */.dG)(O(), {
        ref: x,
        id: _,
        type: (0,use_resolve_button_type/* useResolveButtonType */.f)(b, t),
        "aria-haspopup": "listbox",
        "aria-controls": s == null ? void 0 : s.id,
        "aria-expanded": X,
        "aria-labelledby": H,
        "aria-describedby": B,
        disabled: i || void 0,
        autoFocus: m,
        onKeyDown: h,
        onKeyUp: k,
        onKeyPress: U,
        onPointerDown: L,
        onClick: f
    }, r, N, R);
    return (0,render/* useRender */.L6)()({
        ourProps: j,
        theirProps: n,
        slot: W,
        defaultTag: Et,
        name: "Listbox.Button"
    });
}
let Le = /*#__PURE__*/ (0,react.createContext)(!1), Rt = "div", At = render/* RenderFeatures */.VN.RenderStrategy | render/* RenderFeatures */.VN.Static;
function Dt(b, E) {
    let y = (0,react.useId)(), { id: u = "headlessui-listbox-options-".concat(y), anchor: p, portal: a = !1, modal: _ = !0, transition: i = !1, ...m } = b, n = (0,floating/* useResolvedAnchor */.Vy)(p), [x, O] = (0,react.useState)(null);
    n && (a = !0);
    let l = ee("Listbox.Options"), t = listbox_machine_glue_p("Listbox.Options"), [s, F, h, k] = (0,react_glue/* useSlice */.M)(t, (e)=>[
            e.listboxState,
            e.buttonElement,
            e.optionsElement,
            e.__demoMode
        ]), C = (0,use_owner/* useOwnerDocument */.i)(F), c = (0,use_owner/* useOwnerDocument */.i)(h), L = (0,open_closed/* useOpenClosed */.oJ)(), [f, U] = (0,use_transition/* useTransition */.Y)(i, x, L !== null ? (L & open_closed/* State */.ZM.Open) === open_closed/* State */.ZM.Open : s === listbox_machine_F.Open);
    (0,use_on_disappear/* useOnDisappear */.m)(f, F, t.actions.closeListbox);
    let H = k ? !1 : _ && s === listbox_machine_F.Open;
    (0,use_scroll_lock/* useScrollLock */.P)(H, c);
    let B = k ? !1 : _ && s === listbox_machine_F.Open;
    (0,use_inert_others/* useInertOthers */.s)(B, {
        allowed: (0,react.useCallback)(()=>[
                F,
                h
            ], [
            F,
            h
        ])
    });
    let r = (0,react_glue/* useSlice */.M)(t, t.selectors.didButtonMove) ? !1 : f, P = f && s === listbox_machine_F.Closed && !b.static, N = (0,frozen/* useFrozenData */._)(P, l.value), G = (0,react.useCallback)((e)=>l.compare(N, e), [
        l.compare,
        N
    ]), R = (0,react_glue/* useSlice */.M)(t, (e)=>{
        var Q;
        if (n == null || !((Q = n == null ? void 0 : n.to) != null && Q.includes("selection"))) return null;
        let A = e.options.findIndex((pe)=>G(pe.dataRef.current.value));
        return A === -1 && (A = 0), A;
    }), W = (()=>{
        if (n == null) return;
        if (R === null) return {
            ...n,
            inner: void 0
        };
        let e = Array.from(l.listRef.current.values());
        return {
            ...n,
            inner: {
                listRef: {
                    current: e
                },
                index: R
            }
        };
    })(), [X, j] = (0,floating/* useFloatingPanel */.ES)(W), te = (0,floating/* useFloatingPanelProps */.U8)(), o = (0,use_sync_refs/* useSyncRefs */.T)(E, n ? X : null, t.actions.setOptionsElement, O), w = (0,use_disposables/* useDisposables */.G)();
    (0,react.useEffect)(()=>{
        var A;
        let e = h;
        e && s === listbox_machine_F.Open && e !== ((A = (0,owner/* getOwnerDocument */.r)(e)) == null ? void 0 : A.activeElement) && (e == null || e.focus({
            preventScroll: !0
        }));
    }, [
        s,
        h
    ]);
    let se = (0,use_event/* useEvent */.z)((e)=>{
        var A, Q;
        switch(w.dispose(), e.key){
            case keyboard/* Keys */.R.Space:
                if (t.state.searchQuery !== "") return e.preventDefault(), e.stopPropagation(), t.actions.search(e.key);
            case keyboard/* Keys */.R.Enter:
                if (e.preventDefault(), e.stopPropagation(), t.state.activeOptionIndex !== null) {
                    let { dataRef: pe } = t.state.options[t.state.activeOptionIndex];
                    t.actions.onChange(pe.current.value);
                }
                l.mode === listbox_machine_C.Single && ((0,react_dom.flushSync)(()=>t.actions.closeListbox()), (A = t.state.buttonElement) == null || A.focus({
                    preventScroll: !0
                }));
                break;
            case (0,match/* match */.E)(l.orientation, {
                vertical: keyboard/* Keys */.R.ArrowDown,
                horizontal: keyboard/* Keys */.R.ArrowRight
            }):
                return e.preventDefault(), e.stopPropagation(), t.actions.goToOption({
                    focus: calculate_active_index/* Focus */.T.Next
                });
            case (0,match/* match */.E)(l.orientation, {
                vertical: keyboard/* Keys */.R.ArrowUp,
                horizontal: keyboard/* Keys */.R.ArrowLeft
            }):
                return e.preventDefault(), e.stopPropagation(), t.actions.goToOption({
                    focus: calculate_active_index/* Focus */.T.Previous
                });
            case keyboard/* Keys */.R.Home:
            case keyboard/* Keys */.R.PageUp:
                return e.preventDefault(), e.stopPropagation(), t.actions.goToOption({
                    focus: calculate_active_index/* Focus */.T.First
                });
            case keyboard/* Keys */.R.End:
            case keyboard/* Keys */.R.PageDown:
                return e.preventDefault(), e.stopPropagation(), t.actions.goToOption({
                    focus: calculate_active_index/* Focus */.T.Last
                });
            case keyboard/* Keys */.R.Escape:
                e.preventDefault(), e.stopPropagation(), (0,react_dom.flushSync)(()=>t.actions.closeListbox()), (Q = t.state.buttonElement) == null || Q.focus({
                    preventScroll: !0
                });
                return;
            case keyboard/* Keys */.R.Tab:
                e.preventDefault(), e.stopPropagation(), (0,react_dom.flushSync)(()=>t.actions.closeListbox()), (0,focus_management/* focusFrom */.EO)(t.state.buttonElement, e.shiftKey ? focus_management/* Focus */.TO.Previous : focus_management/* Focus */.TO.Next);
                break;
            default:
                e.key.length === 1 && (t.actions.search(e.key), w.setTimeout(()=>t.actions.clearSearch(), 350));
                break;
        }
    }), g = (0,react_glue/* useSlice */.M)(t, (e)=>{
        var A;
        return (A = e.buttonElement) == null ? void 0 : A.id;
    }), J = (0,use_slot/* useSlot */.x)({
        open: s === listbox_machine_F.Open
    }), Pe = (0,render/* mergeProps */.dG)(n ? te() : {}, {
        id: u,
        ref: o,
        "aria-activedescendant": (0,react_glue/* useSlice */.M)(t, t.selectors.activeDescendantId),
        "aria-multiselectable": l.mode === listbox_machine_C.Multi ? !0 : void 0,
        "aria-labelledby": g,
        "aria-orientation": l.orientation,
        onKeyDown: se,
        role: "listbox",
        tabIndex: s === listbox_machine_F.Open ? 0 : void 0,
        style: {
            ...m.style,
            ...j,
            "--button-width": (0,use_element_size/* useElementSize */.h)(f, F, !0).width
        },
        ...(0,use_transition/* transitionDataAttributes */.X)(U)
    }), ge = (0,render/* useRender */.L6)(), ve = (0,react.useMemo)(()=>l.mode === listbox_machine_C.Multi ? l : {
            ...l,
            isSelected: G
        }, [
        l,
        G
    ]);
    return /*#__PURE__*/ react.createElement(portal/* Portal */.h_, {
        enabled: a ? b.static || f : !1,
        ownerDocument: C
    }, /*#__PURE__*/ react.createElement(ie.Provider, {
        value: ve
    }, ge({
        ourProps: Pe,
        theirProps: m,
        slot: J,
        defaultTag: Rt,
        features: At,
        visible: r,
        name: "Listbox.Options"
    })));
}
let St = "div";
function _t(b, E) {
    let y = (0,react.useId)(), { id: u = "headlessui-listbox-option-".concat(y), disabled: p = !1, value: a, ..._ } = b, i = (0,react.useContext)(Le) === !0, m = ee("Listbox.Option"), n = listbox_machine_glue_p("Listbox.Option"), x = (0,react_glue/* useSlice */.M)(n, (r)=>n.selectors.isActive(r, u)), O = m.isSelected(a), l = (0,react.useRef)(null), t = (0,use_text_value/* useTextValue */.x)(l), s = (0,use_latest_value/* useLatestValue */.E)({
        disabled: p,
        value: a,
        domRef: l,
        get textValue () {
            return t();
        }
    }), F = (0,use_sync_refs/* useSyncRefs */.T)(E, l, (r)=>{
        r ? m.listRef.current.set(u, r) : m.listRef.current.delete(u);
    }), h = (0,react_glue/* useSlice */.M)(n, (r)=>n.selectors.shouldScrollIntoView(r, u));
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        if (h) return (0,disposables/* disposables */.k)().requestAnimationFrame(()=>{
            var r, P;
            (P = (r = l.current) == null ? void 0 : r.scrollIntoView) == null || P.call(r, {
                block: "nearest"
            });
        });
    }, [
        h,
        l
    ]), (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        if (!i) return n.actions.registerOption(u, s), ()=>n.actions.unregisterOption(u);
    }, [
        s,
        u,
        i
    ]);
    let k = (0,use_event/* useEvent */.z)((r)=>{
        var P;
        if (p) return r.preventDefault();
        n.actions.onChange(a), m.mode === listbox_machine_C.Single && ((0,react_dom.flushSync)(()=>n.actions.closeListbox()), (P = n.state.buttonElement) == null || P.focus({
            preventScroll: !0
        }));
    }), C = (0,use_event/* useEvent */.z)(()=>{
        if (p) return n.actions.goToOption({
            focus: calculate_active_index/* Focus */.T.Nothing
        });
        n.actions.goToOption({
            focus: calculate_active_index/* Focus */.T.Specific,
            id: u
        });
    }), c = (0,use_tracked_pointer/* useTrackedPointer */.g)(), L = (0,use_event/* useEvent */.z)((r)=>c.update(r)), f = (0,use_event/* useEvent */.z)((r)=>{
        c.wasMoved(r) && (p || x && n.state.activationTrigger === P.Pointer || n.actions.goToOption({
            focus: calculate_active_index/* Focus */.T.Specific,
            id: u
        }, P.Pointer));
    }), U = (0,use_event/* useEvent */.z)((r)=>{
        c.wasMoved(r) && (p || x && n.state.activationTrigger === P.Pointer && n.actions.goToOption({
            focus: calculate_active_index/* Focus */.T.Nothing
        }));
    }), H = (0,use_slot/* useSlot */.x)({
        active: x,
        focus: x,
        selected: O,
        disabled: p,
        selectedOption: O && i
    }), B = i ? {} : {
        id: u,
        ref: F,
        role: "option",
        tabIndex: p === !0 ? void 0 : -1,
        "aria-disabled": p === !0 ? !0 : void 0,
        "aria-selected": O,
        disabled: void 0,
        onClick: k,
        onFocus: C,
        onPointerEnter: L,
        onMouseEnter: L,
        onPointerMove: f,
        onMouseMove: f,
        onPointerLeave: U,
        onMouseLeave: U
    }, V = (0,render/* useRender */.L6)();
    return !O && i ? null : V({
        ourProps: B,
        theirProps: _,
        slot: H,
        defaultTag: St,
        name: "Listbox.Option"
    });
}
let Ft = react.Fragment;
function Ct(b, E) {
    let { options: y, placeholder: u, ...p } = b, _ = {
        ref: (0,use_sync_refs/* useSyncRefs */.T)(E)
    }, i = ee("ListboxSelectedOption"), m = (0,use_slot/* useSlot */.x)({}), n = i.value === void 0 || i.value === null || i.mode === listbox_machine_C.Multi && Array.isArray(i.value) && i.value.length === 0, x = (0,render/* useRender */.L6)();
    return /*#__PURE__*/ react.createElement(Le.Provider, {
        value: !0
    }, x({
        ourProps: _,
        theirProps: {
            ...p,
            children: /*#__PURE__*/ react.createElement(react.Fragment, null, u && n ? u : y)
        },
        slot: m,
        defaultTag: Ft,
        name: "ListboxSelectedOption"
    }));
}
let Mt = (0,render/* forwardRefWithAs */.yV)(vt), wt = (0,render/* forwardRefWithAs */.yV)(ht), Bt = label/* Label */.__, It = (0,render/* forwardRefWithAs */.yV)(Dt), kt = (0,render/* forwardRefWithAs */.yV)(_t), Ut = (0,render/* forwardRefWithAs */.yV)(Ct), Bo = Object.assign(Mt, {
    Button: wt,
    Label: Bt,
    Options: It,
    Option: kt,
    SelectedOption: Ut
});


// EXTERNAL MODULE: ../../node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/icons/check.js
var check = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/icons/check.js");
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/components/select.js
/* __next_internal_client_entry_do_not_use__ Select auto */ 





const Select = (t0)=>{
    const $ = (0,dist.c)(18);
    const { options, onChange, selectedOption, value, title, className, anchor: t1 } = t0;
    let t2;
    if ($[0] !== t1) {
        t2 = t1 === void 0 ? {
            to: "top start",
            gap: 10
        } : t1;
        $[0] = t1;
        $[1] = t2;
    } else {
        t2 = $[1];
    }
    const anchor = t2;
    let t3;
    if ($[2] !== className) {
        t3 = (t42)=>{
            const { hover, open, focus } = t42;
            return (0,clsx/* default */.Z)("x:cursor-pointer", "x:h-7 x:rounded-md x:px-2 x:text-xs x:font-medium x:transition-colors", open ? "x:bg-gray-200 x:text-gray-900 x:dark:bg-primary-100/10 x:dark:text-gray-50" : hover ? "x:bg-gray-200 x:text-gray-900 x:dark:bg-primary-100/5 x:dark:text-gray-50" : "x:text-gray-600 x:dark:text-gray-400", focus && "x:nextra-focus", className);
        };
        $[2] = className;
        $[3] = t3;
    } else {
        t3 = $[3];
    }
    let t4;
    if ($[4] !== selectedOption || $[5] !== t3 || $[6] !== title) {
        t4 = /* @__PURE__ */ (0,jsx_runtime.jsx)(wt, {
            title,
            className: t3,
            children: selectedOption
        });
        $[4] = selectedOption;
        $[5] = t3;
        $[6] = title;
        $[7] = t4;
    } else {
        t4 = $[7];
    }
    let t5;
    if ($[8] !== options) {
        t5 = options.map(_temp2);
        $[8] = options;
        $[9] = t5;
    } else {
        t5 = $[9];
    }
    let t6;
    if ($[10] !== anchor || $[11] !== t5) {
        t6 = /* @__PURE__ */ (0,jsx_runtime.jsx)(It, {
            as: "ul",
            transition: true,
            anchor,
            className: _temp,
            children: t5
        });
        $[10] = anchor;
        $[11] = t5;
        $[12] = t6;
    } else {
        t6 = $[12];
    }
    let t7;
    if ($[13] !== onChange || $[14] !== t4 || $[15] !== t6 || $[16] !== value) {
        t7 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(Bo, {
            value,
            onChange,
            children: [
                t4,
                t6
            ]
        });
        $[13] = onChange;
        $[14] = t4;
        $[15] = t6;
        $[16] = value;
        $[17] = t7;
    } else {
        t7 = $[17];
    }
    return t7;
};
function _temp(t0) {
    const { open: open_0 } = t0;
    return (0,clsx/* default */.Z)("x:focus-visible:nextra-focus", open_0 ? "x:opacity-100" : "x:opacity-0", "x:motion-reduce:transition-none x:transition-opacity x:min-w-(--button-width) x:z-30 x:max-h-64 x:rounded-md x:border x:border-black/5 x:backdrop-blur-md x:bg-nextra-bg/70 x:py-1 x:text-sm x:shadow-lg x:dark:border-white/20");
}
function _temp2(option) {
    return /* @__PURE__ */ (0,jsx_runtime.jsx)(kt, {
        value: option.id,
        as: react.Fragment,
        children: (t0)=>{
            const { selected, focus: focus_0 } = t0;
            return /* @__PURE__ */ (0,jsx_runtime.jsxs)("li", {
                className: (0,clsx/* default */.Z)(focus_0 ? "x:bg-primary-100 x:text-primary-800 x:dark:text-primary-500 x:dark:bg-primary-500/10" : "x:text-gray-800 x:dark:text-gray-100", "x:cursor-pointer x:whitespace-nowrap x:py-1.5 x:px-3", "x:transition-colors", selected && "x:flex x:items-center x:justify-between x:gap-3"),
                children: [
                    option.name,
                    selected && /* @__PURE__ */ (0,jsx_runtime.jsx)(check/* ReactComponent */.r, {
                        height: "1em"
                    })
                ]
            });
        }
    }, option.id);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/components/skip-nav/index.client.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SkipNavLink: function() { return /* binding */ SkipNavLink; }
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _barrel_optimize_names_Button_headlessui_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/button/button.js");
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
/* __next_internal_client_entry_do_not_use__ SkipNavLink auto */ 



const DEFAULT_ID = "nextra-skip-nav";
const DEFAULT_LABEL = "Skip to Content";
const SkipNavLink = (t0)=>{
    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(6);
    const { className, id: t1, children: t2 } = t0;
    const id = t1 === void 0 ? DEFAULT_ID : t1;
    const children = t2 === void 0 ? DEFAULT_LABEL : t2;
    const t3 = "#".concat(id);
    let t4;
    if ($[0] !== className) {
        t4 = (t52)=>{
            const { focus } = t52;
            return (0,clsx__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)("nextra-skip-nav", focus ? "x:nextra-focus x:fixed x:z-50 x:my-3 x:mx-4 x:rounded-lg x:px-3 x:py-2 x:text-sm x:font-bold x:bg-nextra-bg x:border x:border-current" : "x:sr-only", className);
        };
        $[0] = className;
        $[1] = t4;
    } else {
        t4 = $[1];
    }
    let t5;
    if ($[2] !== children || $[3] !== t3 || $[4] !== t4) {
        t5 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_barrel_optimize_names_Button_headlessui_react__WEBPACK_IMPORTED_MODULE_3__/* .Button */ .z, {
            as: "a",
            href: t3,
            className: t4,
            children
        });
        $[2] = children;
        $[3] = t3;
        $[4] = t4;
        $[5] = t5;
    } else {
        t5 = $[5];
    }
    return t5;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/components/tabs/index.client.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Tab: function() { return /* binding */ Tab; },
  Tabs: function() { return /* binding */ Tabs; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/@react-aria/focus/dist/useFocusRing.mjs + 8 modules
var useFocusRing = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/focus/dist/useFocusRing.mjs");
// EXTERNAL MODULE: ../../node_modules/@react-aria/interactions/dist/useHover.mjs
var useHover = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/interactions/dist/useHover.mjs");
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-active-press.js
var use_active_press = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-active-press.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-event.js
var use_event = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var use_iso_morphic_effect = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js
var use_latest_value = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
var use_resolve_button_type = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-slot.js
var use_slot = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-slot.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var use_sync_refs = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-is-mounted.js


function f() {
    let e = (0,react.useRef)(!1);
    return (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>(e.current = !0, ()=>{
            e.current = !1;
        }), []), e;
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/hidden.js
var internal_hidden = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/hidden.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/internal/focus-sentinel.js



function focus_sentinel_b(param) {
    let { onFocus: n } = param;
    let [r, o] = (0,react.useState)(!0), u = f();
    return r ? /*#__PURE__*/ react.createElement(internal_hidden/* Hidden */._, {
        as: "button",
        type: "button",
        features: internal_hidden/* HiddenFeatures */.x.Focusable,
        onFocus: (a)=>{
            a.preventDefault();
            let e, i = 50;
            function t() {
                if (i-- <= 0) {
                    e && cancelAnimationFrame(e);
                    return;
                }
                if (n()) {
                    if (cancelAnimationFrame(e), !u.current) return;
                    o(!1);
                    return;
                }
                e = requestAnimationFrame(t);
            }
            e = requestAnimationFrame(t);
        }
    }) : null;
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/focus-management.js
var focus_management = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/focus-management.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/match.js
var match = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/match.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/micro-task.js
var micro_task = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/micro-task.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/owner.js
var owner = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/owner.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/render.js + 1 modules
var render = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/render.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/utils/stable-collection.js

const s = /*#__PURE__*/ react.createContext(null);
function a() {
    return {
        groups: new Map,
        get (o, e) {
            var i;
            let t = this.groups.get(o);
            t || (t = new Map, this.groups.set(o, t));
            let n = (i = t.get(e)) != null ? i : 0;
            t.set(e, n + 1);
            let r = Array.from(t.keys()).indexOf(e);
            function u() {
                let c = t.get(e);
                c > 1 ? t.set(e, c - 1) : t.delete(e);
            }
            return [
                r,
                u
            ];
        }
    };
}
function stable_collection_f(param) {
    let { children: o } = param;
    let e = react.useRef(a());
    return /*#__PURE__*/ react.createElement(s.Provider, {
        value: e
    }, o);
}
function stable_collection_C(o) {
    let e = react.useContext(s);
    if (!e) throw new Error("You must wrap your component in a <StableCollection>");
    let t = react.useId(), [n, r] = e.current.get(o, t);
    return react.useEffect(()=>r, []), n;
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/keyboard.js
var keyboard = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/keyboard.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/components/tabs/tabs.js
/* __next_internal_client_entry_do_not_use__ Tab,TabGroup,TabList,TabPanel,TabPanels auto */ 



















var _e = ((t)=>(t[t.Forwards = 0] = "Forwards", t[t.Backwards = 1] = "Backwards", t))(_e || {}), Se = ((l)=>(l[l.Less = -1] = "Less", l[l.Equal = 0] = "Equal", l[l.Greater = 1] = "Greater", l))(Se || {}), De = ((n)=>(n[n.SetSelectedIndex = 0] = "SetSelectedIndex", n[n.RegisterTab = 1] = "RegisterTab", n[n.UnregisterTab = 2] = "UnregisterTab", n[n.RegisterPanel = 3] = "RegisterPanel", n[n.UnregisterPanel = 4] = "UnregisterPanel", n))(De || {});
let Fe = {
    [0] (e, r) {
        var d;
        let t = (0,focus_management/* sortByDomNode */.z2)(e.tabs, (u)=>u.current), l = (0,focus_management/* sortByDomNode */.z2)(e.panels, (u)=>u.current), a = t.filter((u)=>{
            var T;
            return !((T = u.current) != null && T.hasAttribute("disabled"));
        }), n = {
            ...e,
            tabs: t,
            panels: l
        };
        if (r.index < 0 || r.index > t.length - 1) {
            let u = (0,match/* match */.E)(Math.sign(r.index - e.selectedIndex), {
                [-1]: ()=>1,
                [0]: ()=>(0,match/* match */.E)(Math.sign(r.index), {
                        [-1]: ()=>0,
                        [0]: ()=>0,
                        [1]: ()=>1
                    }),
                [1]: ()=>0
            });
            if (a.length === 0) return n;
            let T = (0,match/* match */.E)(u, {
                [0]: ()=>t.indexOf(a[0]),
                [1]: ()=>t.indexOf(a[a.length - 1])
            });
            return {
                ...n,
                selectedIndex: T === -1 ? e.selectedIndex : T
            };
        }
        let s = t.slice(0, r.index), f = [
            ...t.slice(r.index),
            ...s
        ].find((u)=>a.includes(u));
        if (!f) return n;
        let b = (d = t.indexOf(f)) != null ? d : e.selectedIndex;
        return b === -1 && (b = e.selectedIndex), {
            ...n,
            selectedIndex: b
        };
    },
    [1] (e, r) {
        if (e.tabs.includes(r.tab)) return e;
        let t = e.tabs[e.selectedIndex], l = (0,focus_management/* sortByDomNode */.z2)([
            ...e.tabs,
            r.tab
        ], (n)=>n.current), a = e.selectedIndex;
        return e.info.current.isControlled || (a = l.indexOf(t), a === -1 && (a = e.selectedIndex)), {
            ...e,
            tabs: l,
            selectedIndex: a
        };
    },
    [2] (e, r) {
        return {
            ...e,
            tabs: e.tabs.filter((t)=>t !== r.tab)
        };
    },
    [3] (e, r) {
        return e.panels.includes(r.panel) ? e : {
            ...e,
            panels: (0,focus_management/* sortByDomNode */.z2)([
                ...e.panels,
                r.panel
            ], (t)=>t.current)
        };
    },
    [4] (e, r) {
        return {
            ...e,
            panels: e.panels.filter((t)=>t !== r.panel)
        };
    }
}, V = /*#__PURE__*/ (0,react.createContext)(null);
V.displayName = "TabsDataContext";
function h(e) {
    let r = (0,react.useContext)(V);
    if (r === null) {
        let t = new Error("<".concat(e, " /> is missing a parent <Tab.Group /> component."));
        throw Error.captureStackTrace && Error.captureStackTrace(t, h), t;
    }
    return r;
}
let Q = /*#__PURE__*/ (0,react.createContext)(null);
Q.displayName = "TabsActionsContext";
function Y(e) {
    let r = (0,react.useContext)(Q);
    if (r === null) {
        let t = new Error("<".concat(e, " /> is missing a parent <Tab.Group /> component."));
        throw Error.captureStackTrace && Error.captureStackTrace(t, Y), t;
    }
    return r;
}
function Ie(e, r) {
    return (0,match/* match */.E)(r.type, Fe, e, r);
}
let he = "div";
function ve(e, r) {
    let { defaultIndex: t = 0, vertical: l = !1, manual: a = !1, onChange: n, selectedIndex: s = null, ...g } = e;
    const f = l ? "vertical" : "horizontal", b = a ? "manual" : "auto";
    let d = s !== null, u = (0,use_latest_value/* useLatestValue */.E)({
        isControlled: d
    }), T = (0,use_sync_refs/* useSyncRefs */.T)(r), [p, c] = (0,react.useReducer)(Ie, {
        info: u,
        selectedIndex: s != null ? s : t,
        tabs: [],
        panels: []
    }), v = (0,use_slot/* useSlot */.x)({
        selectedIndex: p.selectedIndex
    }), m = (0,use_latest_value/* useLatestValue */.E)(n || (()=>{})), C = (0,use_latest_value/* useLatestValue */.E)(p.tabs), D = (0,react.useMemo)(()=>({
            orientation: f,
            activation: b,
            ...p
        }), [
        f,
        b,
        p
    ]), P = (0,use_event/* useEvent */.z)((i)=>(c({
            type: 1,
            tab: i
        }), ()=>c({
                type: 2,
                tab: i
            }))), R = (0,use_event/* useEvent */.z)((i)=>(c({
            type: 3,
            panel: i
        }), ()=>c({
                type: 4,
                panel: i
            }))), A = (0,use_event/* useEvent */.z)((i)=>{
        L.current !== i && m.current(i), d || c({
            type: 0,
            index: i
        });
    }), L = (0,use_latest_value/* useLatestValue */.E)(d ? e.selectedIndex : p.selectedIndex), _ = (0,react.useMemo)(()=>({
            registerTab: P,
            registerPanel: R,
            change: A
        }), []);
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        c({
            type: 0,
            index: s != null ? s : t
        });
    }, [
        s
    ]), (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        if (L.current === void 0 || p.tabs.length <= 0) return;
        let i = (0,focus_management/* sortByDomNode */.z2)(p.tabs, (S)=>S.current);
        i.some((S, X)=>p.tabs[X] !== S) && A(i.indexOf(p.tabs[L.current]));
    });
    let K = {
        ref: T
    }, J = (0,render/* useRender */.L6)();
    return /*#__PURE__*/ react.createElement(stable_collection_f, null, /*#__PURE__*/ react.createElement(Q.Provider, {
        value: _
    }, /*#__PURE__*/ react.createElement(V.Provider, {
        value: D
    }, D.tabs.length <= 0 && /*#__PURE__*/ react.createElement(focus_sentinel_b, {
        onFocus: ()=>{
            var i, M;
            for (let S of C.current)if (((i = S.current) == null ? void 0 : i.tabIndex) === 0) return (M = S.current) == null || M.focus(), !0;
            return !1;
        }
    }), J({
        ourProps: K,
        theirProps: g,
        slot: v,
        defaultTag: he,
        name: "Tabs"
    }))));
}
let Ce = "div";
function Me(e, r) {
    let { orientation: t, selectedIndex: l } = h("Tab.List"), a = (0,use_sync_refs/* useSyncRefs */.T)(r), n = (0,use_slot/* useSlot */.x)({
        selectedIndex: l
    }), s = e, g = {
        ref: a,
        role: "tablist",
        "aria-orientation": t
    };
    return (0,render/* useRender */.L6)()({
        ourProps: g,
        theirProps: s,
        slot: n,
        defaultTag: Ce,
        name: "Tabs.List"
    });
}
let Ge = "button";
function Ue(e, r) {
    var Z, ee;
    let t = (0,react.useId)(), { id: l = "headlessui-tabs-tab-".concat(t), disabled: a = !1, autoFocus: n = !1, ...s } = e, { orientation: g, activation: f, selectedIndex: b, tabs: d, panels: u } = h("Tab"), T = Y("Tab"), p = h("Tab"), [c, v] = (0,react.useState)(null), m = (0,react.useRef)(null), C = (0,use_sync_refs/* useSyncRefs */.T)(m, r, v);
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>T.registerTab(m), [
        T,
        m
    ]);
    let D = stable_collection_C("tabs"), P = d.indexOf(m);
    P === -1 && (P = D);
    let R = P === b, A = (0,use_event/* useEvent */.z)((o)=>{
        var $;
        let E = o();
        if (E === focus_management/* FocusResult */.fE.Success && f === "auto") {
            let q = ($ = (0,owner/* getOwnerDocument */.r)(m)) == null ? void 0 : $.activeElement, te = p.tabs.findIndex((be)=>be.current === q);
            te !== -1 && T.change(te);
        }
        return E;
    }), L = (0,use_event/* useEvent */.z)((o)=>{
        let E = d.map((q)=>q.current).filter(Boolean);
        if (o.key === keyboard/* Keys */.R.Space || o.key === keyboard/* Keys */.R.Enter) {
            o.preventDefault(), o.stopPropagation(), T.change(P);
            return;
        }
        switch(o.key){
            case keyboard/* Keys */.R.Home:
            case keyboard/* Keys */.R.PageUp:
                return o.preventDefault(), o.stopPropagation(), A(()=>(0,focus_management/* focusIn */.jA)(E, focus_management/* Focus */.TO.First));
            case keyboard/* Keys */.R.End:
            case keyboard/* Keys */.R.PageDown:
                return o.preventDefault(), o.stopPropagation(), A(()=>(0,focus_management/* focusIn */.jA)(E, focus_management/* Focus */.TO.Last));
        }
        if (A(()=>(0,match/* match */.E)(g, {
                vertical () {
                    return o.key === keyboard/* Keys */.R.ArrowUp ? (0,focus_management/* focusIn */.jA)(E, focus_management/* Focus */.TO.Previous | focus_management/* Focus */.TO.WrapAround) : o.key === keyboard/* Keys */.R.ArrowDown ? (0,focus_management/* focusIn */.jA)(E, focus_management/* Focus */.TO.Next | focus_management/* Focus */.TO.WrapAround) : focus_management/* FocusResult */.fE.Error;
                },
                horizontal () {
                    return o.key === keyboard/* Keys */.R.ArrowLeft ? (0,focus_management/* focusIn */.jA)(E, focus_management/* Focus */.TO.Previous | focus_management/* Focus */.TO.WrapAround) : o.key === keyboard/* Keys */.R.ArrowRight ? (0,focus_management/* focusIn */.jA)(E, focus_management/* Focus */.TO.Next | focus_management/* Focus */.TO.WrapAround) : focus_management/* FocusResult */.fE.Error;
                }
            })) === focus_management/* FocusResult */.fE.Success) return o.preventDefault();
    }), _ = (0,react.useRef)(!1), K = (0,use_event/* useEvent */.z)(()=>{
        var o;
        _.current || (_.current = !0, (o = m.current) == null || o.focus({
            preventScroll: !0
        }), T.change(P), (0,micro_task/* microTask */.Y)(()=>{
            _.current = !1;
        }));
    }), J = (0,use_event/* useEvent */.z)((o)=>{
        o.preventDefault();
    }), { isFocusVisible: i, focusProps: M } = (0,useFocusRing/* useFocusRing */.F)({
        autoFocus: n
    }), { isHovered: S, hoverProps: X } = (0,useHover/* useHover */.X)({
        isDisabled: a
    }), { pressed: ue, pressProps: Te } = (0,use_active_press/* useActivePress */.x)({
        disabled: a
    }), de = (0,use_slot/* useSlot */.x)({
        selected: R,
        hover: S,
        active: ue,
        focus: i,
        autofocus: n,
        disabled: a
    }), ce = (0,render/* mergeProps */.dG)({
        ref: C,
        onKeyDown: L,
        onMouseDown: J,
        onClick: K,
        id: l,
        role: "tab",
        type: (0,use_resolve_button_type/* useResolveButtonType */.f)(e, c),
        "aria-controls": (ee = (Z = u[P]) == null ? void 0 : Z.current) == null ? void 0 : ee.id,
        "aria-selected": R,
        tabIndex: R ? 0 : -1,
        disabled: a || void 0,
        autoFocus: n
    }, M, X, Te);
    return (0,render/* useRender */.L6)()({
        ourProps: ce,
        theirProps: s,
        slot: de,
        defaultTag: Ge,
        name: "Tabs.Tab"
    });
}
let He = "div";
function we(e, r) {
    let { selectedIndex: t } = h("Tab.Panels"), l = (0,use_sync_refs/* useSyncRefs */.T)(r), a = (0,use_slot/* useSlot */.x)({
        selectedIndex: t
    }), n = e, s = {
        ref: l
    };
    return (0,render/* useRender */.L6)()({
        ourProps: s,
        theirProps: n,
        slot: a,
        defaultTag: He,
        name: "Tabs.Panels"
    });
}
let Oe = "div", Ne = render/* RenderFeatures */.VN.RenderStrategy | render/* RenderFeatures */.VN.Static;
function ke(e, r) {
    var R, A, L, _;
    let t = (0,react.useId)(), { id: l = "headlessui-tabs-panel-".concat(t), tabIndex: a = 0, ...n } = e, { selectedIndex: s, tabs: g, panels: f } = h("Tab.Panel"), b = Y("Tab.Panel"), d = (0,react.useRef)(null), u = (0,use_sync_refs/* useSyncRefs */.T)(d, r);
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>b.registerPanel(d), [
        b,
        d
    ]);
    let T = stable_collection_C("panels"), p = f.indexOf(d);
    p === -1 && (p = T);
    let c = p === s, { isFocusVisible: v, focusProps: m } = (0,useFocusRing/* useFocusRing */.F)(), C = (0,use_slot/* useSlot */.x)({
        selected: c,
        focus: v
    }), D = (0,render/* mergeProps */.dG)({
        ref: u,
        id: l,
        role: "tabpanel",
        "aria-labelledby": (A = (R = g[p]) == null ? void 0 : R.current) == null ? void 0 : A.id,
        tabIndex: c ? a : -1
    }, m), P = (0,render/* useRender */.L6)();
    return !c && ((L = n.unmount) == null || L) && !((_ = n.static) != null && _) ? /*#__PURE__*/ react.createElement(internal_hidden/* Hidden */._, {
        "aria-hidden": "true",
        ...D
    }) : P({
        ourProps: D,
        theirProps: n,
        slot: C,
        defaultTag: Oe,
        features: Ne,
        visible: c,
        name: "Tabs.Panel"
    });
}
let Be = (0,render/* forwardRefWithAs */.yV)(Ue), We = (0,render/* forwardRefWithAs */.yV)(ve), je = (0,render/* forwardRefWithAs */.yV)(Me), Ke = (0,render/* forwardRefWithAs */.yV)(we), Je = (0,render/* forwardRefWithAs */.yV)(ke), ct = Object.assign(Be, {
    Group: We,
    List: je,
    Panels: Ke,
    Panel: Je
});


// EXTERNAL MODULE: ../../node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/hooks/use-hash.js
var use_hash = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-hash.js");
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/components/tabs/index.client.js
/* __next_internal_client_entry_do_not_use__ Tab,Tabs auto */ 





function isTabObjectItem(item) {
    return !!item && typeof item === "object" && "label" in item;
}
const Tabs = (t0)=>{
    const $ = (0,dist.c)(30);
    const { items, children, storageKey, defaultIndex: t1, selectedIndex: _selectedIndex, onChange, className, tabClassName } = t0;
    const defaultIndex = t1 === void 0 ? 0 : t1;
    const [selectedIndex, setSelectedIndex] = (0,react.useState)(defaultIndex);
    const hash = (0,use_hash.useHash)();
    const tabPanelsRef = (0,react.useRef)(null);
    let t2;
    let t3;
    if ($[0] !== _selectedIndex) {
        t2 = ()=>{
            if (_selectedIndex !== void 0) {
                setSelectedIndex(_selectedIndex);
            }
        };
        t3 = [
            _selectedIndex
        ];
        $[0] = _selectedIndex;
        $[1] = t2;
        $[2] = t3;
    } else {
        t2 = $[1];
        t3 = $[2];
    }
    (0,react.useEffect)(t2, t3);
    let t4;
    let t5;
    if ($[3] !== hash) {
        t4 = ()=>{
            if (!hash) {
                return;
            }
            const tabPanel = tabPanelsRef.current.querySelector('[role=tabpanel]:has([id="'.concat(hash, '"])'));
            if (!tabPanel) {
                return;
            }
            for (const [index, el] of Object.entries(tabPanelsRef.current.children)){
                if (el === tabPanel) {
                    setSelectedIndex(Number(index));
                    location.hash = "";
                    requestAnimationFrame(()=>{
                        location.hash = "#".concat(hash);
                    });
                }
            }
        };
        t5 = [
            hash
        ];
        $[3] = hash;
        $[4] = t4;
        $[5] = t5;
    } else {
        t4 = $[4];
        t5 = $[5];
    }
    (0,react.useEffect)(t4, t5);
    let t6;
    if ($[6] !== storageKey) {
        t6 = ()=>{
            if (!storageKey) {
                return;
            }
            const fn = function fn2(event) {
                if (event.key === storageKey) {
                    setSelectedIndex(Number(event.newValue));
                }
            };
            const index_0 = Number(localStorage.getItem(storageKey));
            setSelectedIndex(Number.isNaN(index_0) ? 0 : index_0);
            window.addEventListener("storage", fn);
            return ()=>{
                window.removeEventListener("storage", fn);
            };
        };
        $[6] = storageKey;
        $[7] = t6;
    } else {
        t6 = $[7];
    }
    let t7;
    if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
        t7 = [];
        $[8] = t7;
    } else {
        t7 = $[8];
    }
    (0,react.useEffect)(t6, t7);
    let t8;
    if ($[9] !== onChange || $[10] !== storageKey) {
        t8 = (index_1)=>{
            if (storageKey) {
                const newValue = String(index_1);
                localStorage.setItem(storageKey, newValue);
                window.dispatchEvent(new StorageEvent("storage", {
                    key: storageKey,
                    newValue
                }));
                return;
            }
            setSelectedIndex(index_1);
            onChange === null || onChange === void 0 ? void 0 : onChange(index_1);
        };
        $[9] = onChange;
        $[10] = storageKey;
        $[11] = t8;
    } else {
        t8 = $[11];
    }
    const handleChange = t8;
    let t9;
    if ($[12] !== className) {
        t9 = (args)=>(0,clsx/* default */.Z)("nextra-scrollbar x:overflow-x-auto x:overscroll-x-contain x:overflow-y-hidden", "x:mt-4 x:flex x:w-full x:gap-2 x:border-b x:border-gray-200 x:pb-px x:dark:border-neutral-800", "x:focus-visible:nextra-focus", typeof className === "function" ? className(args) : className);
        $[12] = className;
        $[13] = t9;
    } else {
        t9 = $[13];
    }
    let t10;
    if ($[14] !== items || $[15] !== tabClassName) {
        let t112;
        if ($[17] !== tabClassName) {
            t112 = (item, index_2)=>/* @__PURE__ */ (0,jsx_runtime.jsx)(ct, {
                    disabled: isTabObjectItem(item) && item.disabled,
                    className: (args_0)=>{
                        const { selected, disabled, hover, focus } = args_0;
                        return (0,clsx/* default */.Z)(focus && "x:nextra-focus x:ring-inset", "x:whitespace-nowrap x:cursor-pointer", "x:rounded-t x:p-2 x:font-medium x:leading-5 x:transition-colors", "x:-mb-0.5 x:select-none x:border-b-2", selected ? "x:border-current x:outline-none" : hover ? "x:border-gray-200 x:dark:border-neutral-800" : "x:border-transparent", selected ? "x:text-primary-600" : disabled ? "x:text-gray-400 x:dark:text-neutral-600 x:pointer-events-none" : hover ? "x:text-black x:dark:text-white" : "x:text-gray-600 x:dark:text-gray-200", typeof tabClassName === "function" ? tabClassName(args_0) : tabClassName);
                    },
                    children: isTabObjectItem(item) ? item.label : item
                }, index_2);
            $[17] = tabClassName;
            $[18] = t112;
        } else {
            t112 = $[18];
        }
        t10 = items.map(t112);
        $[14] = items;
        $[15] = tabClassName;
        $[16] = t10;
    } else {
        t10 = $[16];
    }
    let t11;
    if ($[19] !== t10 || $[20] !== t9) {
        t11 = /* @__PURE__ */ (0,jsx_runtime.jsx)(je, {
            className: t9,
            children: t10
        });
        $[19] = t10;
        $[20] = t9;
        $[21] = t11;
    } else {
        t11 = $[21];
    }
    let t12;
    if ($[22] !== children) {
        t12 = /* @__PURE__ */ (0,jsx_runtime.jsx)(Ke, {
            ref: tabPanelsRef,
            children
        });
        $[22] = children;
        $[23] = t12;
    } else {
        t12 = $[23];
    }
    let t13;
    if ($[24] !== defaultIndex || $[25] !== handleChange || $[26] !== selectedIndex || $[27] !== t11 || $[28] !== t12) {
        t13 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(We, {
            selectedIndex,
            defaultIndex,
            onChange: handleChange,
            as: react.Fragment,
            children: [
                t11,
                t12
            ]
        });
        $[24] = defaultIndex;
        $[25] = handleChange;
        $[26] = selectedIndex;
        $[27] = t11;
        $[28] = t12;
        $[29] = t13;
    } else {
        t13 = $[29];
    }
    return t13;
};
const Tab = (t0)=>{
    const $ = (0,dist.c)(12);
    let children;
    let className;
    let props;
    let t1;
    if ($[0] !== t0) {
        ({ children, unmount: t1, className, ...props } = t0);
        $[0] = t0;
        $[1] = children;
        $[2] = className;
        $[3] = props;
        $[4] = t1;
    } else {
        children = $[1];
        className = $[2];
        props = $[3];
        t1 = $[4];
    }
    const unmount = t1 === void 0 ? false : t1;
    let t2;
    if ($[5] !== className) {
        t2 = (args)=>(0,clsx/* default */.Z)("x:rounded x:mt-[1.25em]", args.focus && "x:nextra-focus", typeof className === "function" ? className(args) : className);
        $[5] = className;
        $[6] = t2;
    } else {
        t2 = $[6];
    }
    let t3;
    if ($[7] !== children || $[8] !== props || $[9] !== t2 || $[10] !== unmount) {
        t3 = /* @__PURE__ */ (0,jsx_runtime.jsx)(Je, {
            ...props,
            unmount,
            className: t2,
            children
        });
        $[7] = children;
        $[8] = props;
        $[9] = t2;
        $[10] = unmount;
        $[11] = t3;
    } else {
        t3 = $[11];
    }
    return t3;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-copy.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useCopy: function() { return /* binding */ useCopy; }
/* harmony export */ });
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* __next_internal_client_entry_do_not_use__ useCopy auto */ 

function useCopy(t0) {
    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(10);
    let t1;
    if ($[0] !== t0) {
        t1 = t0 === void 0 ? {} : t0;
        $[0] = t0;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    const { timeout: t2 } = t1;
    const timeout = t2 === void 0 ? 2e3 : t2;
    const [isCopied, setCopied] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
    let t3;
    if ($[2] !== isCopied || $[3] !== timeout) {
        t3 = ()=>{
            if (!isCopied) {
                return;
            }
            const timerId = setTimeout(()=>{
                setCopied(false);
            }, timeout);
            return ()=>{
                clearTimeout(timerId);
            };
        };
        $[2] = isCopied;
        $[3] = timeout;
        $[4] = t3;
    } else {
        t3 = $[4];
    }
    let t4;
    if ($[5] !== isCopied) {
        t4 = [
            isCopied
        ];
        $[5] = isCopied;
        $[6] = t4;
    } else {
        t4 = $[6];
    }
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t3, t4);
    let t5;
    if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
        t5 = async function copy2(content) {
            setCopied(true);
            try {
                await navigator.clipboard.writeText(content);
            } catch (e) {
                console.error("Failed to copy!");
            }
        };
        $[7] = t5;
    } else {
        t5 = $[7];
    }
    const copy = t5;
    let t6;
    if ($[8] !== isCopied) {
        t6 = {
            copy,
            isCopied
        };
        $[8] = isCopied;
        $[9] = t6;
    } else {
        t6 = $[9];
    }
    return t6;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-fs-route.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useFSRoute: function() { return /* binding */ useFSRoute; }
/* harmony export */ });
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/api/navigation.js");
/* provided dependency */ var process = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js");
/* __next_internal_client_entry_do_not_use__ useFSRoute auto */ 

const defaultLocale = process.env.NEXTRA_DEFAULT_LOCALE;
function useFSRoute() {
    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(2);
    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.usePathname)();
    let t0;
    if ($[0] !== pathname) {
        t0 = ( true && defaultLocale ? "/" + pathname.split("/").slice(2).join("/") : pathname).replace(/\.html$/, "").replace(/\/index(\/|$)/, "$1").replace(/\/$/, "") || "/";
        $[0] = pathname;
        $[1] = t0;
    } else {
        t0 = $[1];
    }
    return t0;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-hash.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useHash: function() { return /* binding */ useHash; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* __next_internal_client_entry_do_not_use__ useHash auto */ "use no memo";

function useHash() {
    const [hash, setHash] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("");
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        function handleHashChange() {
            setHash(location.hash.replace("#", ""));
        }
        handleHashChange();
        window.addEventListener("hashchange", handleHashChange);
        return ()=>{
            window.removeEventListener("hashchange", handleHashChange);
        };
    }, []);
    return hash;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-mounted.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useMounted: function() { return /* binding */ useMounted; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* __next_internal_client_entry_do_not_use__ useMounted auto */ "use no memo";

function useMounted() {
    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        setMounted(true);
    }, []);
    return mounted;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/icons/arrow-right.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: function() { return /* binding */ SvgArrowRight; }
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__);


const SvgArrowRight = (props) => {
  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M9 5l7 7-7 7", strokeLinecap: "round", strokeLinejoin: "round" });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("svg", { viewBox: "0 0 24 24", stroke: "currentColor", fill: "none", strokeWidth: 2, ...props, children: t0 });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/icons/check.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: function() { return /* binding */ SvgCheck; }
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__);


const SvgCheck = (props) => {
  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("svg", { viewBox: "0 0 20 20", fill: "currentColor", ...props, children: t0 });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/icons/copy.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: function() { return /* binding */ SvgCopy; }
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__);


const SvgCopy = (props) => {
  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(4);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("rect", { x: 9, y: 9, width: 13, height: 13, rx: 2 });
    t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M5 15H4C2.89543 15 2 14.1046 2 13V4C2 2.89543 2.89543 2 4 2H13C14.1046 2 15 2.89543 15 4V5" });
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  let t2;
  if ($[2] !== props) {
    t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("svg", { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, ...props, children: [
      t0,
      t1
    ] });
    $[2] = props;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/icons/link-arrow.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: function() { return /* binding */ SvgLinkArrow; }
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__);


const SvgLinkArrow = (props) => {
  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(4);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M7 17L17 7" });
    t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M7 7h10v10" });
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  let t2;
  if ($[2] !== props) {
    t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("svg", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.7, viewBox: "0 0 24 24", ...props, children: [
      t0,
      t1
    ] });
    $[2] = props;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/mdx-components/anchor.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  e: function() { return /* binding */ Anchor; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ./node_modules/next/dist/api/link.js
var api_link = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/api/link.js");
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/server/constants.js
/* provided dependency */ var process = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js");
const MARKDOWN_EXTENSION_RE = /\.mdx?$/;
const CWD = process.cwd();
const MARKDOWN_URL_EXTENSION_RE = /\.mdx?(?:(?=[#?])|$)/;
const IS_PRODUCTION = (/* unused pure expression or super */ null && ("production" === "production"));
const EXTERNAL_URL_RE = /^https?:\/\//;
const DEFAULT_PROPERTY_PROPS = {
  type: "Property",
  kind: "init",
  method: false,
  shorthand: false,
  computed: false
};
const METADATA_ONLY_RQ = "?metadata";


// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/icons/link-arrow.js
var link_arrow = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/icons/link-arrow.js");
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/mdx-components/anchor.js






const Anchor = (t0) => {
  const $ = (0,dist.c)(23);
  let prefetch;
  let props;
  let t1;
  if ($[0] !== t0) {
    ({
      href: t1,
      prefetch,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = prefetch;
    $[2] = props;
    $[3] = t1;
  } else {
    prefetch = $[1];
    props = $[2];
    t1 = $[3];
  }
  const href = t1 === void 0 ? "" : t1;
  const t2 = props;
  let t3;
  if ($[4] !== props.className) {
    t3 = (0,clsx/* default */.Z)("x:focus-visible:nextra-focus", props.className);
    $[4] = props.className;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== props || $[7] !== t3) {
    t4 = {
      ...t2,
      className: t3
    };
    $[6] = props;
    $[7] = t3;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  props = t4;
  if (typeof href === "string") {
    if (href.startsWith("#")) {
      let t52;
      if ($[9] !== href || $[10] !== props) {
        t52 = /* @__PURE__ */ (0,jsx_runtime.jsx)("a", { href, ...props });
        $[9] = href;
        $[10] = props;
        $[11] = t52;
      } else {
        t52 = $[11];
      }
      return t52;
    }
    if (EXTERNAL_URL_RE.test(href)) {
      const {
        children
      } = props;
      let t52;
      if ($[12] !== children) {
        t52 = typeof children === "string" && /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [
          "\xA0",
          /* @__PURE__ */ (0,jsx_runtime.jsx)(link_arrow/* ReactComponent */.r, { height: "1em", className: "x:inline x:align-baseline x:shrink-0" })
        ] });
        $[12] = children;
        $[13] = t52;
      } else {
        t52 = $[13];
      }
      let t6;
      if ($[14] !== children || $[15] !== href || $[16] !== props || $[17] !== t52) {
        t6 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("a", { href, target: "_blank", rel: "noreferrer", ...props, children: [
          children,
          t52
        ] });
        $[14] = children;
        $[15] = href;
        $[16] = props;
        $[17] = t52;
        $[18] = t6;
      } else {
        t6 = $[18];
      }
      return t6;
    }
  }
  let t5;
  if ($[19] !== href || $[20] !== prefetch || $[21] !== props) {
    t5 = /* @__PURE__ */ (0,jsx_runtime.jsx)(api_link["default"], { href, prefetch, ...props });
    $[19] = href;
    $[20] = prefetch;
    $[21] = props;
    $[22] = t5;
  } else {
    t5 = $[22];
  }
  return t5;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/mdx-components/details.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Details: function() { return /* binding */ Details; }
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _components_collapse_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/components/collapse.js");
/* harmony import */ var _hooks_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-hash.js");
/* __next_internal_client_entry_do_not_use__ Details auto */ 





const Details = (t0)=>{
    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(26);
    let children;
    let className;
    let open;
    let props;
    if ($[0] !== t0) {
        ({ children, open, className, ...props } = t0);
        $[0] = t0;
        $[1] = children;
        $[2] = className;
        $[3] = open;
        $[4] = props;
    } else {
        children = $[1];
        className = $[2];
        open = $[3];
        props = $[4];
    }
    const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(!!open);
    const [delayedOpenState, setDelayedOpenState] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(isOpen);
    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(0);
    let t1;
    let t2;
    if ($[5] !== isOpen) {
        t1 = ()=>{
            const animation = animationRef.current;
            if (animation) {
                clearTimeout(animation);
                animationRef.current = 0;
            }
            if (!isOpen) {
                animationRef.current = window.setTimeout(()=>setDelayedOpenState(isOpen), 300);
                return ()=>{
                    clearTimeout(animationRef.current);
                };
            }
            setDelayedOpenState(true);
        };
        t2 = [
            isOpen
        ];
        $[5] = isOpen;
        $[6] = t1;
        $[7] = t2;
    } else {
        t1 = $[6];
        t2 = $[7];
    }
    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t1, t2);
    let t3;
    if ($[8] !== children) {
        t3 = findSummary(children, setIsOpen);
        $[8] = children;
        $[9] = t3;
    } else {
        t3 = $[9];
    }
    const [summaryElement, restChildren] = t3;
    const hash = (0,_hooks_index_js__WEBPACK_IMPORTED_MODULE_3__.useHash)();
    const detailsRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);
    let t4;
    let t5;
    if ($[10] !== hash) {
        t4 = ()=>{
            if (!hash) {
                return;
            }
            const elementWithHashId = detailsRef.current.querySelector('[id="'.concat(hash, '"]'));
            if (!elementWithHashId) {
                return;
            }
            setIsOpen(true);
        };
        t5 = [
            hash
        ];
        $[10] = hash;
        $[11] = t4;
        $[12] = t5;
    } else {
        t4 = $[11];
        t5 = $[12];
    }
    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(t4, t5);
    let t6;
    if ($[13] !== className) {
        t6 = (0,clsx__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)("x:not-first:mt-4 x:rounded x:border x:border-gray-200 x:bg-white x:p-2 x:shadow-sm x:dark:border-neutral-800 x:dark:bg-neutral-900", "x:overflow-hidden", className);
        $[13] = className;
        $[14] = t6;
    } else {
        t6 = $[14];
    }
    const t7 = isOpen || delayedOpenState;
    const t8 = isOpen ? "" : void 0;
    let t9;
    if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
        t9 = (0,clsx__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)("x:*:pt-2", "x:grid");
        $[15] = t9;
    } else {
        t9 = $[15];
    }
    let t10;
    if ($[16] !== isOpen || $[17] !== restChildren) {
        t10 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_collapse_js__WEBPACK_IMPORTED_MODULE_5__/* .Collapse */ .U, {
            isOpen,
            className: t9,
            children: restChildren
        });
        $[16] = isOpen;
        $[17] = restChildren;
        $[18] = t10;
    } else {
        t10 = $[18];
    }
    let t11;
    if ($[19] !== props || $[20] !== summaryElement || $[21] !== t10 || $[22] !== t6 || $[23] !== t7 || $[24] !== t8) {
        t11 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("details", {
            className: t6,
            ref: detailsRef,
            ...props,
            open: t7,
            "data-expanded": t8,
            children: [
                summaryElement,
                t10
            ]
        });
        $[19] = props;
        $[20] = summaryElement;
        $[21] = t10;
        $[22] = t6;
        $[23] = t7;
        $[24] = t8;
        $[25] = t11;
    } else {
        t11 = $[25];
    }
    return t11;
};
function findSummary(list, setIsOpen) {
    let summary;
    const rest = react__WEBPACK_IMPORTED_MODULE_2__.Children.map(list, (child)=>{
        if (!summary && // Add onClick only for first summary
        child && typeof child === "object" && "type" in child) {
            if (child.type === "summary") {
                summary = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.cloneElement)(child, {
                    // @ts-expect-error -- fixme
                    onClick (event) {
                        if (event.target.tagName !== "A") {
                            event.preventDefault();
                            setIsOpen((v)=>!v);
                        }
                    }
                });
                return;
            }
            if (child.type !== Details && child.props.children) {
                ;
                [summary, child] = findSummary(child.props.children, setIsOpen);
            }
        }
        return child;
    });
    return [
        summary,
        rest
    ];
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/mdx-components/pre/copy-to-clipboard.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CopyToClipboard: function() { return /* binding */ CopyToClipboard; }
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_button_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/components/button.js");
/* harmony import */ var _hooks_use_copy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-copy.js");
/* harmony import */ var _icons_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/icons/check.js");
/* harmony import */ var _icons_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/icons/copy.js");
/* __next_internal_client_entry_do_not_use__ CopyToClipboard auto */ 




const CopyToClipboard = (props)=>{
    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(8);
    const { copy, isCopied } = (0,_hooks_use_copy_js__WEBPACK_IMPORTED_MODULE_2__.useCopy)();
    let t0;
    if ($[0] !== copy) {
        t0 = async (event)=>{
            var _container_querySelector;
            const container = event.currentTarget.parentNode.parentNode;
            const content = ((_container_querySelector = container.querySelector("pre code")) === null || _container_querySelector === void 0 ? void 0 : _container_querySelector.textContent) || "";
            copy(content);
        };
        $[0] = copy;
        $[1] = t0;
    } else {
        t0 = $[1];
    }
    const handleClick = t0;
    const IconToUse = isCopied ? _icons_index_js__WEBPACK_IMPORTED_MODULE_3__/* .ReactComponent */ .r : _icons_index_js__WEBPACK_IMPORTED_MODULE_4__/* .ReactComponent */ .r;
    let t1;
    if ($[2] !== IconToUse) {
        t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(IconToUse, {
            height: "1em",
            className: "nextra-copy-icon"
        });
        $[2] = IconToUse;
        $[3] = t1;
    } else {
        t1 = $[3];
    }
    let t2;
    if ($[4] !== handleClick || $[5] !== props || $[6] !== t1) {
        t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_button_js__WEBPACK_IMPORTED_MODULE_5__.Button, {
            onClick: handleClick,
            title: "Copy code",
            variant: "outline",
            ...props,
            children: t1
        });
        $[4] = handleClick;
        $[5] = props;
        $[6] = t1;
        $[7] = t2;
    } else {
        t2 = $[7];
    }
    return t2;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/mdx-components/pre/toggle-word-wrap-button.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ToggleWordWrapButton: function() { return /* binding */ ToggleWordWrapButton; }
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_button_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/components/button.js");
/* __next_internal_client_entry_do_not_use__ ToggleWordWrapButton auto */ 


function toggleWordWrap() {
    const htmlDataset = document.documentElement.dataset;
    const hasWordWrap = "nextraWordWrap" in htmlDataset;
    if (hasWordWrap) {
        delete htmlDataset.nextraWordWrap;
    } else {
        htmlDataset.nextraWordWrap = "";
    }
}
const ToggleWordWrapButton = (t0)=>{
    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_1__.c)(2);
    const { children } = t0;
    let t1;
    if ($[0] !== children) {
        t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_button_js__WEBPACK_IMPORTED_MODULE_2__.Button, {
            onClick: toggleWordWrap,
            className: "x:md:hidden",
            title: "Toggle word wrap",
            variant: "outline",
            children
        });
        $[0] = children;
        $[1] = t1;
    } else {
        t1 = $[1];
    }
    return t1;
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @lightSyntaxTransform
 * @noflow
 * @nolint
 * @preventMunge
 * @preserve-invariant-messages
 */

"use no memo";
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  $dispatcherGuard: () => $dispatcherGuard,
  $makeReadOnly: () => $makeReadOnly,
  $reset: () => $reset,
  $structuralCheck: () => $structuralCheck,
  c: () => c,
  clearRenderCounterRegistry: () => clearRenderCounterRegistry,
  renderCounterRegistry: () => renderCounterRegistry,
  useRenderCounter: () => useRenderCounter
});
module.exports = __toCommonJS(index_exports);
var React = __toESM(__webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js"));
var { useRef, useEffect, isValidElement } = React;
var _a;
var ReactSecretInternals = (
  //@ts-ignore
  (_a = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) != null ? _a : React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
);
var $empty = Symbol.for("react.memo_cache_sentinel");
var _a2;
var c = (
  // @ts-expect-error
  typeof ((_a2 = React.__COMPILER_RUNTIME) == null ? void 0 : _a2.c) === "function" ? (
    // @ts-expect-error
    React.__COMPILER_RUNTIME.c
  ) : function c2(size) {
    return React.useMemo(() => {
      const $ = new Array(size);
      for (let ii = 0; ii < size; ii++) {
        $[ii] = $empty;
      }
      $[$empty] = true;
      return $;
    }, []);
  }
);
var LazyGuardDispatcher = {};
[
  "readContext",
  "useCallback",
  "useContext",
  "useEffect",
  "useImperativeHandle",
  "useInsertionEffect",
  "useLayoutEffect",
  "useMemo",
  "useReducer",
  "useRef",
  "useState",
  "useDebugValue",
  "useDeferredValue",
  "useTransition",
  "useMutableSource",
  "useSyncExternalStore",
  "useId",
  "unstable_isNewReconciler",
  "getCacheSignal",
  "getCacheForType",
  "useCacheRefresh"
].forEach((name) => {
  LazyGuardDispatcher[name] = () => {
    throw new Error(
      `[React] Unexpected React hook call (${name}) from a React compiled function. Check that all hooks are called directly and named according to convention ('use[A-Z]') `
    );
  };
});
var originalDispatcher = null;
LazyGuardDispatcher["useMemoCache"] = (count) => {
  if (originalDispatcher == null) {
    throw new Error(
      "React Compiler internal invariant violation: unexpected null dispatcher"
    );
  } else {
    return originalDispatcher.useMemoCache(count);
  }
};
function setCurrent(newDispatcher) {
  ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;
  return ReactSecretInternals.ReactCurrentDispatcher.current;
}
var guardFrames = [];
function $dispatcherGuard(kind) {
  const curr = ReactSecretInternals.ReactCurrentDispatcher.current;
  if (kind === 0 /* PushGuardContext */) {
    guardFrames.push(curr);
    if (guardFrames.length === 1) {
      originalDispatcher = curr;
    }
    if (curr === LazyGuardDispatcher) {
      throw new Error(
        `[React] Unexpected call to custom hook or component from a React compiled function. Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') and (2) components are returned as JSX instead of being directly invoked.`
      );
    }
    setCurrent(LazyGuardDispatcher);
  } else if (kind === 1 /* PopGuardContext */) {
    const lastFrame = guardFrames.pop();
    if (lastFrame == null) {
      throw new Error(
        "React Compiler internal error: unexpected null in guard stack"
      );
    }
    if (guardFrames.length === 0) {
      originalDispatcher = null;
    }
    setCurrent(lastFrame);
  } else if (kind === 2 /* PushExpectHook */) {
    guardFrames.push(curr);
    setCurrent(originalDispatcher);
  } else if (kind === 3 /* PopExpectHook */) {
    const lastFrame = guardFrames.pop();
    if (lastFrame == null) {
      throw new Error(
        "React Compiler internal error: unexpected null in guard stack"
      );
    }
    setCurrent(lastFrame);
  } else {
    throw new Error("React Compiler internal error: unreachable block" + kind);
  }
}
function $reset($) {
  for (let ii = 0; ii < $.length; ii++) {
    $[ii] = $empty;
  }
}
function $makeReadOnly() {
  throw new Error("TODO: implement $makeReadOnly in react-compiler-runtime");
}
var renderCounterRegistry = /* @__PURE__ */ new Map();
function clearRenderCounterRegistry() {
  for (const counters of renderCounterRegistry.values()) {
    counters.forEach((counter) => {
      counter.count = 0;
    });
  }
}
function registerRenderCounter(name, val) {
  let counters = renderCounterRegistry.get(name);
  if (counters == null) {
    counters = /* @__PURE__ */ new Set();
    renderCounterRegistry.set(name, counters);
  }
  counters.add(val);
}
function removeRenderCounter(name, val) {
  const counters = renderCounterRegistry.get(name);
  if (counters == null) {
    return;
  }
  counters.delete(val);
}
function useRenderCounter(name) {
  const val = useRef(null);
  if (val.current != null) {
    val.current.count += 1;
  }
  useEffect(() => {
    if (val.current == null) {
      const counter = { count: 0 };
      registerRenderCounter(name, counter);
      val.current = counter;
    }
    return () => {
      if (val.current !== null) {
        removeRenderCounter(name, val.current);
      }
    };
  });
}
var seenErrors = /* @__PURE__ */ new Set();
function $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {
  function error(l, r, path, depth) {
    const str = `${fnName}:${loc} [${kind}] ${variableName}${path} changed from ${l} to ${r} at depth ${depth}`;
    if (seenErrors.has(str)) {
      return;
    }
    seenErrors.add(str);
    console.error(str);
  }
  const depthLimit = 2;
  function recur(oldValue2, newValue2, path, depth) {
    if (depth > depthLimit) {
      return;
    } else if (oldValue2 === newValue2) {
      return;
    } else if (typeof oldValue2 !== typeof newValue2) {
      error(`type ${typeof oldValue2}`, `type ${typeof newValue2}`, path, depth);
    } else if (typeof oldValue2 === "object") {
      const oldArray = Array.isArray(oldValue2);
      const newArray = Array.isArray(newValue2);
      if (oldValue2 === null && newValue2 !== null) {
        error("null", `type ${typeof newValue2}`, path, depth);
      } else if (newValue2 === null) {
        error(`type ${typeof oldValue2}`, "null", path, depth);
      } else if (oldValue2 instanceof Map) {
        if (!(newValue2 instanceof Map)) {
          error(`Map instance`, `other value`, path, depth);
        } else if (oldValue2.size !== newValue2.size) {
          error(
            `Map instance with size ${oldValue2.size}`,
            `Map instance with size ${newValue2.size}`,
            path,
            depth
          );
        } else {
          for (const [k, v] of oldValue2) {
            if (!newValue2.has(k)) {
              error(
                `Map instance with key ${k}`,
                `Map instance without key ${k}`,
                path,
                depth
              );
            } else {
              recur(v, newValue2.get(k), `${path}.get(${k})`, depth + 1);
            }
          }
        }
      } else if (newValue2 instanceof Map) {
        error("other value", `Map instance`, path, depth);
      } else if (oldValue2 instanceof Set) {
        if (!(newValue2 instanceof Set)) {
          error(`Set instance`, `other value`, path, depth);
        } else if (oldValue2.size !== newValue2.size) {
          error(
            `Set instance with size ${oldValue2.size}`,
            `Set instance with size ${newValue2.size}`,
            path,
            depth
          );
        } else {
          for (const v of newValue2) {
            if (!oldValue2.has(v)) {
              error(
                `Set instance without element ${v}`,
                `Set instance with element ${v}`,
                path,
                depth
              );
            }
          }
        }
      } else if (newValue2 instanceof Set) {
        error("other value", `Set instance`, path, depth);
      } else if (oldArray || newArray) {
        if (oldArray !== newArray) {
          error(
            `type ${oldArray ? "array" : "object"}`,
            `type ${newArray ? "array" : "object"}`,
            path,
            depth
          );
        } else if (oldValue2.length !== newValue2.length) {
          error(
            `array with length ${oldValue2.length}`,
            `array with length ${newValue2.length}`,
            path,
            depth
          );
        } else {
          for (let ii = 0; ii < oldValue2.length; ii++) {
            recur(oldValue2[ii], newValue2[ii], `${path}[${ii}]`, depth + 1);
          }
        }
      } else if (isValidElement(oldValue2) || isValidElement(newValue2)) {
        if (isValidElement(oldValue2) !== isValidElement(newValue2)) {
          error(
            `type ${isValidElement(oldValue2) ? "React element" : "object"}`,
            `type ${isValidElement(newValue2) ? "React element" : "object"}`,
            path,
            depth
          );
        } else if (oldValue2.type !== newValue2.type) {
          error(
            `React element of type ${oldValue2.type}`,
            `React element of type ${newValue2.type}`,
            path,
            depth
          );
        } else {
          recur(
            oldValue2.props,
            newValue2.props,
            `[props of ${path}]`,
            depth + 1
          );
        }
      } else {
        for (const key in newValue2) {
          if (!(key in oldValue2)) {
            error(
              `object without key ${key}`,
              `object with key ${key}`,
              path,
              depth
            );
          }
        }
        for (const key in oldValue2) {
          if (!(key in newValue2)) {
            error(
              `object with key ${key}`,
              `object without key ${key}`,
              path,
              depth
            );
          } else {
            recur(oldValue2[key], newValue2[key], `${path}.${key}`, depth + 1);
          }
        }
      }
    } else if (typeof oldValue2 === "function") {
      return;
    } else if (isNaN(oldValue2) || isNaN(newValue2)) {
      if (isNaN(oldValue2) !== isNaN(newValue2)) {
        error(
          `${isNaN(oldValue2) ? "NaN" : "non-NaN value"}`,
          `${isNaN(newValue2) ? "NaN" : "non-NaN value"}`,
          path,
          depth
        );
      }
    } else if (oldValue2 !== newValue2) {
      error(oldValue2, newValue2, path, depth);
    }
  }
  recur(oldValue, newValue, "", 0);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.production.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var React = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
function is(x, y) {
  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
}
var objectIs = "function" === typeof Object.is ? Object.is : is,
  useSyncExternalStore = React.useSyncExternalStore,
  useRef = React.useRef,
  useEffect = React.useEffect,
  useMemo = React.useMemo,
  useDebugValue = React.useDebugValue;
exports.useSyncExternalStoreWithSelector = function (
  subscribe,
  getSnapshot,
  getServerSnapshot,
  selector,
  isEqual
) {
  var instRef = useRef(null);
  if (null === instRef.current) {
    var inst = { hasValue: !1, value: null };
    instRef.current = inst;
  } else inst = instRef.current;
  instRef = useMemo(
    function () {
      function memoizedSelector(nextSnapshot) {
        if (!hasMemo) {
          hasMemo = !0;
          memoizedSnapshot = nextSnapshot;
          nextSnapshot = selector(nextSnapshot);
          if (void 0 !== isEqual && inst.hasValue) {
            var currentSelection = inst.value;
            if (isEqual(currentSelection, nextSnapshot))
              return (memoizedSelection = currentSelection);
          }
          return (memoizedSelection = nextSnapshot);
        }
        currentSelection = memoizedSelection;
        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
        var nextSelection = selector(nextSnapshot);
        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
          return (memoizedSnapshot = nextSnapshot), currentSelection;
        memoizedSnapshot = nextSnapshot;
        return (memoizedSelection = nextSelection);
      }
      var hasMemo = !1,
        memoizedSnapshot,
        memoizedSelection,
        maybeGetServerSnapshot =
          void 0 === getServerSnapshot ? null : getServerSnapshot;
      return [
        function () {
          return memoizedSelector(getSnapshot());
        },
        null === maybeGetServerSnapshot
          ? void 0
          : function () {
              return memoizedSelector(maybeGetServerSnapshot());
            }
      ];
    },
    [getSnapshot, getServerSnapshot, selector, isEqual]
  );
  var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
  useEffect(
    function () {
      inst.hasValue = !0;
      inst.value = value;
    },
    [value]
  );
  useDebugValue(value);
  return value;
};


/***/ }),

/***/ "(app-pages-browser)/../../node_modules/use-sync-external-store/with-selector.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__("(app-pages-browser)/../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.production.js");
} else {}


/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Me: function() { return /* binding */ autoUpdate; },
  oo: function() { return /* binding */ floating_ui_dom_computePosition; },
  US: function() { return /* binding */ floating_ui_dom_detectOverflow; },
  RR: function() { return /* binding */ floating_ui_dom_flip; },
  cv: function() { return /* binding */ floating_ui_dom_offset; },
  uY: function() { return /* binding */ floating_ui_dom_shift; },
  dp: function() { return /* binding */ floating_ui_dom_size; }
});

// UNUSED EXPORTS: arrow, autoPlacement, getOverflowAncestors, hide, inline, limitShift, platform

// EXTERNAL MODULE: ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var floating_ui_utils = __webpack_require__("(app-pages-browser)/../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs");
;// CONCATENATED MODULE: ../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs



function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = (0,floating_ui_utils/* getSideAxis */.Qq)(placement);
  const alignmentAxis = (0,floating_ui_utils/* getAlignmentAxis */.Wh)(placement);
  const alignLength = (0,floating_ui_utils/* getAxisLength */.I4)(alignmentAxis);
  const side = (0,floating_ui_utils/* getSide */.k3)(placement);
  const isVertical = sideAxis === 'y';
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch ((0,floating_ui_utils/* getAlignment */.hp)(placement)) {
    case 'start':
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = (0,floating_ui_utils/* evaluate */.ku)(options, state);
  const paddingObject = (0,floating_ui_utils/* getPaddingObject */.yd)(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = (0,floating_ui_utils/* rectToClientRect */.JB)(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = (0,floating_ui_utils/* rectToClientRect */.JB)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => ({
  name: 'arrow',
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    // Since `element` is required, we don't Partial<> the type.
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === 'y';
    const minProp = isYAxis ? 'top' : 'left';
    const maxProp = isYAxis ? 'bottom' : 'right';
    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

    // DOM platform can return `window` as the `offsetParent`.
    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // If the padding is large enough that it causes the arrow to no longer be
    // centered, modify the padding so that it is centered.
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds.
    const min$1 = minPadding;
    const max = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = clamp(min$1, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. To ensure `shift()` continues to take action,
    // a single reset is performed when this is true.
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset
        })
      },
      reset: shouldAddOffset
    };
  }
});

function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter(placement => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'autoPlacement',
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

      // Make `computeCoords` start from the right place.
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];

      // There are more placements to check.
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map(d => {
        const alignment = getAlignment(d.placement);
        return [d.placement, alignment && crossAxis ?
        // Check along the mainAxis and main crossAxis side.
        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :
        // Check only the mainAxis.
        d.overflows[0], d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,
      // Aligned placements should not check their opposite crossAxis
      // side.
      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = (0,floating_ui_utils/* evaluate */.ku)(options, state);

      // If a reset by the arrow was caused due to an alignment offset being
      // added, we should skip any logic now since `flip()` has already done its
      // work.
      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = (0,floating_ui_utils/* getSide */.k3)(placement);
      const initialSideAxis = (0,floating_ui_utils/* getSideAxis */.Qq)(initialPlacement);
      const isBasePlacement = (0,floating_ui_utils/* getSide */.k3)(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [(0,floating_ui_utils/* getOppositePlacement */.pw)(initialPlacement)] : (0,floating_ui_utils/* getExpandedPlacements */.gy)(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...(0,floating_ui_utils/* getOppositeAxisPlacements */.KX)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = (0,floating_ui_utils/* getAlignmentSides */.i8)(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== (0,floating_ui_utils/* getSideAxis */.Qq)(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow ||
          // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every(d => (0,floating_ui_utils/* getSideAxis */.Qq)(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            // Try next placement and re-run the lifecycle.
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$filter2;
                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = (0,floating_ui_utils/* getSideAxis */.Qq)(d.placement);
                    return currentSideAxis === initialSideAxis ||
                    // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === 'y';
                  }
                  return true;
                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some(side => overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'hide',
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = 'referenceHidden',
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
        case 'escaped':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
        default:
          {
            return {};
          }
      }
    }
  };
};

function getBoundingRect(rects) {
  const minX = min(...rects.map(rect => rect.left));
  const minY = min(...rects.map(rect => rect.top));
  const maxX = max(...rects.map(rect => rect.right));
  const maxY = max(...rects.map(rect => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
  const groups = [];
  let prevRect = null;
  for (let i = 0; i < sortedRects.length; i++) {
    const rect = sortedRects[i];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));
}
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'inline',
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform,
        strategy
      } = state;
      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
      // ClientRect's bounds, despite the event listener being triggered. A
      // padding of 2 seems to handle this issue.
      const {
        padding = 2,
        x,
        y
      } = evaluate(options, state);
      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
      const paddingObject = getPaddingObject(padding);
      function getBoundingClientRect() {
        // There are two rects and they are disjoined.
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          // Find the first rect in which the point is fully inside.
          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }

        // There are 2 or more connected rects.
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === 'y') {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === 'top';
            const top = firstRect.top;
            const bottom = lastRect.bottom;
            const left = isTop ? firstRect.left : lastRect.left;
            const right = isTop ? firstRect.right : lastRect.right;
            const width = right - left;
            const height = bottom - top;
            return {
              top,
              bottom,
              left,
              right,
              width,
              height,
              x: left,
              y: top
            };
          }
          const isLeftSide = getSide(placement) === 'left';
          const maxRight = max(...clientRects.map(rect => rect.right));
          const minLeft = min(...clientRects.map(rect => rect.left));
          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform.getElementRects({
        reference: {
          getBoundingClientRect
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};

const originSides = /*#__PURE__*/new Set(['left', 'top']);

// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.

async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = (0,floating_ui_utils/* getSide */.k3)(placement);
  const alignment = (0,floating_ui_utils/* getAlignment */.hp)(placement);
  const isVertical = (0,floating_ui_utils/* getSideAxis */.Qq)(placement) === 'y';
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = (0,floating_ui_utils/* evaluate */.ku)(options, state);

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: 'offset',
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);

      // If the placement is the same and the arrow caused an alignment offset
      // then we don't need to change the positioning coordinates.
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = (0,floating_ui_utils/* evaluate */.ku)(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = (0,floating_ui_utils/* getSideAxis */.Qq)((0,floating_ui_utils/* getSide */.k3)(placement));
      const mainAxis = (0,floating_ui_utils/* getOppositeAxis */.Rn)(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = (0,floating_ui_utils/* clamp */.uZ)(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = (0,floating_ui_utils/* clamp */.uZ)(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset, state);
      const computedOffset = typeof rawOffset === 'number' ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === 'y' ? 'height' : 'width';
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === 'y' ? 'width' : 'height';
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};

/**
 * Provides data that allows you to change the size of the floating element —
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = (0,floating_ui_utils/* evaluate */.ku)(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = (0,floating_ui_utils/* getSide */.k3)(placement);
      const alignment = (0,floating_ui_utils/* getAlignment */.hp)(placement);
      const isYAxis = (0,floating_ui_utils/* getSideAxis */.Qq)(placement) === 'y';
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = (0,floating_ui_utils/* min */.VV)(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = (0,floating_ui_utils/* min */.VV)(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = (0,floating_ui_utils/* max */.Fp)(overflow.left, 0);
        const xMax = (0,floating_ui_utils/* max */.Fp)(overflow.right, 0);
        const yMin = (0,floating_ui_utils/* max */.Fp)(overflow.top, 0);
        const yMax = (0,floating_ui_utils/* max */.Fp)(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,floating_ui_utils/* max */.Fp)(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,floating_ui_utils/* max */.Fp)(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};



// EXTERNAL MODULE: ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
var floating_ui_utils_dom = __webpack_require__("(app-pages-browser)/../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs");
;// CONCATENATED MODULE: ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs





function getCssDimensions(element) {
  const css = (0,floating_ui_utils_dom/* getComputedStyle */.Dx)(element);
  // In testing environments, the `width` and `height` properties are empty
  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = (0,floating_ui_utils_dom/* isHTMLElement */.Re)(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = (0,floating_ui_utils/* round */.NM)(width) !== offsetWidth || (0,floating_ui_utils/* round */.NM)(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}

function unwrapElement(element) {
  return !(0,floating_ui_utils_dom/* isElement */.kK)(element) ? element.contextElement : element;
}

function getScale(element) {
  const domElement = unwrapElement(element);
  if (!(0,floating_ui_utils_dom/* isHTMLElement */.Re)(domElement)) {
    return (0,floating_ui_utils/* createCoords */.ze)(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? (0,floating_ui_utils/* round */.NM)(rect.width) : rect.width) / width;
  let y = ($ ? (0,floating_ui_utils/* round */.NM)(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

const noOffsets = /*#__PURE__*/(0,floating_ui_utils/* createCoords */.ze)(0);
function getVisualOffsets(element) {
  const win = (0,floating_ui_utils_dom/* getWindow */.Jj)(element);
  if (!(0,floating_ui_utils_dom/* isWebKit */.Pf)() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,floating_ui_utils_dom/* getWindow */.Jj)(element)) {
    return false;
  }
  return isFixed;
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = (0,floating_ui_utils/* createCoords */.ze)(1);
  if (includeScale) {
    if (offsetParent) {
      if ((0,floating_ui_utils_dom/* isElement */.kK)(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,floating_ui_utils/* createCoords */.ze)(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = (0,floating_ui_utils_dom/* getWindow */.Jj)(domElement);
    const offsetWin = offsetParent && (0,floating_ui_utils_dom/* isElement */.kK)(offsetParent) ? (0,floating_ui_utils_dom/* getWindow */.Jj)(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = (0,floating_ui_utils_dom/* getFrameElement */.wK)(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = (0,floating_ui_utils_dom/* getComputedStyle */.Dx)(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = (0,floating_ui_utils_dom/* getWindow */.Jj)(currentIFrame);
      currentIFrame = (0,floating_ui_utils_dom/* getFrameElement */.wK)(currentWin);
    }
  }
  return (0,floating_ui_utils/* rectToClientRect */.JB)({
    width,
    height,
    x,
    y
  });
}

// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
function getWindowScrollBarX(element, rect) {
  const leftScroll = (0,floating_ui_utils_dom/* getNodeScroll */.Lw)(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect((0,floating_ui_utils_dom/* getDocumentElement */.tF)(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}

function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === 'fixed';
  const documentElement = (0,floating_ui_utils_dom/* getDocumentElement */.tF)(offsetParent);
  const topLayer = elements ? (0,floating_ui_utils_dom/* isTopLayer */.tR)(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = (0,floating_ui_utils/* createCoords */.ze)(1);
  const offsets = (0,floating_ui_utils/* createCoords */.ze)(0);
  const isOffsetParentAnElement = (0,floating_ui_utils_dom/* isHTMLElement */.Re)(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,floating_ui_utils_dom/* getNodeName */.wk)(offsetParent) !== 'body' || (0,floating_ui_utils_dom/* isOverflowElement */.ao)(documentElement)) {
      scroll = (0,floating_ui_utils_dom/* getNodeScroll */.Lw)(offsetParent);
    }
    if ((0,floating_ui_utils_dom/* isHTMLElement */.Re)(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0,floating_ui_utils/* createCoords */.ze)(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}

function getClientRects(element) {
  return Array.from(element.getClientRects());
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = (0,floating_ui_utils_dom/* getDocumentElement */.tF)(element);
  const scroll = (0,floating_ui_utils_dom/* getNodeScroll */.Lw)(element);
  const body = element.ownerDocument.body;
  const width = (0,floating_ui_utils/* max */.Fp)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = (0,floating_ui_utils/* max */.Fp)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if ((0,floating_ui_utils_dom/* getComputedStyle */.Dx)(body).direction === 'rtl') {
    x += (0,floating_ui_utils/* max */.Fp)(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Safety check: ensure the scrollbar space is reasonable in case this
// calculation is affected by unusual styles.
// Most scrollbars leave 15-18px of space.
const SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = (0,floating_ui_utils_dom/* getWindow */.Jj)(element);
  const html = (0,floating_ui_utils_dom/* getDocumentElement */.tF)(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = (0,floating_ui_utils_dom/* isWebKit */.Pf)();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  // <html> `overflow: hidden` + `scrollbar-gutter: stable` reduces the
  // visual width of the <html> but this is not considered in the size
  // of `html.clientWidth`.
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === 'CSS1Compat' ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    // If the <body> scrollbar is on the left, the width needs to be extended
    // by the scrollbar amount so there isn't extra space on the right.
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}

const absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);
// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = (0,floating_ui_utils_dom/* isHTMLElement */.Re)(element) ? getScale(element) : (0,floating_ui_utils/* createCoords */.ze)(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect((0,floating_ui_utils_dom/* getDocumentElement */.tF)(element));
  } else if ((0,floating_ui_utils_dom/* isElement */.kK)(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return (0,floating_ui_utils/* rectToClientRect */.JB)(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = (0,floating_ui_utils_dom/* getParentNode */.Ow)(element);
  if (parentNode === stopNode || !(0,floating_ui_utils_dom/* isElement */.kK)(parentNode) || (0,floating_ui_utils_dom/* isLastTraversableNode */.Py)(parentNode)) {
    return false;
  }
  return (0,floating_ui_utils_dom/* getComputedStyle */.Dx)(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = (0,floating_ui_utils_dom/* getOverflowAncestors */.Kx)(element, [], false).filter(el => (0,floating_ui_utils_dom/* isElement */.kK)(el) && (0,floating_ui_utils_dom/* getNodeName */.wk)(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = (0,floating_ui_utils_dom/* getComputedStyle */.Dx)(element).position === 'fixed';
  let currentNode = elementIsFixed ? (0,floating_ui_utils_dom/* getParentNode */.Ow)(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while ((0,floating_ui_utils_dom/* isElement */.kK)(currentNode) && !(0,floating_ui_utils_dom/* isLastTraversableNode */.Py)(currentNode)) {
    const computedStyle = (0,floating_ui_utils_dom/* getComputedStyle */.Dx)(currentNode);
    const currentNodeIsContaining = (0,floating_ui_utils_dom/* isContainingBlock */.hT)(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || (0,floating_ui_utils_dom/* isOverflowElement */.ao)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = (0,floating_ui_utils_dom/* getParentNode */.Ow)(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? (0,floating_ui_utils_dom/* isTopLayer */.tR)(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = (0,floating_ui_utils/* max */.Fp)(rect.top, accRect.top);
    accRect.right = (0,floating_ui_utils/* min */.VV)(rect.right, accRect.right);
    accRect.bottom = (0,floating_ui_utils/* min */.VV)(rect.bottom, accRect.bottom);
    accRect.left = (0,floating_ui_utils/* max */.Fp)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = (0,floating_ui_utils_dom/* isHTMLElement */.Re)(offsetParent);
  const documentElement = (0,floating_ui_utils_dom/* getDocumentElement */.tF)(offsetParent);
  const isFixed = strategy === 'fixed';
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = (0,floating_ui_utils/* createCoords */.ze)(0);

  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
  // Firefox with layout.scrollbar.side = 3 in about:config to test this.
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,floating_ui_utils_dom/* getNodeName */.wk)(offsetParent) !== 'body' || (0,floating_ui_utils_dom/* isOverflowElement */.ao)(documentElement)) {
      scroll = (0,floating_ui_utils_dom/* getNodeScroll */.Lw)(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0,floating_ui_utils/* createCoords */.ze)(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}

function isStaticPositioned(element) {
  return (0,floating_ui_utils_dom/* getComputedStyle */.Dx)(element).position === 'static';
}

function getTrueOffsetParent(element, polyfill) {
  if (!(0,floating_ui_utils_dom/* isHTMLElement */.Re)(element) || (0,floating_ui_utils_dom/* getComputedStyle */.Dx)(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;

  // Firefox returns the <html> element as the offsetParent if it's non-static,
  // while Chrome and Safari return the <body> element. The <body> element must
  // be used to perform the correct calculations even if the <html> element is
  // non-static.
  if ((0,floating_ui_utils_dom/* getDocumentElement */.tF)(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const win = (0,floating_ui_utils_dom/* getWindow */.Jj)(element);
  if ((0,floating_ui_utils_dom/* isTopLayer */.tR)(element)) {
    return win;
  }
  if (!(0,floating_ui_utils_dom/* isHTMLElement */.Re)(element)) {
    let svgOffsetParent = (0,floating_ui_utils_dom/* getParentNode */.Ow)(element);
    while (svgOffsetParent && !(0,floating_ui_utils_dom/* isLastTraversableNode */.Py)(svgOffsetParent)) {
      if ((0,floating_ui_utils_dom/* isElement */.kK)(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = (0,floating_ui_utils_dom/* getParentNode */.Ow)(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && (0,floating_ui_utils_dom/* isTableElement */.Ze)(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (0,floating_ui_utils_dom/* isLastTraversableNode */.Py)(offsetParent) && isStaticPositioned(offsetParent) && !(0,floating_ui_utils_dom/* isContainingBlock */.hT)(offsetParent)) {
    return win;
  }
  return offsetParent || (0,floating_ui_utils_dom/* getContainingBlock */.gQ)(element) || win;
}

const getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};

function isRTL(element) {
  return (0,floating_ui_utils_dom/* getComputedStyle */.Dx)(element).direction === 'rtl';
}

const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: floating_ui_utils_dom/* getDocumentElement */.tF,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: floating_ui_utils_dom/* isElement */.kK,
  isRTL
};

function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}

// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = (0,floating_ui_utils_dom/* getDocumentElement */.tF)(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = (0,floating_ui_utils/* floor */.GW)(top);
    const insetRight = (0,floating_ui_utils/* floor */.GW)(root.clientWidth - (left + width));
    const insetBottom = (0,floating_ui_utils/* floor */.GW)(root.clientHeight - (top + height));
    const insetLeft = (0,floating_ui_utils/* floor */.GW)(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: (0,floating_ui_utils/* max */.Fp)(0, (0,floating_ui_utils/* min */.VV)(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          // If the reference is clipped, the ratio is 0. Throttle the refresh
          // to prevent an infinite loop of updates.
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1000);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        // It's possible that even though the ratio is reported as 1, the
        // element is not actually fully within the IntersectionObserver's root
        // area anymore. This can happen under performance constraints. This may
        // be a bug in the browser's IntersectionObserver implementation. To
        // work around this, we compare the element's bounding rect now with
        // what it was at the time we created the IntersectionObserver. If they
        // are not equal then the element moved, so we refresh.
        refresh();
      }
      isFirstUpdate = false;
    }

    // Older browsers don't support a `document` as the root and will throw an
    // error.
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === 'function',
    layoutShift = typeof IntersectionObserver === 'function',
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? (0,floating_ui_utils_dom/* getOverflowAncestors */.Kx)(referenceEl) : []), ...(0,floating_ui_utils_dom/* getOverflowAncestors */.Kx)(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(_ref => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        // Prevent update loops when using the `size` middleware.
        // https://github.com/floating-ui/floating-ui/issues/1740
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
const floating_ui_dom_detectOverflow = detectOverflow;

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const floating_ui_dom_offset = offset;

/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const floating_ui_dom_autoPlacement = (/* unused pure expression or super */ null && (autoPlacement$1));

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const floating_ui_dom_shift = shift;

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const floating_ui_dom_flip = flip;

/**
 * Provides data that allows you to change the size of the floating element —
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const floating_ui_dom_size = size;

/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const floating_ui_dom_hide = (/* unused pure expression or super */ null && (hide$1));

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const floating_ui_dom_arrow = (/* unused pure expression or super */ null && (arrow$1));

/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const floating_ui_dom_inline = (/* unused pure expression or super */ null && (inline$1));

/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const floating_ui_dom_limitShift = (/* unused pure expression or super */ null && (limitShift$1));

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */
const floating_ui_dom_computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};




/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RR: function() { return /* binding */ flip; },
/* harmony export */   YF: function() { return /* binding */ useFloating; },
/* harmony export */   cv: function() { return /* binding */ offset; },
/* harmony export */   dp: function() { return /* binding */ size; },
/* harmony export */   uY: function() { return /* binding */ shift; }
/* harmony export */ });
/* unused harmony exports arrow, autoPlacement, hide, inline, limitShift */
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js");






var isClient = typeof document !== 'undefined';

var noop = function noop() {};
var index = isClient ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : noop;

// Fork of `fast-deep-equal` that only does the comparisons we need and compares
// functions
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === 'function' && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === 'object') {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0;) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0;) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0;) {
      const key = keys[i];
      if (key === '_owner' && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}

function getDPR(element) {
  if (typeof window === 'undefined') {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}

function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}

function useLatestRef(value) {
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}

/**
 * Provides data to position a floating element.
 * @see https://floating-ui.com/docs/useFloating
 */
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_0__.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
  const [_floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
  const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const floatingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform);
  const openRef = useLatestRef(open);
  const update = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__/* .computePosition */ .oo)(referenceRef.current, floatingRef.current, config).then(data => {
      const fullData = {
        ...data,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData(data => ({
        ...data,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...(getDPR(elements.floating) >= 1.5 && {
          willChange: 'transform'
        })
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * This wraps the core `arrow` middleware to allow React refs as the element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow$1 = options => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, 'current');
  }
  return {
    name: 'arrow',
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === 'function' ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = (options, deps) => ({
  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__/* .offset */ .cv)(options),
  options: [options, deps]
});

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = (options, deps) => ({
  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__/* .shift */ .uY)(options),
  options: [options, deps]
});

/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = (options, deps) => ({
  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__/* .flip */ .RR)(options),
  options: [options, deps]
});

/**
 * Provides data that allows you to change the size of the floating element —
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = (options, deps) => ({
  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__/* .size */ .dp)(options),
  options: [options, deps]
});

/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = (options, deps) => ({
  ...autoPlacement$1(options),
  options: [options, deps]
});

/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});

/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = (options, deps) => ({
  ...inline$1(options),
  options: [options, deps]
});

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * This wraps the core `arrow` middleware to allow React refs as the element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});




/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ij: function() { return /* binding */ getUserAgent; }
/* harmony export */ });
/* unused harmony exports TYPEABLE_SELECTOR, activeElement, contains, getDocument, getPlatform, getTarget, isAndroid, isEventTargetWithin, isJSDOM, isMac, isMouseLikePointerType, isReactEvent, isRootElement, isSafari, isTypeableCombobox, isTypeableElement, isVirtualClick, isVirtualPointerEvent, stopEvent */


function activeElement(doc) {
  let activeElement = doc.activeElement;
  while (((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {
    var _activeElement;
    activeElement = activeElement.shadowRoot.activeElement;
  }
  return activeElement;
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();

  // First, attempt with faster native method
  if (parent.contains(child)) {
    return true;
  }

  // then fallback to custom implementation with Shadow DOM support
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      // @ts-ignore
      next = next.parentNode || next.host;
    }
  }

  // Give up, the result is false
  return false;
}
// Avoid Chrome DevTools blue warning.
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map(_ref => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(' ');
  }
  return navigator.userAgent;
}

// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts
function isVirtualClick(event) {
  // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.
  // Try to find a workaround for this. `react-aria` source still has the check.
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }
  if (isAndroid() && event.pointerType) {
    return event.type === 'click' && event.buttons === 1;
  }
  return event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
  if (isJSDOM()) return false;
  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse' ||
  // iOS VoiceOver returns 0.333• for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'touch';
}
function isSafari() {
  // Chrome DevTools does not complain about navigator.vendor
  return /apple/i.test(navigator.vendor);
}
function isAndroid() {
  const re = /android/i;
  return re.test(getPlatform()) || re.test(getUserAgent());
}
function isMac() {
  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;
}
function isJSDOM() {
  return getUserAgent().includes('jsdom/');
}
function isMouseLikePointerType(pointerType, strict) {
  // On some Linux machines with Chromium, mouse inputs return a `pointerType`
  // of "pen": https://github.com/floating-ui/floating-ui/issues/2015
  const values = ['mouse', 'pen'];
  if (!strict) {
    values.push('', undefined);
  }
  return values.includes(pointerType);
}
function isReactEvent(event) {
  return 'nativeEvent' in event;
}
function isRootElement(element) {
  return element.matches('html,body');
}
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function isEventTargetWithin(event, node) {
  if (node == null) {
    return false;
  }
  if ('composedPath' in event) {
    return event.composedPath().includes(node);
  }

  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't
  const e = event;
  return e.target != null && node.contains(e.target);
}
function getTarget(event) {
  if ('composedPath' in event) {
    return event.composedPath()[0];
  }

  // TS thinks `event` is of type never as it assumes all browsers support
  // `composedPath()`, but browsers without shadow DOM don't.
  return event.target;
}
const TYPEABLE_SELECTOR = (/* unused pure expression or super */ null && ("input:not([type='hidden']):not([disabled])," + "[contenteditable]:not([contenteditable='false']),textarea:not([disabled])"));
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
function isTypeableCombobox(element) {
  if (!element) return false;
  return element.getAttribute('role') === 'combobox' && isTypeableElement(element);
}




/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dx: function() { return /* binding */ getComputedStyle; },
/* harmony export */   Jj: function() { return /* binding */ getWindow; },
/* harmony export */   Kx: function() { return /* binding */ getOverflowAncestors; },
/* harmony export */   Lw: function() { return /* binding */ getNodeScroll; },
/* harmony export */   Ow: function() { return /* binding */ getParentNode; },
/* harmony export */   Pf: function() { return /* binding */ isWebKit; },
/* harmony export */   Py: function() { return /* binding */ isLastTraversableNode; },
/* harmony export */   Re: function() { return /* binding */ isHTMLElement; },
/* harmony export */   Ze: function() { return /* binding */ isTableElement; },
/* harmony export */   ao: function() { return /* binding */ isOverflowElement; },
/* harmony export */   gQ: function() { return /* binding */ getContainingBlock; },
/* harmony export */   hT: function() { return /* binding */ isContainingBlock; },
/* harmony export */   kK: function() { return /* binding */ isElement; },
/* harmony export */   tF: function() { return /* binding */ getDocumentElement; },
/* harmony export */   tR: function() { return /* binding */ isTopLayer; },
/* harmony export */   wK: function() { return /* binding */ getFrameElement; },
/* harmony export */   wk: function() { return /* binding */ getNodeName; }
/* harmony export */ });
/* unused harmony exports getNearestOverflowAncestor, isNode, isShadowRoot */
function hasWindow() {
  return typeof window !== 'undefined';
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || '').toLowerCase();
  }
  // Mocked nodes in testing environments may not be instances of Node. By
  // returning `#document` an infinite loop won't occur.
  // https://github.com/floating-ui/floating-ui/issues/2317
  return '#document';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === 'undefined') {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [':popover-open', ':modal'];
function isTopLayer(element) {
  return topLayerSelectors.some(selector => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
const transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];
const willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];
const containValues = ['paint', 'layout', 'strict', 'content'];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  // https://drafts.csswg.org/css-transforms-2/#individual-transforms
  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
const lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}




/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fp: function() { return /* binding */ max; },
/* harmony export */   GW: function() { return /* binding */ floor; },
/* harmony export */   I4: function() { return /* binding */ getAxisLength; },
/* harmony export */   JB: function() { return /* binding */ rectToClientRect; },
/* harmony export */   KX: function() { return /* binding */ getOppositeAxisPlacements; },
/* harmony export */   NM: function() { return /* binding */ round; },
/* harmony export */   Qq: function() { return /* binding */ getSideAxis; },
/* harmony export */   Rn: function() { return /* binding */ getOppositeAxis; },
/* harmony export */   VV: function() { return /* binding */ min; },
/* harmony export */   Wh: function() { return /* binding */ getAlignmentAxis; },
/* harmony export */   gy: function() { return /* binding */ getExpandedPlacements; },
/* harmony export */   hp: function() { return /* binding */ getAlignment; },
/* harmony export */   i8: function() { return /* binding */ getAlignmentSides; },
/* harmony export */   k3: function() { return /* binding */ getSide; },
/* harmony export */   ku: function() { return /* binding */ evaluate; },
/* harmony export */   pw: function() { return /* binding */ getOppositePlacement; },
/* harmony export */   uZ: function() { return /* binding */ clamp; },
/* harmony export */   yd: function() { return /* binding */ getPaddingObject; },
/* harmony export */   ze: function() { return /* binding */ createCoords; }
/* harmony export */ });
/* unused harmony exports alignments, expandPaddingObject, getOppositeAlignmentPlacement, placements, sides */
/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */

const sides = (/* unused pure expression or super */ null && (['top', 'right', 'bottom', 'left']));
const alignments = (/* unused pure expression or super */ null && (['start', 'end']));
const placements = /*#__PURE__*/(/* unused pure expression or super */ null && (sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), [])));
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = v => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getOppositeAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
  return axis === 'y' ? 'height' : 'width';
}
const yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ['left', 'right'];
const rlPlacement = ['right', 'left'];
const tbPlacement = ['top', 'bottom'];
const btPlacement = ['bottom', 'top'];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case 'left':
    case 'right':
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}




/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/button/button.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   z: function() { return /* binding */ L; }
/* harmony export */ });
/* harmony import */ var _react_aria_focus__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/focus/dist/useFocusRing.mjs");
/* harmony import */ var _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/interactions/dist/useHover.mjs");
/* harmony import */ var _hooks_use_active_press_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-active-press.js");
/* harmony import */ var _hooks_use_slot_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-slot.js");
/* harmony import */ var _internal_disabled_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/disabled.js");
/* harmony import */ var _utils_render_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/render.js");
/* __next_internal_client_entry_do_not_use__ Button auto */ 





let R = "button";
function v(s, n) {
    var r;
    let p = (0,_internal_disabled_js__WEBPACK_IMPORTED_MODULE_0__/* .useDisabled */ .B)(), { disabled: e = p || !1, autoFocus: t = !1, ...o } = s, { isFocusVisible: a, focusProps: l } = (0,_react_aria_focus__WEBPACK_IMPORTED_MODULE_1__/* .useFocusRing */ .F)({
        autoFocus: t
    }), { isHovered: u, hoverProps: i } = (0,_react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__/* .useHover */ .X)({
        isDisabled: e
    }), { pressed: T, pressProps: d } = (0,_hooks_use_active_press_js__WEBPACK_IMPORTED_MODULE_3__/* .useActivePress */ .x)({
        disabled: e
    }), f = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_4__/* .mergeProps */ .dG)({
        ref: n,
        type: (r = o.type) != null ? r : "button",
        disabled: e || void 0,
        autoFocus: t
    }, l, i, d), m = (0,_hooks_use_slot_js__WEBPACK_IMPORTED_MODULE_5__/* .useSlot */ .x)({
        disabled: e,
        hover: u,
        focus: a,
        active: T,
        autofocus: t
    });
    return (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_4__/* .useRender */ .L6)()({
        ourProps: f,
        theirProps: o,
        slot: m,
        defaultTag: R,
        name: "Button"
    });
}
let L = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_4__/* .forwardRefWithAs */ .yV)(v);



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/description/description.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fw: function() { return /* binding */ H; },
/* harmony export */   zH: function() { return /* binding */ w; }
/* harmony export */ });
/* unused harmony export Description */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _hooks_use_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");
/* harmony import */ var _hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");
/* harmony import */ var _hooks_use_slot_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-slot.js");
/* harmony import */ var _hooks_use_sync_refs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js");
/* harmony import */ var _internal_disabled_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/disabled.js");
/* harmony import */ var _utils_render_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/render.js");
/* __next_internal_client_entry_do_not_use__ Description,useDescribedBy,useDescriptions auto */ 







let a = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
a.displayName = "DescriptionContext";
function f() {
    let r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(a);
    if (r === null) {
        let e = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
        throw Error.captureStackTrace && Error.captureStackTrace(e, f), e;
    }
    return r;
}
function w() {
    var r, e;
    return (e = (r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(a)) == null ? void 0 : r.value) != null ? e : void 0;
}
function H() {
    let [r, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
    return [
        r.length > 0 ? r.join(" ") : void 0,
        (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>function(t) {
                let i = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_1__/* .useEvent */ .z)((n)=>(e((o)=>[
                            ...o,
                            n
                        ]), ()=>e((o)=>{
                            let s = o.slice(), p = s.indexOf(n);
                            return p !== -1 && s.splice(p, 1), s;
                        }))), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({
                        register: i,
                        slot: t.slot,
                        name: t.name,
                        props: t.props,
                        value: t.value
                    }), [
                    i,
                    t.slot,
                    t.name,
                    t.props,
                    t.value
                ]);
                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(a.Provider, {
                    value: l
                }, t.children);
            }, [
            e
        ])
    ];
}
let I = "p";
function C(r, e) {
    let c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)(), t = (0,_internal_disabled_js__WEBPACK_IMPORTED_MODULE_2__/* .useDisabled */ .B)(), { id: i = "headlessui-description-".concat(c), ...l } = r, n = f(), o = (0,_hooks_use_sync_refs_js__WEBPACK_IMPORTED_MODULE_3__/* .useSyncRefs */ .T)(e);
    (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_4__/* .useIsoMorphicEffect */ .e)(()=>n.register(i), [
        i,
        n.register
    ]);
    let s = (0,_hooks_use_slot_js__WEBPACK_IMPORTED_MODULE_5__/* .useSlot */ .x)({
        ...n.slot,
        disabled: t || !1
    }), p = {
        ref: o,
        ...n.props,
        id: i
    };
    return (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_6__/* .useRender */ .L6)()({
        ourProps: p,
        theirProps: l,
        slot: s,
        defaultTag: I,
        name: n.name || "Description"
    });
}
let _ = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_6__/* .forwardRefWithAs */ .yV)(C), M = Object.assign(_, {});



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/keyboard.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: function() { return /* binding */ o; }
/* harmony export */ });
var o = ((r)=>(r.Space = " ", r.Enter = "Enter", r.Escape = "Escape", r.Backspace = "Backspace", r.Delete = "Delete", r.ArrowLeft = "ArrowLeft", r.ArrowUp = "ArrowUp", r.ArrowRight = "ArrowRight", r.ArrowDown = "ArrowDown", r.Home = "Home", r.End = "End", r.PageUp = "PageUp", r.PageDown = "PageDown", r.Tab = "Tab", r))(o || {});



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/label/label.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __: function() { return /* binding */ Z; },
/* harmony export */   bE: function() { return /* binding */ V; },
/* harmony export */   t0: function() { return /* binding */ C; },
/* harmony export */   wp: function() { return /* binding */ N; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _hooks_use_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");
/* harmony import */ var _hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");
/* harmony import */ var _hooks_use_slot_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-slot.js");
/* harmony import */ var _hooks_use_sync_refs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js");
/* harmony import */ var _internal_disabled_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/disabled.js");
/* harmony import */ var _internal_id_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/id.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js");
/* harmony import */ var _utils_render_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/render.js");
/* __next_internal_client_entry_do_not_use__ Label,useLabelContext,useLabelledBy,useLabels auto */ 









let L = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
L.displayName = "LabelContext";
function C() {
    let n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(L);
    if (n === null) {
        let l = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
        throw Error.captureStackTrace && Error.captureStackTrace(l, C), l;
    }
    return n;
}
function N(n) {
    var a, e, o;
    let l = (e = (a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(L)) == null ? void 0 : a.value) != null ? e : void 0;
    return ((o = n == null ? void 0 : n.length) != null ? o : 0) > 0 ? [
        l,
        ...n
    ].filter(Boolean).join(" ") : l;
}
function V() {
    let { inherit: n = !1 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let l = N(), [a, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), o = n ? [
        l,
        ...a
    ].filter(Boolean) : a;
    return [
        o.length > 0 ? o.join(" ") : void 0,
        (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>function(t) {
                let p = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_1__/* .useEvent */ .z)((i)=>(e((u)=>[
                            ...u,
                            i
                        ]), ()=>e((u)=>{
                            let d = u.slice(), f = d.indexOf(i);
                            return f !== -1 && d.splice(f, 1), d;
                        }))), b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({
                        register: p,
                        slot: t.slot,
                        name: t.name,
                        props: t.props,
                        value: t.value
                    }), [
                    p,
                    t.slot,
                    t.name,
                    t.props,
                    t.value
                ]);
                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(L.Provider, {
                    value: b
                }, t.children);
            }, [
            e
        ])
    ];
}
let G = "label";
function U(n, l) {
    var y;
    let a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)(), e = C(), o = (0,_internal_id_js__WEBPACK_IMPORTED_MODULE_2__/* .useProvidedId */ .Q)(), T = (0,_internal_disabled_js__WEBPACK_IMPORTED_MODULE_3__/* .useDisabled */ .B)(), { id: t = "headlessui-label-".concat(a), htmlFor: p = o != null ? o : (y = e.props) == null ? void 0 : y.htmlFor, passive: b = !1, ...i } = n, u = (0,_hooks_use_sync_refs_js__WEBPACK_IMPORTED_MODULE_4__/* .useSyncRefs */ .T)(l);
    (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_5__/* .useIsoMorphicEffect */ .e)(()=>e.register(t), [
        t,
        e.register
    ]);
    let d = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_1__/* .useEvent */ .z)((s)=>{
        let g = s.currentTarget;
        if (!(s.target !== s.currentTarget && _utils_dom_js__WEBPACK_IMPORTED_MODULE_6__/* .isInteractiveElement */ .jF(s.target)) && (_utils_dom_js__WEBPACK_IMPORTED_MODULE_6__/* .isHTMLLabelElement */ .dz(g) && s.preventDefault(), e.props && "onClick" in e.props && typeof e.props.onClick == "function" && e.props.onClick(s), _utils_dom_js__WEBPACK_IMPORTED_MODULE_6__/* .isHTMLLabelElement */ .dz(g))) {
            let r = document.getElementById(g.htmlFor);
            if (r) {
                let E = r.getAttribute("disabled");
                if (E === "true" || E === "") return;
                let x = r.getAttribute("aria-disabled");
                if (x === "true" || x === "") return;
                (_utils_dom_js__WEBPACK_IMPORTED_MODULE_6__/* .isHTMLInputElement */ .LL(r) && (r.type === "file" || r.type === "radio" || r.type === "checkbox") || r.role === "radio" || r.role === "checkbox" || r.role === "switch") && r.click(), r.focus({
                    preventScroll: !0
                });
            }
        }
    }), f = (0,_hooks_use_slot_js__WEBPACK_IMPORTED_MODULE_7__/* .useSlot */ .x)({
        ...e.slot,
        disabled: T || !1
    }), c = {
        ref: u,
        ...e.props,
        id: t,
        htmlFor: p,
        onClick: d
    };
    return b && ("onClick" in c && (delete c.htmlFor, delete c.onClick), "onClick" in i && delete i.onClick), (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_8__/* .useRender */ .L6)()({
        ourProps: c,
        theirProps: i,
        slot: f,
        defaultTag: p ? G : "div",
        name: e.name || "Label"
    });
}
let j = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_8__/* .forwardRefWithAs */ .yV)(U), Z = Object.assign(j, {});



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/mouse.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   t: function() { return /* binding */ g; }
/* harmony export */ });
var g = ((f)=>(f[f.Left = 0] = "Left", f[f.Right = 2] = "Right", f))(g || {});



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/portal/portal.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  h_: function() { return /* binding */ te; }
});

// UNUSED EXPORTS: PortalGroup, useNestedPortals

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/index.js
var react_dom = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
var use_disposables = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-disposables.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-on-unmount.js
var use_on_unmount = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-on-unmount.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-owner.js
var use_owner = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-owner.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var use_sync_refs = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/internal/portal-force-root.js

let e = /*#__PURE__*/ (0,react.createContext)(!1);
function a() {
    return (0,react.useContext)(e);
}
function l(o) {
    return /*#__PURE__*/ t.createElement(e.Provider, {
        value: o.force
    }, o.children);
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/env.js
var env = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/env.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/render.js + 1 modules
var render = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/render.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/components/portal/portal.js
/* __next_internal_client_entry_do_not_use__ Portal,PortalGroup,useNestedPortals auto */ 









function W(e) {
    let o = a(), l = (0,react.useContext)(c), [r, p] = (0,react.useState)(()=>{
        var s;
        if (!o && l !== null) return (s = l.current) != null ? s : null;
        if (env/* env */.O.isServer) return null;
        let t = e == null ? void 0 : e.getElementById("headlessui-portal-root");
        if (t) return t;
        if (e === null) return null;
        let n = e.createElement("div");
        return n.setAttribute("id", "headlessui-portal-root"), e.body.appendChild(n);
    });
    return (0,react.useEffect)(()=>{
        r !== null && (e != null && e.body.contains(r) || e == null || e.body.appendChild(r));
    }, [
        r,
        e
    ]), (0,react.useEffect)(()=>{
        o || l !== null && p(l.current);
    }, [
        l,
        p,
        o
    ]), r;
}
let _ = react.Fragment, j = (0,render/* forwardRefWithAs */.yV)(function(o, l) {
    let { ownerDocument: r = null, ...p } = o, t = (0,react.useRef)(null), n = (0,use_sync_refs/* useSyncRefs */.T)((0,use_sync_refs/* optionalRef */.h)((a)=>{
        t.current = a;
    }), l), s = (0,use_owner/* useOwnerDocument */.i)(t), C = r != null ? r : s, u = W(C), y = (0,react.useContext)(m), g = (0,use_disposables/* useDisposables */.G)(), v = (0,render/* useRender */.L6)();
    return (0,use_on_unmount/* useOnUnmount */.L)(()=>{
        var a;
        u && u.childNodes.length <= 0 && ((a = u.parentElement) == null || a.removeChild(u));
    }), u ? /*#__PURE__*/ (0,react_dom.createPortal)(/*#__PURE__*/ react.createElement("div", {
        "data-headlessui-portal": "",
        ref: (a)=>{
            g.dispose(), y && a && g.add(y.register(a));
        }
    }, v({
        ourProps: {
            ref: n
        },
        theirProps: p,
        slot: {},
        defaultTag: _,
        name: "Portal"
    })), u) : null;
});
function S(e, o) {
    let l = (0,use_sync_refs/* useSyncRefs */.T)(o), { enabled: r = !0, ownerDocument: p, ...t } = e, n = (0,render/* useRender */.L6)();
    return r ? /*#__PURE__*/ react.createElement(j, {
        ...t,
        ownerDocument: p,
        ref: l
    }) : n({
        ourProps: {
            ref: l
        },
        theirProps: t,
        slot: {},
        defaultTag: _,
        name: "Portal"
    });
}
let I = react.Fragment, c = /*#__PURE__*/ (0,react.createContext)(null);
function D(e, o) {
    let { target: l, ...r } = e, t = {
        ref: (0,use_sync_refs/* useSyncRefs */.T)(o)
    }, n = (0,render/* useRender */.L6)();
    return /*#__PURE__*/ react.createElement(c.Provider, {
        value: l
    }, n({
        ourProps: t,
        theirProps: r,
        defaultTag: I,
        name: "Popover.Group"
    }));
}
let m = /*#__PURE__*/ (0,react.createContext)(null);
function ee() {
    let e = P(m), o = x([]), l = L((t)=>(o.current.push(t), e && e.register(t), ()=>r(t))), r = L((t)=>{
        let n = o.current.indexOf(t);
        n !== -1 && o.current.splice(n, 1), e && e.unregister(t);
    }), p = G(()=>({
            register: l,
            unregister: r,
            portals: o
        }), [
        l,
        r,
        o
    ]);
    return [
        o,
        G(()=>function(param) {
                let { children: n } = param;
                return /*#__PURE__*/ i.createElement(m.Provider, {
                    value: p
                }, n);
            }, [
            p
        ])
    ];
}
let J = (0,render/* forwardRefWithAs */.yV)(S), X = (0,render/* forwardRefWithAs */.yV)(D), te = Object.assign(J, {
    Group: X
});



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-active-press.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: function() { return /* binding */ w; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _utils_owner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/owner.js");
/* harmony import */ var _use_disposables_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-disposables.js");
/* harmony import */ var _use_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");




function E(e) {
    let t = e.width / 2, n = e.height / 2;
    return {
        top: e.clientY - n,
        right: e.clientX + t,
        bottom: e.clientY + n,
        left: e.clientX - t
    };
}
function P(e, t) {
    return !(!e || !t || e.right < t.left || e.left > t.right || e.bottom < t.top || e.top > t.bottom);
}
function w() {
    let { disabled: e = !1 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), [n, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), r = (0,_use_disposables_js__WEBPACK_IMPORTED_MODULE_1__/* .useDisposables */ .G)(), o = (0,_use_event_js__WEBPACK_IMPORTED_MODULE_2__/* .useEvent */ .z)(()=>{
        t.current = null, l(!1), r.dispose();
    }), f = (0,_use_event_js__WEBPACK_IMPORTED_MODULE_2__/* .useEvent */ .z)((s)=>{
        if (r.dispose(), t.current === null) {
            t.current = s.currentTarget, l(!0);
            {
                let i = (0,_utils_owner_js__WEBPACK_IMPORTED_MODULE_3__/* .getOwnerDocument */ .r)(s.currentTarget);
                r.addEventListener(i, "pointerup", o, !1), r.addEventListener(i, "pointermove", (c)=>{
                    if (t.current) {
                        let p = E(c);
                        l(P(p, t.current.getBoundingClientRect()));
                    }
                }, !1), r.addEventListener(i, "pointercancel", o, !1);
            }
        }
    });
    return {
        pressed: n,
        pressProps: e ? {} : {
            onPointerDown: f,
            onPointerUp: o,
            onClick: o
        }
    };
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-by-comparator.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: function() { return /* binding */ u; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");

function l(e, r) {
    return e !== null && r !== null && typeof e == "object" && typeof r == "object" && "id" in e && "id" in r ? e.id === r.id : e === r;
}
function u() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : l;
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((r, t)=>{
        if (typeof e == "string") {
            let o = e;
            return (r == null ? void 0 : r[o]) === (t == null ? void 0 : t[o]);
        }
        return e(r, t);
    }, [
        e
    ]);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-controllable.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: function() { return /* binding */ b; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js");
/* harmony import */ var _use_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");



function b(l, r, c) {
    let [i, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(c), e = l !== void 0, t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(e), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1);
    return e && !t.current && !u.current ? (u.current = !0, t.current = e, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !e && t.current && !d.current && (d.current = !0, t.current = e, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [
        e ? l : i,
        (0,_use_event_js__WEBPACK_IMPORTED_MODULE_2__/* .useEvent */ .z)((n)=>(e || (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>s(n)), r == null ? void 0 : r(n)))
    ];
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-default-value.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: function() { return /* binding */ l; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");

function l(e) {
    let [t] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e);
    return t;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-disposables.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: function() { return /* binding */ p; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _utils_disposables_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js");


function p() {
    let [e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_utils_disposables_js__WEBPACK_IMPORTED_MODULE_1__/* .disposables */ .k);
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>()=>e.dispose(), [
        e
    ]), e;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-document-event.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: function() { return /* binding */ i; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _use_latest_value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js");


function i(t, e, o, n) {
    let u = (0,_use_latest_value_js__WEBPACK_IMPORTED_MODULE_1__/* .useLatestValue */ .E)(o);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        if (!t) return;
        function r(m) {
            u.current(m);
        }
        return document.addEventListener(e, r, n), ()=>document.removeEventListener(e, r, n);
    }, [
        t,
        e,
        n
    ]);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-element-size.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: function() { return /* binding */ w; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _utils_disposables_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js");
/* harmony import */ var _use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");



function h(i) {
    if (i === null) return {
        width: 0,
        height: 0
    };
    let { width: t, height: e } = i.getBoundingClientRect();
    return {
        width: t,
        height: e
    };
}
function w(i, t) {
    let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    let [r, f] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>h(t));
    return (0,_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__/* .useIsoMorphicEffect */ .e)(()=>{
        if (!t || !i) return;
        let n = (0,_utils_disposables_js__WEBPACK_IMPORTED_MODULE_2__/* .disposables */ .k)();
        return n.requestAnimationFrame(function s() {
            n.requestAnimationFrame(s), f((u)=>{
                let o = h(t);
                return o.width === u.width && o.height === u.height ? u : o;
            });
        }), ()=>{
            n.dispose();
        };
    }, [
        t,
        i
    ]), e ? {
        width: "".concat(r.width, "px"),
        height: "".concat(r.height, "px")
    } : r;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   z: function() { return /* binding */ o; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _use_latest_value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js");


let o = function(t) {
    let e = (0,_use_latest_value_js__WEBPACK_IMPORTED_MODULE_1__/* .useLatestValue */ .E)(t);
    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function() {
        for(var _len = arguments.length, r = new Array(_len), _key = 0; _key < _len; _key++){
            r[_key] = arguments[_key];
        }
        return e.current(...r);
    }, [
        e
    ]);
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-inert-others.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   s: function() { return /* binding */ y; }
/* harmony export */ });
/* harmony import */ var _utils_disposables_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js");
/* harmony import */ var _utils_owner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/owner.js");
/* harmony import */ var _use_is_top_layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-is-top-layer.js");
/* harmony import */ var _use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");




let f = new Map, u = new Map;
function h(t) {
    var e;
    let r = (e = u.get(t)) != null ? e : 0;
    return u.set(t, r + 1), r !== 0 ? ()=>m(t) : (f.set(t, {
        "aria-hidden": t.getAttribute("aria-hidden"),
        inert: t.inert
    }), t.setAttribute("aria-hidden", "true"), t.inert = !0, ()=>m(t));
}
function m(t) {
    var i;
    let r = (i = u.get(t)) != null ? i : 1;
    if (r === 1 ? u.delete(t) : u.set(t, r - 1), r !== 1) return;
    let e = f.get(t);
    e && (e["aria-hidden"] === null ? t.removeAttribute("aria-hidden") : t.setAttribute("aria-hidden", e["aria-hidden"]), t.inert = e.inert, f.delete(t));
}
function y(t) {
    let { allowed: r, disallowed: e } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let i = (0,_use_is_top_layer_js__WEBPACK_IMPORTED_MODULE_0__/* .useIsTopLayer */ .g)(t, "inert-others");
    (0,_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__/* .useIsoMorphicEffect */ .e)(()=>{
        var d, c;
        if (!i) return;
        let a = (0,_utils_disposables_js__WEBPACK_IMPORTED_MODULE_2__/* .disposables */ .k)();
        for (let n of (d = e == null ? void 0 : e()) != null ? d : [])n && a.add(h(n));
        let s = (c = r == null ? void 0 : r()) != null ? c : [];
        for (let n of s){
            if (!n) continue;
            let l = (0,_utils_owner_js__WEBPACK_IMPORTED_MODULE_3__/* .getOwnerDocument */ .r)(n);
            if (!l) continue;
            let o = n.parentElement;
            for(; o && o !== l.body;){
                for (let p of o.children)s.some((E)=>p.contains(E)) || a.add(h(p));
                o = o.parentElement;
            }
        }
        return a.dispose;
    }, [
        i,
        r,
        e
    ]);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-is-top-layer.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: function() { return /* binding */ I; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _machines_stack_machine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/machines/stack-machine.js");
/* harmony import */ var _react_glue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/react-glue.js");
/* harmony import */ var _use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");




function I(o, s) {
    let t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)(), r = _machines_stack_machine_js__WEBPACK_IMPORTED_MODULE_1__/* .stackMachines */ .n.get(s), [i, c] = (0,_react_glue_js__WEBPACK_IMPORTED_MODULE_2__/* .useSlice */ .M)(r, (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>[
            r.selectors.isTop(e, t),
            r.selectors.inStack(e, t)
        ], [
        r,
        t
    ]));
    return (0,_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_3__/* .useIsoMorphicEffect */ .e)(()=>{
        if (o) return r.actions.push(t), ()=>r.actions.pop(t);
    }, [
        r,
        o,
        t
    ]), o ? c ? i : !0 : !1;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: function() { return /* binding */ n; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/env.js");


let n = (e, t)=>{
    _utils_env_js__WEBPACK_IMPORTED_MODULE_1__/* .env */ .O.isServer ? (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(e, t) : (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(e, t);
};



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: function() { return /* binding */ s; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");


function s(e) {
    let r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(e);
    return (0,_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__/* .useIsoMorphicEffect */ .e)(()=>{
        r.current = e;
    }, [
        e
    ]), r;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-on-disappear.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   m: function() { return /* binding */ p; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _utils_disposables_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js");
/* harmony import */ var _use_latest_value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js");




function p(s, n, o) {
    let i = (0,_use_latest_value_js__WEBPACK_IMPORTED_MODULE_1__/* .useLatestValue */ .E)((t)=>{
        let e = t.getBoundingClientRect();
        e.x === 0 && e.y === 0 && e.width === 0 && e.height === 0 && o();
    });
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        if (!s) return;
        let t = n === null ? null : _utils_dom_js__WEBPACK_IMPORTED_MODULE_2__/* .isHTMLElement */ .Re(n) ? n : n.current;
        if (!t) return;
        let e = (0,_utils_disposables_js__WEBPACK_IMPORTED_MODULE_3__/* .disposables */ .k)();
        if (typeof ResizeObserver != "undefined") {
            let r = new ResizeObserver(()=>i.current(t));
            r.observe(t), e.add(()=>r.disconnect());
        }
        if (typeof IntersectionObserver != "undefined") {
            let r = new IntersectionObserver(()=>i.current(t));
            r.observe(t), e.add(()=>r.disconnect());
        }
        return ()=>e.dispose();
    }, [
        n,
        i,
        s
    ]);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-on-unmount.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: function() { return /* binding */ c; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _utils_micro_task_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/micro-task.js");
/* harmony import */ var _use_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");



function c(t) {
    let r = (0,_use_event_js__WEBPACK_IMPORTED_MODULE_1__/* .useEvent */ .z)(t), e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>(e.current = !1, ()=>{
            e.current = !0, (0,_utils_micro_task_js__WEBPACK_IMPORTED_MODULE_2__/* .microTask */ .Y)(()=>{
                e.current && r();
            });
        }), [
        r
    ]);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  O: function() { return /* binding */ k; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/dom.js
var dom = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/focus-management.js
var focus_management = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/focus-management.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/platform.js
var platform = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/platform.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-document-event.js
var use_document_event = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-document-event.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js
var use_latest_value = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-window-event.js


function use_window_event_s(t, e, o, n) {
    let i = (0,use_latest_value/* useLatestValue */.E)(o);
    (0,react.useEffect)(()=>{
        if (!t) return;
        function r(d) {
            i.current(d);
        }
        return window.addEventListener(e, r, n), ()=>window.removeEventListener(e, r, n);
    }, [
        t,
        e,
        n
    ]);
}


;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js







const C = 30;
function k(o, f, h) {
    let m = (0,use_latest_value/* useLatestValue */.E)(h), s = (0,react.useCallback)(function(e, c) {
        if (e.defaultPrevented) return;
        let r = c(e);
        if (r === null || !r.getRootNode().contains(r) || !r.isConnected) return;
        let M = function u(n) {
            return typeof n == "function" ? u(n()) : Array.isArray(n) || n instanceof Set ? n : [
                n
            ];
        }(f);
        for (let u of M)if (u !== null && (u.contains(r) || e.composed && e.composedPath().includes(u))) return;
        return !(0,focus_management/* isFocusableElement */.sP)(r, focus_management/* FocusableMode */.tJ.Loose) && r.tabIndex !== -1 && e.preventDefault(), m.current(e, r);
    }, [
        m,
        f
    ]), i = (0,react.useRef)(null);
    (0,use_document_event/* useDocumentEvent */.I)(o, "pointerdown", (t)=>{
        var e, c;
        (0,platform/* isMobile */.tq)() || (i.current = ((c = (e = t.composedPath) == null ? void 0 : e.call(t)) == null ? void 0 : c[0]) || t.target);
    }, !0), (0,use_document_event/* useDocumentEvent */.I)(o, "pointerup", (t)=>{
        if ((0,platform/* isMobile */.tq)() || !i.current) return;
        let e = i.current;
        return i.current = null, s(t, ()=>e);
    }, !0);
    let l = (0,react.useRef)({
        x: 0,
        y: 0
    });
    (0,use_document_event/* useDocumentEvent */.I)(o, "touchstart", (t)=>{
        l.current.x = t.touches[0].clientX, l.current.y = t.touches[0].clientY;
    }, !0), (0,use_document_event/* useDocumentEvent */.I)(o, "touchend", (t)=>{
        let e = {
            x: t.changedTouches[0].clientX,
            y: t.changedTouches[0].clientY
        };
        if (!(Math.abs(e.x - l.current.x) >= C || Math.abs(e.y - l.current.y) >= C)) return s(t, ()=>dom/* isHTMLorSVGElement */.sP(t.target) ? t.target : null);
    }, !0), use_window_event_s(o, "blur", (t)=>s(t, ()=>dom/* isHTMLIframeElement */.jQ(window.document.activeElement) ? window.document.activeElement : null), !0);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-owner.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: function() { return /* binding */ n; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _utils_owner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/owner.js");


function n() {
    for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){
        e[_key] = arguments[_key];
    }
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_utils_owner_js__WEBPACK_IMPORTED_MODULE_1__/* .getOwnerDocument */ .r)(...e), [
        ...e
    ]);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-quick-release.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: function() { return /* binding */ L; },
/* harmony export */   a: function() { return /* binding */ S; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js");
/* harmony import */ var _use_document_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-document-event.js");



var H = ((e)=>(e[e.Ignore = 0] = "Ignore", e[e.Select = 1] = "Select", e[e.Close = 2] = "Close", e))(H || {});
const S = {
    Ignore: {
        kind: 0
    },
    Select: (r)=>({
            kind: 1,
            target: r
        }),
    Close: {
        kind: 2
    }
}, M = 200, f = 5;
function L(r, param) {
    let { trigger: n, action: T, close: e, select: p } = param;
    let l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    (0,_use_document_event_js__WEBPACK_IMPORTED_MODULE_1__/* .useDocumentEvent */ .I)(r && n !== null, "pointerdown", (t)=>{
        _utils_dom_js__WEBPACK_IMPORTED_MODULE_2__/* .isNode */ .UG(t == null ? void 0 : t.target) && n != null && n.contains(t.target) && (i.current = t.x, u.current = t.y, l.current = t.timeStamp);
    }), (0,_use_document_event_js__WEBPACK_IMPORTED_MODULE_1__/* .useDocumentEvent */ .I)(r && n !== null, "pointerup", (t)=>{
        var s, m;
        let c = l.current;
        if (c === null || (l.current = null, !_utils_dom_js__WEBPACK_IMPORTED_MODULE_2__/* .isHTMLorSVGElement */ .sP(t.target)) || Math.abs(t.x - ((s = i.current) != null ? s : t.x)) < f && Math.abs(t.y - ((m = u.current) != null ? m : t.y)) < f) return;
        let a = T(t);
        switch(a.kind){
            case 0:
                return;
            case 1:
                {
                    t.timeStamp - c > M && (p(a.target), e());
                    break;
                }
            case 2:
                {
                    e();
                    break;
                }
        }
    }, {
        capture: !0
    });
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: function() { return /* binding */ e; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");

function e(t, u) {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{
        var n;
        if (t.type) return t.type;
        let r = (n = t.as) != null ? n : "button";
        if (typeof r == "string" && r.toLowerCase() === "button" || (u == null ? void 0 : u.tagName) === "BUTTON" && !u.hasAttribute("type")) return "button";
    }, [
        t.type,
        t.as,
        u
    ]);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-scroll-lock.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  P: function() { return /* binding */ f; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-store.js

function use_store_o(t) {
    return (0,react.useSyncExternalStore)(t.subscribe, t.getSnapshot, t.getSnapshot);
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var use_iso_morphic_effect = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/disposables.js
var disposables = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/utils/store.js
function a(o, r) {
    let t = o(), n = new Set;
    return {
        getSnapshot () {
            return t;
        },
        subscribe (e) {
            return n.add(e), ()=>n.delete(e);
        },
        dispatch (e) {
            for(var _len = arguments.length, s = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                s[_key - 1] = arguments[_key];
            }
            let i = r[e].call(t, ...s);
            i && (t = i, n.forEach((c)=>c()));
        }
    };
}


;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/document-overflow/adjust-scrollbar-padding.js
function d() {
    let r;
    return {
        before (param) {
            let { doc: e } = param;
            var l;
            let o = e.documentElement, t = (l = e.defaultView) != null ? l : window;
            r = Math.max(0, t.innerWidth - o.clientWidth);
        },
        after (param) {
            let { doc: e, d: o } = param;
            let t = e.documentElement, l = Math.max(0, t.clientWidth - t.offsetWidth), n = Math.max(0, r - l);
            o.style(t, "paddingRight", "".concat(n, "px"));
        }
    };
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/dom.js
var dom = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/platform.js
var platform = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/platform.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/document-overflow/handle-ios-locking.js



function w() {
    return (0,platform/* isIOS */.gn)() ? {
        before (param) {
            let { doc: n, d: l, meta: f } = param;
            function i(a) {
                return f.containers.flatMap((r)=>r()).some((r)=>r.contains(a));
            }
            l.microTask(()=>{
                var c;
                if (window.getComputedStyle(n.documentElement).scrollBehavior !== "auto") {
                    let t = (0,disposables/* disposables */.k)();
                    t.style(n.documentElement, "scrollBehavior", "auto"), l.add(()=>l.microTask(()=>t.dispose()));
                }
                let a = (c = window.scrollY) != null ? c : window.pageYOffset, r = null;
                l.addEventListener(n, "click", (t)=>{
                    if (dom/* isHTMLorSVGElement */.sP(t.target)) try {
                        let e = t.target.closest("a");
                        if (!e) return;
                        let { hash: m } = new URL(e.href), s = n.querySelector(m);
                        dom/* isHTMLorSVGElement */.sP(s) && !i(s) && (r = s);
                    } catch (e) {}
                }, !0), l.addEventListener(n, "touchstart", (t)=>{
                    if (dom/* isHTMLorSVGElement */.sP(t.target) && dom/* hasInlineStyle */.nR(t.target)) if (i(t.target)) {
                        let e = t.target;
                        for(; e.parentElement && i(e.parentElement);)e = e.parentElement;
                        l.style(e, "overscrollBehavior", "contain");
                    } else l.style(t.target, "touchAction", "none");
                }), l.addEventListener(n, "touchmove", (t)=>{
                    if (dom/* isHTMLorSVGElement */.sP(t.target)) {
                        if (dom/* isHTMLInputElement */.LL(t.target)) return;
                        if (i(t.target)) {
                            let e = t.target;
                            for(; e.parentElement && e.dataset.headlessuiPortal !== "" && !(e.scrollHeight > e.clientHeight || e.scrollWidth > e.clientWidth);)e = e.parentElement;
                            e.dataset.headlessuiPortal === "" && t.preventDefault();
                        } else t.preventDefault();
                    }
                }, {
                    passive: !1
                }), l.add(()=>{
                    var e;
                    let t = (e = window.scrollY) != null ? e : window.pageYOffset;
                    a !== t && window.scrollTo(0, a), r && r.isConnected && (r.scrollIntoView({
                        block: "nearest"
                    }), r = null);
                });
            });
        }
    } : {};
}


;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/document-overflow/prevent-scroll.js
function r() {
    return {
        before (param) {
            let { doc: e, d: o } = param;
            o.style(e.documentElement, "overflow", "hidden");
        }
    };
}


;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/document-overflow/overflow-store.js





function m(e) {
    let n = {};
    for (let t of e)Object.assign(n, t(n));
    return n;
}
let overflow_store_a = a(()=>new Map, {
    PUSH (e, n) {
        var o;
        let t = (o = this.get(e)) != null ? o : {
            doc: e,
            count: 0,
            d: (0,disposables/* disposables */.k)(),
            meta: new Set
        };
        return t.count++, t.meta.add(n), this.set(e, t), this;
    },
    POP (e, n) {
        let t = this.get(e);
        return t && (t.count--, t.meta.delete(n)), this;
    },
    SCROLL_PREVENT (param) {
        let { doc: e, d: n, meta: t } = param;
        let o = {
            doc: e,
            d: n,
            meta: m(t)
        }, c = [
            w(),
            d(),
            r()
        ];
        c.forEach((param)=>{
            let { before: r } = param;
            return r == null ? void 0 : r(o);
        }), c.forEach((param)=>{
            let { after: r } = param;
            return r == null ? void 0 : r(o);
        });
    },
    SCROLL_ALLOW (param) {
        let { d: e } = param;
        e.dispose();
    },
    TEARDOWN (param) {
        let { doc: e } = param;
        this.delete(e);
    }
});
overflow_store_a.subscribe(()=>{
    let e = overflow_store_a.getSnapshot(), n = new Map;
    for (let [t] of e)n.set(t, t.documentElement.style.overflow);
    for (let t of e.values()){
        let o = n.get(t.doc) === "hidden", c = t.count !== 0;
        (c && !o || !c && o) && overflow_store_a.dispatch(t.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t), t.count === 0 && overflow_store_a.dispatch("TEARDOWN", t);
    }
});


;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/document-overflow/use-document-overflow.js



function use_document_overflow_a(r, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ()=>({
            containers: []
        });
    let f = use_store_o(overflow_store_a), o = e ? f.get(e) : void 0, i = o ? o.count > 0 : !1;
    return (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        if (!(!e || !r)) return overflow_store_a.dispatch("PUSH", e, n), ()=>overflow_store_a.dispatch("POP", e, n);
    }, [
        r,
        e
    ]), i;
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-is-top-layer.js
var use_is_top_layer = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-is-top-layer.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-scroll-lock.js


function f(e, c) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ()=>[
            document.body
        ];
    let r = (0,use_is_top_layer/* useIsTopLayer */.g)(e, "scroll-lock");
    use_document_overflow_a(r, c, (t)=>{
        var o;
        return {
            containers: [
                ...(o = t.containers) != null ? o : [],
                n
            ]
        };
    });
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-slot.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: function() { return /* binding */ n; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");

function n(e) {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>e, Object.values(e));
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: function() { return /* binding */ y; },
/* harmony export */   h: function() { return /* binding */ T; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _use_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");


let u = Symbol();
function T(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return Object.assign(t, {
        [u]: n
    });
}
function y() {
    for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
        t[_key] = arguments[_key];
    }
    let n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        n.current = t;
    }, [
        t
    ]);
    let c = (0,_use_event_js__WEBPACK_IMPORTED_MODULE_1__/* .useEvent */ .z)((e)=>{
        for (let o of n.current)o != null && (typeof o == "function" ? o(e) : o.current = e);
    });
    return t.every((e)=>e == null || (e == null ? void 0 : e[u])) ? void 0 : c;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-text-value.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  x: function() { return /* binding */ s; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/dom.js
var dom = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/utils/get-text-value.js

let a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o(e) {
    var l, n;
    let i = (l = e.innerText) != null ? l : "", t = e.cloneNode(!0);
    if (!dom/* isHTMLElement */.Re(t)) return i;
    let u = !1;
    for (let f of t.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))f.remove(), u = !0;
    let r = u ? (n = t.innerText) != null ? n : "" : i;
    return a.test(r) && (r = r.replace(a, "")), r;
}
function F(e) {
    let i = e.getAttribute("aria-label");
    if (typeof i == "string") return i.trim();
    let t = e.getAttribute("aria-labelledby");
    if (t) {
        let u = t.split(" ").map((r)=>{
            let l = document.getElementById(r);
            if (l) {
                let n = l.getAttribute("aria-label");
                return typeof n == "string" ? n.trim() : o(l).trim();
            }
            return null;
        }).filter(Boolean);
        if (u.length > 0) return u.join(", ");
    }
    return o(e).trim();
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-event.js
var use_event = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-text-value.js



function s(c) {
    let t = (0,react.useRef)(""), r = (0,react.useRef)("");
    return (0,use_event/* useEvent */.z)(()=>{
        let e = c.current;
        if (!e) return "";
        let u = e.innerText;
        if (t.current === u) return r.current;
        let n = F(e).trim().toLowerCase();
        return t.current = u, r.current = n, n;
    });
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: function() { return /* binding */ u; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");

function t(e) {
    return [
        e.screenX,
        e.screenY
    ];
}
function u() {
    let e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([
        -1,
        -1
    ]);
    return {
        wasMoved (r) {
            let n = t(r);
            return e.current[0] === n[0] && e.current[1] === n[1] ? !1 : (e.current = n, !0);
        },
        update (r) {
            e.current = t(r);
        }
    };
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-transition.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  X: function() { return /* binding */ R; },
  Y: function() { return /* binding */ x; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/disposables.js
var disposables = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
var use_disposables = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-disposables.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-flags.js

function c() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let [r, a] = (0,react.useState)(u), g = (0,react.useCallback)((e)=>a(e), []), s = (0,react.useCallback)((e)=>a((l)=>l | e), []), m = (0,react.useCallback)((e)=>(r & e) === e, [
        r
    ]), n = (0,react.useCallback)((e)=>a((l)=>l & ~e), []), F = (0,react.useCallback)((e)=>a((l)=>l ^ e), []);
    return {
        flags: r,
        setFlag: g,
        addFlag: s,
        hasFlag: m,
        removeFlag: n,
        toggleFlag: F
    };
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var use_iso_morphic_effect = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-transition.js
/* provided dependency */ var process = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js");
var T, b;





typeof process != "undefined" && typeof globalThis != "undefined" && typeof Element != "undefined" && ((T = process == null ? void 0 : process.env) == null ? void 0 : T["NODE_ENV"]) === "test" && typeof ((b = Element == null ? void 0 : Element.prototype) == null ? void 0 : b.getAnimations) == "undefined" && (Element.prototype.getAnimations = function() {
    return console.warn([
        "Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.",
        "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.",
        "",
        "Example usage:",
        "```js",
        "import { mockAnimationsApi } from 'jsdom-testing-mocks'",
        "mockAnimationsApi()",
        "```"
    ].join("\n")), [];
});
var L = ((r)=>(r[r.None = 0] = "None", r[r.Closed = 1] = "Closed", r[r.Enter = 2] = "Enter", r[r.Leave = 4] = "Leave", r))(L || {});
function R(t) {
    let n = {};
    for(let e in t)t[e] === !0 && (n["data-".concat(e)] = "");
    return n;
}
function x(t, n, e, i) {
    let [r, o] = (0,react.useState)(e), { hasFlag: s, addFlag: a, removeFlag: l } = c(t && r ? 3 : 0), u = (0,react.useRef)(!1), f = (0,react.useRef)(!1), E = (0,use_disposables/* useDisposables */.G)();
    return (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        var d;
        if (t) {
            if (e && o(!0), !n) {
                e && a(3);
                return;
            }
            return (d = i == null ? void 0 : i.start) == null || d.call(i, e), C(n, {
                inFlight: u,
                prepare () {
                    f.current ? f.current = !1 : f.current = u.current, u.current = !0, !f.current && (e ? (a(3), l(4)) : (a(4), l(2)));
                },
                run () {
                    f.current ? e ? (l(3), a(4)) : (l(4), a(3)) : e ? l(1) : a(1);
                },
                done () {
                    var p;
                    f.current && typeof n.getAnimations == "function" && n.getAnimations().length > 0 || (u.current = !1, l(7), e || o(!1), (p = i == null ? void 0 : i.end) == null || p.call(i, e));
                }
            });
        }
    }, [
        t,
        e,
        n,
        E
    ]), t ? [
        r,
        {
            closed: s(1),
            enter: s(2),
            leave: s(4),
            transition: s(2) || s(4)
        }
    ] : [
        e,
        {
            closed: void 0,
            enter: void 0,
            leave: void 0,
            transition: void 0
        }
    ];
}
function C(t, param) {
    let { prepare: n, run: e, done: i, inFlight: r } = param;
    let o = (0,disposables/* disposables */.k)();
    return j(t, {
        prepare: n,
        inFlight: r
    }), o.nextFrame(()=>{
        e(), o.requestAnimationFrame(()=>{
            o.add(M(t, i));
        });
    }), o.dispose;
}
function M(t, n) {
    var o, s;
    let e = (0,disposables/* disposables */.k)();
    if (!t) return e.dispose;
    let i = !1;
    e.add(()=>{
        i = !0;
    });
    let r = (s = (o = t.getAnimations) == null ? void 0 : o.call(t).filter((a)=>a instanceof CSSTransition)) != null ? s : [];
    return r.length === 0 ? (n(), e.dispose) : (Promise.allSettled(r.map((a)=>a.finished)).then(()=>{
        i || n();
    }), e.dispose);
}
function j(t, param) {
    let { inFlight: n, prepare: e } = param;
    if (n != null && n.current) {
        e();
        return;
    }
    let i = t.style.transition;
    t.style.transition = "none", e(), t.offsetHeight, t.style.transition = i;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: function() { return /* binding */ F; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _utils_owner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/owner.js");
/* harmony import */ var _use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");



function F(c, param) {
    let { container: e, accept: t, walk: r } = param;
    let o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(r);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        o.current = t, l.current = r;
    }, [
        t,
        r
    ]), (0,_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__/* .useIsoMorphicEffect */ .e)(()=>{
        if (!e || !c) return;
        let n = (0,_utils_owner_js__WEBPACK_IMPORTED_MODULE_2__/* .getOwnerDocument */ .r)(e);
        if (!n) return;
        let f = o.current, p = l.current, i = Object.assign((m)=>f(m), {
            acceptNode: f
        }), u = n.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, i, !1);
        for(; u.nextNode();)p(u.currentNode);
    }, [
        e,
        c,
        o,
        l
    ]);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/disabled.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: function() { return /* binding */ a; }
/* harmony export */ });
/* unused harmony export DisabledProvider */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");

let e = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);
function a() {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(e);
}
function l(param) {
    let { value: t, children: o } = param;
    return /*#__PURE__*/ n.createElement(e.Provider, {
        value: t
    }, o);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/floating.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AZ: function() { return /* binding */ Fe; },
/* harmony export */   ES: function() { return /* binding */ Re; },
/* harmony export */   HO: function() { return /* binding */ Ae; },
/* harmony export */   L: function() { return /* binding */ be; },
/* harmony export */   U8: function() { return /* binding */ Te; },
/* harmony export */   Vy: function() { return /* binding */ ye; }
/* harmony export */ });
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@floating-ui/react/dist/floating-ui.react.mjs");
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs");
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("(app-pages-browser)/../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var _hooks_use_disposables_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-disposables.js");
/* harmony import */ var _hooks_use_event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");
/* harmony import */ var _hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js");







let y = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
    styles: void 0,
    setReference: ()=>{},
    setFloating: ()=>{},
    getReferenceProps: ()=>({}),
    getFloatingProps: ()=>({}),
    slot: {}
});
y.displayName = "FloatingContext";
let $ = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
$.displayName = "PlacementContext";
function ye(e) {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>e ? typeof e == "string" ? {
            to: e
        } : e : null, [
        e
    ]);
}
function Fe() {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(y).setReference;
}
function be() {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(y).getReferenceProps;
}
function Te() {
    let { getFloatingProps: e, slot: t } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(y);
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {
        for(var _len = arguments.length, n = new Array(_len), _key = 0; _key < _len; _key++){
            n[_key] = arguments[_key];
        }
        return Object.assign({}, e(...n), {
            "data-anchor": t.anchor
        });
    }, [
        e,
        t
    ]);
}
function Re() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    e === !1 && (e = null), typeof e == "string" && (e = {
        to: e
    });
    let t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)($), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>e, [
        JSON.stringify(e, (l, o)=>{
            var u;
            return (u = o == null ? void 0 : o.outerHTML) != null ? u : o;
        })
    ]);
    (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__/* .useIsoMorphicEffect */ .e)(()=>{
        t == null || t(n != null ? n : null);
    }, [
        t,
        n
    ]);
    let r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(y);
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[
            r.setFloating,
            e ? r.styles : {}
        ], [
        r.setFloating,
        e,
        r.styles
    ]);
}
let D = 4;
function Ae(param) {
    let { children: e, enabled: t = !0 } = param;
    let [n, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [l, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), [f, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);
    ce(f);
    let i = t && n !== null && f !== null, { to: F = "bottom", gap: E = 0, offset: A = 0, padding: c = 0, inner: h } = ge(n, f), [a, p = "center"] = F.split(" ");
    (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__/* .useIsoMorphicEffect */ .e)(()=>{
        i && o(0);
    }, [
        i
    ]);
    let { refs: b, floatingStyles: S, context: g } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_2__/* .useFloating */ .YF)({
        open: i,
        placement: a === "selection" ? p === "center" ? "bottom" : "bottom-".concat(p) : p === "center" ? "".concat(a) : "".concat(a, "-").concat(p),
        strategy: "absolute",
        transform: !1,
        middleware: [
            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_3__/* .offset */ .cv)({
                mainAxis: a === "selection" ? 0 : E,
                crossAxis: A
            }),
            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_3__/* .shift */ .uY)({
                padding: c
            }),
            a !== "selection" && (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_3__/* .flip */ .RR)({
                padding: c
            }),
            a === "selection" && h ? (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_2__/* .inner */ .aN)({
                ...h,
                padding: c,
                overflowRef: u,
                offset: l,
                minItemsVisible: D,
                referenceOverflowThreshold: c,
                onFallbackChange (P) {
                    var L, N;
                    if (!P) return;
                    let d = g.elements.floating;
                    if (!d) return;
                    let M = parseFloat(getComputedStyle(d).scrollPaddingBottom) || 0, I = Math.min(D, d.childElementCount), W = 0, B = 0;
                    for (let m of (N = (L = g.elements.floating) == null ? void 0 : L.childNodes) != null ? N : [])if (_utils_dom_js__WEBPACK_IMPORTED_MODULE_4__/* .isHTMLElement */ .Re(m)) {
                        let x = m.offsetTop, k = x + m.clientHeight + M, H = d.scrollTop, U = H + d.clientHeight;
                        if (x >= H && k <= U) I--;
                        else {
                            B = Math.max(0, Math.min(k, U) - Math.max(x, H)), W = m.clientHeight;
                            break;
                        }
                    }
                    I >= 1 && o((m)=>{
                        let x = W * I - B + M;
                        return m >= x ? m : x;
                    });
                }
            }) : null,
            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_3__/* .size */ .dp)({
                padding: c,
                apply (param) {
                    let { availableWidth: P, availableHeight: d, elements: M } = param;
                    Object.assign(M.floating.style, {
                        overflow: "auto",
                        maxWidth: "".concat(P, "px"),
                        maxHeight: "min(var(--anchor-max-height, 100vh), ".concat(d, "px)")
                    });
                }
            })
        ].filter(Boolean),
        whileElementsMounted: _floating_ui_react__WEBPACK_IMPORTED_MODULE_5__/* .autoUpdate */ .Me
    }), [w = a, V = p] = g.placement.split("-");
    a === "selection" && (w = "selection");
    let G = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({
            anchor: [
                w,
                V
            ].filter(Boolean).join(" ")
        }), [
        w,
        V
    ]), K = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_2__/* .useInnerOffset */ .Rz)(g, {
        overflowRef: u,
        onChange: o
    }), { getReferenceProps: Q, getFloatingProps: X } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_2__/* .useInteractions */ .NI)([
        K
    ]), Y = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_6__/* .useEvent */ .z)((P)=>{
        s(P), b.setFloating(P);
    });
    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement($.Provider, {
        value: r
    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(y.Provider, {
        value: {
            setFloating: Y,
            setReference: b.setReference,
            styles: S,
            getReferenceProps: Q,
            getFloatingProps: X,
            slot: G
        }
    }, e));
}
function ce(e) {
    (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__/* .useIsoMorphicEffect */ .e)(()=>{
        if (!e) return;
        let t = new MutationObserver(()=>{
            let n = window.getComputedStyle(e).maxHeight, r = parseFloat(n);
            if (isNaN(r)) return;
            let l = parseInt(n);
            isNaN(l) || r !== l && (e.style.maxHeight = "".concat(Math.ceil(r), "px"));
        });
        return t.observe(e, {
            attributes: !0,
            attributeFilter: [
                "style"
            ]
        }), ()=>{
            t.disconnect();
        };
    }, [
        e
    ]);
}
function ge(e, t) {
    var o, u, f;
    let n = O((o = e == null ? void 0 : e.gap) != null ? o : "var(--anchor-gap, 0)", t), r = O((u = e == null ? void 0 : e.offset) != null ? u : "var(--anchor-offset, 0)", t), l = O((f = e == null ? void 0 : e.padding) != null ? f : "var(--anchor-padding, 0)", t);
    return {
        ...e,
        gap: n,
        offset: r,
        padding: l
    };
}
function O(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    let r = (0,_hooks_use_disposables_js__WEBPACK_IMPORTED_MODULE_7__/* .useDisposables */ .G)(), l = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_6__/* .useEvent */ .z)((s, i)=>{
        if (s == null) return [
            n,
            null
        ];
        if (typeof s == "number") return [
            s,
            null
        ];
        if (typeof s == "string") {
            if (!i) return [
                n,
                null
            ];
            let F = J(s, i);
            return [
                F,
                (E)=>{
                    let A = q(s);
                    {
                        let c = A.map((h)=>window.getComputedStyle(i).getPropertyValue(h));
                        r.requestAnimationFrame(function h() {
                            r.nextFrame(h);
                            let a = !1;
                            for (let [b, S] of A.entries()){
                                let g = window.getComputedStyle(i).getPropertyValue(S);
                                if (c[b] !== g) {
                                    c[b] = g, a = !0;
                                    break;
                                }
                            }
                            if (!a) return;
                            let p = J(s, i);
                            F !== p && (E(p), F = p);
                        });
                    }
                    return r.dispose;
                }
            ];
        }
        return [
            n,
            null
        ];
    }), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>l(e, t)[0], [
        e,
        t
    ]), [u = o, f] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();
    return (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__/* .useIsoMorphicEffect */ .e)(()=>{
        let [s, i] = l(e, t);
        if (f(s), !!i) return i(f);
    }, [
        e,
        t
    ]), u;
}
function q(e) {
    let t = /var\((.*)\)/.exec(e);
    if (t) {
        let n = t[1].indexOf(",");
        if (n === -1) return [
            t[1]
        ];
        let r = t[1].slice(0, n).trim(), l = t[1].slice(n + 1).trim();
        return l ? [
            r,
            ...q(l)
        ] : [
            r
        ];
    }
    return [];
}
function J(e, t) {
    let n = document.createElement("div");
    t.appendChild(n), n.style.setProperty("margin-top", "0px", "important"), n.style.setProperty("margin-top", e, "important");
    let r = parseFloat(window.getComputedStyle(n).marginTop) || 0;
    return t.removeChild(n), r;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/form-fields.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mt: function() { return /* binding */ j; }
/* harmony export */ });
/* unused harmony exports FormFieldsProvider, HoistFormFields */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js");
/* harmony import */ var _hooks_use_disposables_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-disposables.js");
/* harmony import */ var _utils_form_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/form.js");
/* harmony import */ var _utils_render_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/render.js");
/* harmony import */ var _hidden_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/hidden.js");






let f = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
function W(t) {
    let [e, r] = u(null);
    return /*#__PURE__*/ o.createElement(f.Provider, {
        value: {
            target: e
        }
    }, t.children, /*#__PURE__*/ o.createElement(l, {
        features: d.Hidden,
        ref: r
    }));
}
function c(param) {
    let { children: t } = param;
    let e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(f);
    if (!e) return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, t);
    let { target: r } = e;
    return r ? /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, t), r) : null;
}
function j(param) {
    let { data: t, form: e, disabled: r, onReset: n, overrides: F } = param;
    let [i, a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), p = (0,_hooks_use_disposables_js__WEBPACK_IMPORTED_MODULE_2__/* .useDisposables */ .G)();
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        if (n && i) return p.addEventListener(i, "reset", n);
    }, [
        i,
        e,
        n
    ]), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(c, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(C, {
        setForm: a,
        formId: e
    }), (0,_utils_form_js__WEBPACK_IMPORTED_MODULE_3__/* .objectToFormEntries */ .t)(t).map((param)=>{
        let [s, v] = param;
        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_hidden_js__WEBPACK_IMPORTED_MODULE_4__/* .Hidden */ ._, {
            features: _hidden_js__WEBPACK_IMPORTED_MODULE_4__/* .HiddenFeatures */ .x.Hidden,
            ...(0,_utils_render_js__WEBPACK_IMPORTED_MODULE_5__/* .compact */ .oA)({
                key: s,
                as: "input",
                type: "hidden",
                hidden: !0,
                readOnly: !0,
                form: e,
                disabled: r,
                name: s,
                value: v,
                ...F
            })
        });
    }));
}
function C(param) {
    let { setForm: t, formId: e } = param;
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        if (e) {
            let r = document.getElementById(e);
            r && t(r);
        }
    }, [
        t,
        e
    ]), e ? null : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_hidden_js__WEBPACK_IMPORTED_MODULE_4__/* .Hidden */ ._, {
        features: _hidden_js__WEBPACK_IMPORTED_MODULE_4__/* .HiddenFeatures */ .x.Hidden,
        as: "input",
        type: "hidden",
        hidden: !0,
        readOnly: !0,
        ref: (r)=>{
            if (!r) return;
            let n = r.closest("form");
            n && t(n);
        }
    });
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/frozen.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: function() { return /* binding */ f; },
/* harmony export */   _: function() { return /* binding */ l; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");

function f(param) {
    let { children: o, freeze: e } = param;
    let n = l(e, o);
    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, n);
}
function l(o, e) {
    let [n, t] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e);
    return !o && n !== e && t(e), o ? n : e;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/hidden.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: function() { return /* binding */ f; },
/* harmony export */   x: function() { return /* binding */ s; }
/* harmony export */ });
/* harmony import */ var _utils_render_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/render.js");

let a = "span";
var s = ((e)=>(e[e.None = 1] = "None", e[e.Focusable = 2] = "Focusable", e[e.Hidden = 4] = "Hidden", e))(s || {});
function l(t, r) {
    var n;
    let { features: d = 1, ...e } = t, o = {
        ref: r,
        "aria-hidden": (d & 2) === 2 ? !0 : (n = e["aria-hidden"]) != null ? n : void 0,
        hidden: (d & 4) === 4 ? !0 : void 0,
        style: {
            position: "fixed",
            top: 1,
            left: 1,
            width: 1,
            height: 0,
            padding: 0,
            margin: -1,
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            borderWidth: "0",
            ...(d & 4) === 4 && (d & 2) !== 2 && {
                display: "none"
            }
        }
    };
    return (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_0__/* .useRender */ .L6)()({
        ourProps: o,
        theirProps: e,
        slot: {},
        defaultTag: a,
        name: "Hidden"
    });
}
let f = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_0__/* .forwardRefWithAs */ .yV)(l);



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/id.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: function() { return /* binding */ u; }
/* harmony export */ });
/* unused harmony export IdProvider */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");

let e = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);
function u() {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(e);
}
function f(param) {
    let { id: t, children: r } = param;
    return /*#__PURE__*/ n.createElement(e.Provider, {
        value: t
    }, r);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/open-closed.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZM: function() { return /* binding */ i; },
/* harmony export */   oJ: function() { return /* binding */ u; },
/* harmony export */   up: function() { return /* binding */ c; }
/* harmony export */ });
/* unused harmony export ResetOpenClosedProvider */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");

let n = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
n.displayName = "OpenClosedContext";
var i = ((e)=>(e[e.Open = 1] = "Open", e[e.Closed = 2] = "Closed", e[e.Closing = 4] = "Closing", e[e.Opening = 8] = "Opening", e))(i || {});
function u() {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(n);
}
function c(param) {
    let { value: o, children: t } = param;
    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(n.Provider, {
        value: o
    }, t);
}
function s(param) {
    let { children: o } = param;
    return /*#__PURE__*/ r.createElement(n.Provider, {
        value: null
    }, o);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/machine.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: function() { return /* binding */ T; },
/* harmony export */   dC: function() { return /* binding */ k; },
/* harmony export */   wU: function() { return /* binding */ j; }
/* harmony export */ });
/* harmony import */ var _utils_default_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/default-map.js");
/* harmony import */ var _utils_disposables_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js");
/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/env.js");
var h = Object.defineProperty;
var v = (t, e, r)=>e in t ? h(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r;
var S = (t, e, r)=>(v(t, typeof e != "symbol" ? e + "" : e, r), r), b = (t, e, r)=>{
    if (!e.has(t)) throw TypeError("Cannot " + r);
};
var i = (t, e, r)=>(b(t, e, "read from private field"), r ? r.call(t) : e.get(t)), c = (t, e, r)=>{
    if (e.has(t)) throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, u = (t, e, r, s)=>(b(t, e, "write to private field"), s ? s.call(t, r) : e.set(t, r), r);
var n, a, o;



class T {
    dispose() {
        this.disposables.dispose();
    }
    get state() {
        return i(this, n);
    }
    subscribe(e, r) {
        if (_utils_env_js__WEBPACK_IMPORTED_MODULE_0__/* .env */ .O.isServer) return ()=>{};
        let s = {
            selector: e,
            callback: r,
            current: e(i(this, n))
        };
        return i(this, o).add(s), this.disposables.add(()=>{
            i(this, o).delete(s);
        });
    }
    on(e, r) {
        return _utils_env_js__WEBPACK_IMPORTED_MODULE_0__/* .env */ .O.isServer ? ()=>{} : (i(this, a).get(e).add(r), this.disposables.add(()=>{
            i(this, a).get(e).delete(r);
        }));
    }
    send(e) {
        let r = this.reduce(i(this, n), e);
        if (r !== i(this, n)) {
            u(this, n, r);
            for (let s of i(this, o)){
                let l = s.selector(i(this, n));
                j(s.current, l) || (s.current = l, s.callback(l));
            }
            for (let s of i(this, a).get(e.type))s(i(this, n), e);
        }
    }
    constructor(e){
        c(this, n, {});
        c(this, a, new _utils_default_map_js__WEBPACK_IMPORTED_MODULE_1__/* .DefaultMap */ .G(()=>new Set));
        c(this, o, new Set);
        S(this, "disposables", (0,_utils_disposables_js__WEBPACK_IMPORTED_MODULE_2__/* .disposables */ .k)());
        u(this, n, e), _utils_env_js__WEBPACK_IMPORTED_MODULE_0__/* .env */ .O.isServer && this.disposables.microTask(()=>{
            this.dispose();
        });
    }
}
n = new WeakMap, a = new WeakMap, o = new WeakMap;
function j(t, e) {
    return Object.is(t, e) ? !0 : typeof t != "object" || t === null || typeof e != "object" || e === null ? !1 : Array.isArray(t) && Array.isArray(e) ? t.length !== e.length ? !1 : f(t[Symbol.iterator](), e[Symbol.iterator]()) : t instanceof Map && e instanceof Map || t instanceof Set && e instanceof Set ? t.size !== e.size ? !1 : f(t.entries(), e.entries()) : p(t) && p(e) ? f(Object.entries(t)[Symbol.iterator](), Object.entries(e)[Symbol.iterator]()) : !1;
}
function f(t, e) {
    do {
        let r = t.next(), s = e.next();
        if (r.done && s.done) return !0;
        if (r.done || s.done || !Object.is(r.value, s.value)) return !1;
    }while (!0);
}
function p(t) {
    if (Object.prototype.toString.call(t) !== "[object Object]") return !1;
    let e = Object.getPrototypeOf(t);
    return e === null || Object.getPrototypeOf(e) === null;
}
function k(t) {
    let [e, r] = t(), s = (0,_utils_disposables_js__WEBPACK_IMPORTED_MODULE_2__/* .disposables */ .k)();
    return function() {
        for(var _len = arguments.length, l = new Array(_len), _key = 0; _key < _len; _key++){
            l[_key] = arguments[_key];
        }
        e(...l), s.dispose(), s.microTask(r);
    };
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/machines/stack-machine.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: function() { return /* binding */ k; },
/* harmony export */   n: function() { return /* binding */ x; }
/* harmony export */ });
/* harmony import */ var _machine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/machine.js");
/* harmony import */ var _utils_default_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/default-map.js");
/* harmony import */ var _utils_match_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/match.js");
var a = Object.defineProperty;
var r = (e, c, t)=>c in e ? a(e, c, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : e[c] = t;
var p = (e, c, t)=>(r(e, typeof c != "symbol" ? c + "" : c, t), t);



var k = ((t)=>(t[t.Push = 0] = "Push", t[t.Pop = 1] = "Pop", t))(k || {});
let y = {
    [0] (e, c) {
        let t = c.id, s = e.stack, i = e.stack.indexOf(t);
        if (i !== -1) {
            let n = e.stack.slice();
            return n.splice(i, 1), n.push(t), s = n, {
                ...e,
                stack: s
            };
        }
        return {
            ...e,
            stack: [
                ...e.stack,
                t
            ]
        };
    },
    [1] (e, c) {
        let t = c.id, s = e.stack.indexOf(t);
        if (s === -1) return e;
        let i = e.stack.slice();
        return i.splice(s, 1), {
            ...e,
            stack: i
        };
    }
};
class o extends _machine_js__WEBPACK_IMPORTED_MODULE_0__/* .Machine */ .J {
    static new() {
        return new o({
            stack: []
        });
    }
    reduce(t, s) {
        return (0,_utils_match_js__WEBPACK_IMPORTED_MODULE_1__/* .match */ .E)(s.type, y, t, s);
    }
    constructor(){
        super(...arguments);
        p(this, "actions", {
            push: (t)=>this.send({
                    type: 0,
                    id: t
                }),
            pop: (t)=>this.send({
                    type: 1,
                    id: t
                })
        });
        p(this, "selectors", {
            isTop: (t, s)=>t.stack[t.stack.length - 1] === s,
            inStack: (t, s)=>t.stack.includes(s)
        });
    }
}
const x = new _utils_default_map_js__WEBPACK_IMPORTED_MODULE_2__/* .DefaultMap */ .G(()=>o.new());



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/react-glue.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: function() { return /* binding */ S; }
/* harmony export */ });
/* harmony import */ var use_sync_external_store_with_selector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/use-sync-external-store/with-selector.js");
/* harmony import */ var _hooks_use_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");
/* harmony import */ var _machine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/machine.js");



function S(e, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _machine_js__WEBPACK_IMPORTED_MODULE_1__/* .shallowEqual */ .wU;
    return (0,use_sync_external_store_with_selector__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStoreWithSelector)((0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_2__/* .useEvent */ .z)((i)=>e.subscribe(s, i)), (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_2__/* .useEvent */ .z)(()=>e.state), (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_2__/* .useEvent */ .z)(()=>e.state), (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_2__/* .useEvent */ .z)(n), r);
}
function s(e) {
    return e;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/bugs.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: function() { return /* binding */ s; }
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js");

function s(l) {
    let e = l.parentElement, t = null;
    for(; e && !_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .isHTMLFieldSetElement */ .zO(e);)_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .isHTMLLegendElement */ .CD(e) && (t = e), e = e.parentElement;
    let i = (e == null ? void 0 : e.getAttribute("disabled")) === "";
    return i && r(t) ? !1 : i;
}
function r(l) {
    if (!l) return !1;
    let e = l.previousElementSibling;
    for(; e !== null;){
        if (_dom_js__WEBPACK_IMPORTED_MODULE_0__/* .isHTMLLegendElement */ .CD(e)) return !1;
        e = e.previousElementSibling;
    }
    return !0;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: function() { return /* binding */ c; },
/* harmony export */   d: function() { return /* binding */ f; }
/* harmony export */ });
function u(l) {
    throw new Error("Unexpected object: " + l);
}
var c = ((i)=>(i[i.First = 0] = "First", i[i.Previous = 1] = "Previous", i[i.Next = 2] = "Next", i[i.Last = 3] = "Last", i[i.Specific = 4] = "Specific", i[i.Nothing = 5] = "Nothing", i))(c || {});
function f(l, n) {
    let t = n.resolveItems();
    if (t.length <= 0) return null;
    let r = n.resolveActiveIndex(), s = r != null ? r : -1;
    switch(l.focus){
        case 0:
            {
                for(let e = 0; e < t.length; ++e)if (!n.resolveDisabled(t[e], e, t)) return e;
                return r;
            }
        case 1:
            {
                s === -1 && (s = t.length);
                for(let e = s - 1; e >= 0; --e)if (!n.resolveDisabled(t[e], e, t)) return e;
                return r;
            }
        case 2:
            {
                for(let e = s + 1; e < t.length; ++e)if (!n.resolveDisabled(t[e], e, t)) return e;
                return r;
            }
        case 3:
            {
                for(let e = t.length - 1; e >= 0; --e)if (!n.resolveDisabled(t[e], e, t)) return e;
                return r;
            }
        case 4:
            {
                for(let e = 0; e < t.length; ++e)if (n.resolveId(t[e], e, t) === l.id) return e;
                return r;
            }
        case 5:
            return null;
        default:
            u(l);
    }
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/default-map.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: function() { return /* binding */ a; }
/* harmony export */ });
class a extends Map {
    get(t) {
        let e = super.get(t);
        return e === void 0 && (e = this.factory(t), this.set(t, e)), e;
    }
    constructor(t){
        super();
        this.factory = t;
    }
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   k: function() { return /* binding */ o; }
/* harmony export */ });
/* harmony import */ var _micro_task_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/micro-task.js");

function o() {
    let s = [], r = {
        addEventListener (e, t, n, i) {
            return e.addEventListener(t, n, i), r.add(()=>e.removeEventListener(t, n, i));
        },
        requestAnimationFrame () {
            for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){
                e[_key] = arguments[_key];
            }
            let t = requestAnimationFrame(...e);
            return r.add(()=>cancelAnimationFrame(t));
        },
        nextFrame () {
            for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){
                e[_key] = arguments[_key];
            }
            return r.requestAnimationFrame(()=>r.requestAnimationFrame(...e));
        },
        setTimeout () {
            for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){
                e[_key] = arguments[_key];
            }
            let t = setTimeout(...e);
            return r.add(()=>clearTimeout(t));
        },
        microTask () {
            for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){
                e[_key] = arguments[_key];
            }
            let t = {
                current: !0
            };
            return (0,_micro_task_js__WEBPACK_IMPORTED_MODULE_0__/* .microTask */ .Y)(()=>{
                t.current && e[0]();
            }), r.add(()=>{
                t.current = !1;
            });
        },
        style (e, t, n) {
            let i = e.style.getPropertyValue(t);
            return Object.assign(e.style, {
                [t]: n
            }), this.add(()=>{
                Object.assign(e.style, {
                    [t]: i
                });
            });
        },
        group (e) {
            let t = o();
            return e(t), this.add(()=>t.dispose());
        },
        add (e) {
            return s.includes(e) || s.push(e), ()=>{
                let t = s.indexOf(e);
                if (t >= 0) for (let n of s.splice(t, 1))n();
            };
        },
        dispose () {
            for (let e of s.splice(0))e();
        }
    };
    return r;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CD: function() { return /* binding */ E; },
/* harmony export */   LL: function() { return /* binding */ l; },
/* harmony export */   Re: function() { return /* binding */ n; },
/* harmony export */   UG: function() { return /* binding */ o; },
/* harmony export */   dz: function() { return /* binding */ m; },
/* harmony export */   jF: function() { return /* binding */ L; },
/* harmony export */   jQ: function() { return /* binding */ u; },
/* harmony export */   nR: function() { return /* binding */ r; },
/* harmony export */   sP: function() { return /* binding */ i; },
/* harmony export */   zO: function() { return /* binding */ a; }
/* harmony export */ });
/* unused harmony exports isElement, isHTMLTextAreaElement */
function o(e) {
    return typeof e != "object" || e === null ? !1 : "nodeType" in e;
}
function t(e) {
    return o(e) && "tagName" in e;
}
function n(e) {
    return t(e) && "accessKey" in e;
}
function i(e) {
    return t(e) && "tabIndex" in e;
}
function r(e) {
    return t(e) && "style" in e;
}
function u(e) {
    return n(e) && e.nodeName === "IFRAME";
}
function l(e) {
    return n(e) && e.nodeName === "INPUT";
}
function s(e) {
    return n(e) && e.nodeName === "TEXTAREA";
}
function m(e) {
    return n(e) && e.nodeName === "LABEL";
}
function a(e) {
    return n(e) && e.nodeName === "FIELDSET";
}
function E(e) {
    return n(e) && e.nodeName === "LEGEND";
}
function L(e) {
    return t(e) ? e.matches('a[href],audio[controls],button,details,embed,iframe,img[usemap],input:not([type="hidden"]),label,select,textarea,video[controls]') : !1;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/element-movement.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   On: function() { return /* binding */ c; },
/* harmony export */   hS: function() { return /* binding */ p; },
/* harmony export */   kn: function() { return /* binding */ a; }
/* harmony export */ });
/* harmony import */ var _disposables_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js");

const c = {
    Idle: {
        kind: "Idle"
    },
    Tracked: (e)=>({
            kind: "Tracked",
            position: e
        }),
    Moved: {
        kind: "Moved"
    }
};
function a(e) {
    let t = e.getBoundingClientRect();
    return "".concat(t.x, ",").concat(t.y);
}
function p(e, t, i) {
    let n = (0,_disposables_js__WEBPACK_IMPORTED_MODULE_0__/* .disposables */ .k)();
    if (t.kind === "Tracked") {
        let o = function() {
            d !== a(e) && (n.dispose(), i());
        };
        var f = o;
        let { position: d } = t, s = new ResizeObserver(o);
        s.observe(e), n.add(()=>s.disconnect()), n.addEventListener(window, "scroll", o, {
            passive: !0
        }), n.addEventListener(window, "resize", o);
    }
    return ()=>n.dispose();
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/env.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   O: function() { return /* binding */ s; }
/* harmony export */ });
var i = Object.defineProperty;
var d = (t, e, n)=>e in t ? i(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n;
var r = (t, e, n)=>(d(t, typeof e != "symbol" ? e + "" : e, n), n);
class o {
    set(e) {
        this.current !== e && (this.handoffState = "pending", this.currentId = 0, this.current = e);
    }
    reset() {
        this.set(this.detect());
    }
    nextId() {
        return ++this.currentId;
    }
    get isServer() {
        return this.current === "server";
    }
    get isClient() {
        return this.current === "client";
    }
    detect() {
        return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
    }
    handoff() {
        this.handoffState === "pending" && (this.handoffState = "complete");
    }
    get isHandoffComplete() {
        return this.handoffState === "complete";
    }
    constructor(){
        r(this, "current", this.detect());
        r(this, "handoffState", "pending");
        r(this, "currentId", 0);
    }
}
let s = new o;



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/focus-management.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EO: function() { return /* binding */ j; },
/* harmony export */   TO: function() { return /* binding */ T; },
/* harmony export */   fE: function() { return /* binding */ y; },
/* harmony export */   jA: function() { return /* binding */ g; },
/* harmony export */   sP: function() { return /* binding */ A; },
/* harmony export */   tJ: function() { return /* binding */ h; },
/* harmony export */   wI: function() { return /* binding */ V; },
/* harmony export */   y: function() { return /* binding */ f; },
/* harmony export */   z2: function() { return /* binding */ P; }
/* harmony export */ });
/* unused harmony exports focusElement, getAutoFocusableElements, getFocusableElements */
/* harmony import */ var _disposables_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js");
/* harmony import */ var _match_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/match.js");
/* harmony import */ var _owner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/owner.js");




let f = [
    "[contentEditable=true]",
    "[tabindex]",
    "a[href]",
    "area[href]",
    "button:not([disabled])",
    "iframe",
    "input:not([disabled])",
    "select:not([disabled])",
    "details>summary",
    "textarea:not([disabled])"
].map((e)=>"".concat(e, ":not([tabindex='-1'])")).join(","), F = [
    "[data-autofocus]"
].map((e)=>"".concat(e, ":not([tabindex='-1'])")).join(",");
var T = ((n)=>(n[n.First = 1] = "First", n[n.Previous = 2] = "Previous", n[n.Next = 4] = "Next", n[n.Last = 8] = "Last", n[n.WrapAround = 16] = "WrapAround", n[n.NoScroll = 32] = "NoScroll", n[n.AutoFocus = 64] = "AutoFocus", n))(T || {}), y = ((o)=>(o[o.Error = 0] = "Error", o[o.Overflow = 1] = "Overflow", o[o.Success = 2] = "Success", o[o.Underflow = 3] = "Underflow", o))(y || {}), S = ((t)=>(t[t.Previous = -1] = "Previous", t[t.Next = 1] = "Next", t))(S || {});
function b() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document.body;
    return e == null ? [] : Array.from(e.querySelectorAll(f)).sort((r, t)=>Math.sign((r.tabIndex || Number.MAX_SAFE_INTEGER) - (t.tabIndex || Number.MAX_SAFE_INTEGER)));
}
function O() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document.body;
    return e == null ? [] : Array.from(e.querySelectorAll(F)).sort((r, t)=>Math.sign((r.tabIndex || Number.MAX_SAFE_INTEGER) - (t.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var h = ((t)=>(t[t.Strict = 0] = "Strict", t[t.Loose = 1] = "Loose", t))(h || {});
function A(e) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var t;
    return e === ((t = (0,_owner_js__WEBPACK_IMPORTED_MODULE_0__/* .getOwnerDocument */ .r)(e)) == null ? void 0 : t.body) ? !1 : (0,_match_js__WEBPACK_IMPORTED_MODULE_1__/* .match */ .E)(r, {
        [0] () {
            return e.matches(f);
        },
        [1] () {
            let l = e;
            for(; l !== null;){
                if (l.matches(f)) return !0;
                l = l.parentElement;
            }
            return !1;
        }
    });
}
function V(e) {
    let r = (0,_owner_js__WEBPACK_IMPORTED_MODULE_0__/* .getOwnerDocument */ .r)(e);
    (0,_disposables_js__WEBPACK_IMPORTED_MODULE_2__/* .disposables */ .k)().nextFrame(()=>{
        r && _dom_js__WEBPACK_IMPORTED_MODULE_3__/* .isHTMLorSVGElement */ .sP(r.activeElement) && !A(r.activeElement, 0) && I(e);
    });
}
var H = ((t)=>(t[t.Keyboard = 0] = "Keyboard", t[t.Mouse = 1] = "Mouse", t))(H || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e)=>{
    e.metaKey || e.altKey || e.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (e)=>{
    e.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function I(e) {
    e == null || e.focus({
        preventScroll: !0
    });
}
let w = [
    "textarea",
    "input"
].join(",");
function _(e) {
    var r, t;
    return (t = (r = e == null ? void 0 : e.matches) == null ? void 0 : r.call(e, w)) != null ? t : !1;
}
function P(e) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (t)=>t;
    return e.slice().sort((t, l)=>{
        let o = r(t), c = r(l);
        if (o === null || c === null) return 0;
        let u = o.compareDocumentPosition(c);
        return u & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : u & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
    });
}
function j(e, r) {
    return g(b(), r, {
        relativeTo: e
    });
}
function g(e, r) {
    let { sorted: t = !0, relativeTo: l = null, skipElements: o = [] } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let c = Array.isArray(e) ? e.length > 0 ? e[0].ownerDocument : document : e.ownerDocument, u = Array.isArray(e) ? t ? P(e) : e : r & 64 ? O(e) : b(e);
    o.length > 0 && u.length > 1 && (u = u.filter((s)=>!o.some((a)=>a != null && "current" in a ? (a == null ? void 0 : a.current) === s : a === s))), l = l != null ? l : c.activeElement;
    let n = (()=>{
        if (r & 5) return 1;
        if (r & 10) return -1;
        throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
    })(), x = (()=>{
        if (r & 1) return 0;
        if (r & 2) return Math.max(0, u.indexOf(l)) - 1;
        if (r & 4) return Math.max(0, u.indexOf(l)) + 1;
        if (r & 8) return u.length - 1;
        throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
    })(), M = r & 32 ? {
        preventScroll: !0
    } : {}, m = 0, d = u.length, i;
    do {
        if (m >= d || m + d <= 0) return 0;
        let s = x + m;
        if (r & 16) s = (s + d) % d;
        else {
            if (s < 0) return 3;
            if (s >= d) return 1;
        }
        i = u[s], i == null || i.focus(M), m += n;
    }while (i !== c.activeElement);
    return r & 6 && _(i) && i.select(), 2;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/form.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: function() { return /* binding */ p; },
/* harmony export */   t: function() { return /* binding */ e; }
/* harmony export */ });
function e() {
    let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    for (let [r, n] of Object.entries(i))o(t, f(s, r), n);
    return t;
}
function f(i, s) {
    return i ? i + "[" + s + "]" : s;
}
function o(i, s, t) {
    if (Array.isArray(t)) for (let [r, n] of t.entries())o(i, f(s, r.toString()), n);
    else t instanceof Date ? i.push([
        s,
        t.toISOString()
    ]) : typeof t == "boolean" ? i.push([
        s,
        t ? "1" : "0"
    ]) : typeof t == "string" ? i.push([
        s,
        t
    ]) : typeof t == "number" ? i.push([
        s,
        "".concat(t)
    ]) : t == null ? i.push([
        s,
        ""
    ]) : e(t, s, i);
}
function p(i) {
    var t, r;
    let s = (t = i == null ? void 0 : i.form) != null ? t : i.closest("form");
    if (s) {
        for (let n of s.elements)if (n !== i && (n.tagName === "INPUT" && n.type === "submit" || n.tagName === "BUTTON" && n.type === "submit" || n.nodeName === "INPUT" && n.type === "image")) {
            n.click();
            return;
        }
        (r = s.requestSubmit) == null || r.call(s);
    }
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/match.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: function() { return /* binding */ u; }
/* harmony export */ });
function u(r, n) {
    for(var _len = arguments.length, a = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
        a[_key - 2] = arguments[_key];
    }
    if (r in n) {
        let e = n[r];
        return typeof e == "function" ? e(...a) : e;
    }
    let t = new Error('Tried to handle "'.concat(r, '" but there is no handler defined. Only defined handlers are: ').concat(Object.keys(n).map((e)=>'"'.concat(e, '"')).join(", "), "."));
    throw Error.captureStackTrace && Error.captureStackTrace(t, u), t;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/micro-task.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: function() { return /* binding */ t; }
/* harmony export */ });
function t(e) {
    typeof queueMicrotask == "function" ? queueMicrotask(e) : Promise.resolve().then(e).catch((o)=>setTimeout(()=>{
            throw o;
        }));
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/owner.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: function() { return /* binding */ o; }
/* harmony export */ });
/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/env.js");

function o(n) {
    var e, r;
    return _env_js__WEBPACK_IMPORTED_MODULE_0__/* .env */ .O.isServer ? null : n ? "ownerDocument" in n ? n.ownerDocument : "current" in n ? (r = (e = n.current) == null ? void 0 : e.ownerDocument) != null ? r : document : null : document;
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/platform.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gn: function() { return /* binding */ t; },
/* harmony export */   tq: function() { return /* binding */ n; }
/* harmony export */ });
/* unused harmony export isAndroid */
function t() {
    return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i() {
    return /Android/gi.test(window.navigator.userAgent);
}
function n() {
    return t() || i();
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/render.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  VN: function() { return /* binding */ A; },
  oA: function() { return /* binding */ m; },
  yV: function() { return /* binding */ Y; },
  dG: function() { return /* binding */ V; },
  L6: function() { return /* binding */ K; }
});

// UNUSED EXPORTS: RenderStrategy, isFragment, isFragmentInstance

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/utils/class-names.js
function class_names_t() {
    for(var _len = arguments.length, r = new Array(_len), _key = 0; _key < _len; _key++){
        r[_key] = arguments[_key];
    }
    return Array.from(new Set(r.flatMap((n)=>typeof n == "string" ? n.split(" ") : []))).filter(Boolean).join(" ");
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/match.js
var match = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/match.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/utils/render.js



var A = ((a)=>(a[a.None = 0] = "None", a[a.RenderStrategy = 1] = "RenderStrategy", a[a.Static = 2] = "Static", a))(A || {}), C = ((e)=>(e[e.Unmount = 0] = "Unmount", e[e.Hidden = 1] = "Hidden", e))(C || {});
function K() {
    let n = $();
    return (0,react.useCallback)((r)=>U({
            mergeRefs: n,
            ...r
        }), [
        n
    ]);
}
function U(param) {
    let { ourProps: n, theirProps: r, slot: e, defaultTag: a, features: s, visible: t = !0, name: l, mergeRefs: i } = param;
    i = i != null ? i : I;
    let o = P(r, n);
    if (t) return F(o, e, a, l, i);
    let y = s != null ? s : 0;
    if (y & 2) {
        let { static: f = !1, ...u } = o;
        if (f) return F(u, e, a, l, i);
    }
    if (y & 1) {
        let { unmount: f = !0, ...u } = o;
        return (0,match/* match */.E)(f ? 0 : 1, {
            [0] () {
                return null;
            },
            [1] () {
                return F({
                    ...u,
                    hidden: !0,
                    style: {
                        display: "none"
                    }
                }, e, a, l, i);
            }
        });
    }
    return F(o, e, a, l, i);
}
function F(n) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, e = arguments.length > 2 ? arguments[2] : void 0, a = arguments.length > 3 ? arguments[3] : void 0, s = arguments.length > 4 ? arguments[4] : void 0;
    let { as: t = e, children: l, refName: i = "ref", ...o } = h(n, [
        "unmount",
        "static"
    ]), y = n.ref !== void 0 ? {
        [i]: n.ref
    } : {}, f = typeof l == "function" ? l(r) : l;
    "className" in o && o.className && typeof o.className == "function" && (o.className = o.className(r)), o["aria-labelledby"] && o["aria-labelledby"] === o.id && (o["aria-labelledby"] = void 0);
    let u = {};
    if (r) {
        let d = !1, p = [];
        for (let [c, T] of Object.entries(r))typeof T == "boolean" && (d = !0), T === !0 && p.push(c.replace(/([A-Z])/g, (g)=>"-".concat(g.toLowerCase())));
        if (d) {
            u["data-headlessui-state"] = p.join(" ");
            for (let c of p)u["data-".concat(c)] = "";
        }
    }
    if (b(t) && (Object.keys(m(o)).length > 0 || Object.keys(m(u)).length > 0)) if (!/*#__PURE__*/ (0,react.isValidElement)(f) || Array.isArray(f) && f.length > 1 || D(f)) {
        if (Object.keys(m(o)).length > 0) throw new Error([
            'Passing props on "Fragment"!',
            "",
            "The current component <".concat(a, ' /> is rendering a "Fragment".'),
            "However we need to passthrough the following props:",
            Object.keys(m(o)).concat(Object.keys(m(u))).map((d)=>"  - ".concat(d)).join("\n"),
            "",
            "You can apply a few solutions:",
            [
                'Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".',
                "Render a single element as the child so that we can forward the props onto that element."
            ].map((d)=>"  - ".concat(d)).join("\n")
        ].join("\n"));
    } else {
        let d = f.props, p = d == null ? void 0 : d.className, c = typeof p == "function" ? function() {
            for(var _len = arguments.length, R = new Array(_len), _key = 0; _key < _len; _key++){
                R[_key] = arguments[_key];
            }
            return class_names_t(p(...R), o.className);
        } : class_names_t(p, o.className), T = c ? {
            className: c
        } : {}, g = P(f.props, m(h(o, [
            "ref"
        ])));
        for(let R in u)R in g && delete u[R];
        return /*#__PURE__*/ (0,react.cloneElement)(f, Object.assign({}, g, u, y, {
            ref: s(H(f), y.ref)
        }, T));
    }
    return /*#__PURE__*/ (0,react.createElement)(t, Object.assign({}, h(o, [
        "ref"
    ]), !b(t) && y, !b(t) && u), f);
}
function $() {
    let n = (0,react.useRef)([]), r = (0,react.useCallback)((e)=>{
        for (let a of n.current)a != null && (typeof a == "function" ? a(e) : a.current = e);
    }, []);
    return function() {
        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){
            e[_key] = arguments[_key];
        }
        if (!e.every((a)=>a == null)) return n.current = e, r;
    };
}
function I() {
    for(var _len = arguments.length, n = new Array(_len), _key = 0; _key < _len; _key++){
        n[_key] = arguments[_key];
    }
    return n.every((r)=>r == null) ? void 0 : (r)=>{
        for (let e of n)e != null && (typeof e == "function" ? e(r) : e.current = r);
    };
}
function P() {
    for(var _len = arguments.length, n = new Array(_len), _key = 0; _key < _len; _key++){
        n[_key] = arguments[_key];
    }
    var a;
    if (n.length === 0) return {};
    if (n.length === 1) return n[0];
    let r = {}, e = {};
    for (let s of n)for(let t in s)t.startsWith("on") && typeof s[t] == "function" ? ((a = e[t]) != null || (e[t] = []), e[t].push(s[t])) : r[t] = s[t];
    if (r.disabled || r["aria-disabled"]) for(let s in e)/^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(s) && (e[s] = [
        (t)=>{
            var l;
            return (l = t == null ? void 0 : t.preventDefault) == null ? void 0 : l.call(t);
        }
    ]);
    for(let s in e)Object.assign(r, {
        [s] (t) {
            for(var _len = arguments.length, l = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                l[_key - 1] = arguments[_key];
            }
            let i = e[s];
            for (let o of i){
                if ((t instanceof Event || (t == null ? void 0 : t.nativeEvent) instanceof Event) && t.defaultPrevented) return;
                o(t, ...l);
            }
        }
    });
    return r;
}
function V() {
    for(var _len = arguments.length, n = new Array(_len), _key = 0; _key < _len; _key++){
        n[_key] = arguments[_key];
    }
    var a;
    if (n.length === 0) return {};
    if (n.length === 1) return n[0];
    let r = {}, e = {};
    for (let s of n)for(let t in s)t.startsWith("on") && typeof s[t] == "function" ? ((a = e[t]) != null || (e[t] = []), e[t].push(s[t])) : r[t] = s[t];
    for(let s in e)Object.assign(r, {
        [s] () {
            for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
                t[_key] = arguments[_key];
            }
            let l = e[s];
            for (let i of l)i == null || i(...t);
        }
    });
    return r;
}
function Y(n) {
    var r;
    return Object.assign(/*#__PURE__*/ (0,react.forwardRef)(n), {
        displayName: (r = n.displayName) != null ? r : n.name
    });
}
function m(n) {
    let r = Object.assign({}, n);
    for(let e in r)r[e] === void 0 && delete r[e];
    return r;
}
function h(n) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let e = Object.assign({}, n);
    for (let a of r)a in e && delete e[a];
    return e;
}
function H(n) {
    return react.version.split(".")[0] >= "19" ? n.props.ref : n.ref;
}
function b(n) {
    return n === react.Fragment || n === Symbol.for("react.fragment");
}
function D(n) {
    return b(n.type);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@react-aria/focus/dist/useFocusRing.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  F: function() { return /* binding */ $f7dceffc5ad7768b$export$4e328f61c538687f; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
;// CONCATENATED MODULE: ../../node_modules/@react-aria/utils/dist/useLayoutEffect.mjs


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== 'undefined' ? (0, react).useLayoutEffect : ()=>{};



//# sourceMappingURL=useLayoutEffect.module.js.map

;// CONCATENATED MODULE: ../../node_modules/@react-aria/utils/dist/useEffectEvent.mjs



/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

var $8ae05eaa5c114e9c$var$_React_useInsertionEffect;
// Use the earliest effect type possible. useInsertionEffect runs during the mutation phase,
// before all layout effects, but is available only in React 18 and later.
const $8ae05eaa5c114e9c$var$useEarlyEffect = ($8ae05eaa5c114e9c$var$_React_useInsertionEffect = (0, react)['useInsertionEffect']) !== null && $8ae05eaa5c114e9c$var$_React_useInsertionEffect !== void 0 ? $8ae05eaa5c114e9c$var$_React_useInsertionEffect : (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c);
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {
    const ref = (0, react.useRef)(null);
    $8ae05eaa5c114e9c$var$useEarlyEffect(()=>{
        ref.current = fn;
    }, [
        fn
    ]);
    // @ts-ignore
    return (0, react.useCallback)((...args)=>{
        const f = ref.current;
        return f === null || f === void 0 ? void 0 : f(...args);
    }, []);
}



//# sourceMappingURL=useEffectEvent.module.js.map

;// CONCATENATED MODULE: ../../node_modules/@react-aria/interactions/dist/utils.mjs



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent) {
    let event = nativeEvent;
    event.nativeEvent = nativeEvent;
    event.isDefaultPrevented = ()=>event.defaultPrevented;
    // cancelBubble is technically deprecated in the spec, but still supported in all browsers.
    event.isPropagationStopped = ()=>event.cancelBubble;
    event.persist = ()=>{};
    return event;
}
function $8a9cb279dc87e130$export$c2b7abe5d61ec696(event, target) {
    Object.defineProperty(event, 'target', {
        value: target
    });
    Object.defineProperty(event, 'currentTarget', {
        value: target
    });
}
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
    let stateRef = (0, react.useRef)({
        isFocused: false,
        observer: null
    });
    // Clean up MutationObserver on unmount. See below.
    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{
        const state = stateRef.current;
        return ()=>{
            if (state.observer) {
                state.observer.disconnect();
                state.observer = null;
            }
        };
    }, []);
    let dispatchBlur = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e)=>{
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    });
    // This function is called during a React onFocus event.
    return (0, react.useCallback)((e)=>{
        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142
        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a
        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.
        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.
        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {
            stateRef.current.isFocused = true;
            let target = e.target;
            let onBlurHandler = (e)=>{
                stateRef.current.isFocused = false;
                if (target.disabled) {
                    // For backward compatibility, dispatch a (fake) React synthetic event.
                    let event = $8a9cb279dc87e130$export$525bc4921d56d4a(e);
                    dispatchBlur(event);
                }
                // We no longer need the MutationObserver once the target is blurred.
                if (stateRef.current.observer) {
                    stateRef.current.observer.disconnect();
                    stateRef.current.observer = null;
                }
            };
            target.addEventListener('focusout', onBlurHandler, {
                once: true
            });
            stateRef.current.observer = new MutationObserver(()=>{
                if (stateRef.current.isFocused && target.disabled) {
                    var _stateRef_current_observer;
                    (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();
                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
                    target.dispatchEvent(new FocusEvent('blur', {
                        relatedTarget: relatedTargetEl
                    }));
                    target.dispatchEvent(new FocusEvent('focusout', {
                        bubbles: true,
                        relatedTarget: relatedTargetEl
                    }));
                }
            });
            stateRef.current.observer.observe(target, {
                attributes: true,
                attributeFilter: [
                    'disabled'
                ]
            });
        }
    }, [
        dispatchBlur
    ]);
}
let $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;
function $8a9cb279dc87e130$export$cabe61c495ee3649(target) {
    // The browser will focus the nearest focusable ancestor of our target.
    while(target && !(0, $6dfIe$isFocusable)(target))target = target.parentElement;
    let window = (0, $6dfIe$getOwnerWindow)(target);
    let activeElement = window.document.activeElement;
    if (!activeElement || activeElement === target) return;
    $8a9cb279dc87e130$export$fda7da73ab5d4c48 = true;
    let isRefocusing = false;
    let onBlur = (e)=>{
        if (e.target === activeElement || isRefocusing) e.stopImmediatePropagation();
    };
    let onFocusOut = (e)=>{
        if (e.target === activeElement || isRefocusing) {
            e.stopImmediatePropagation();
            // If there was no focusable ancestor, we don't expect a focus event.
            // Re-focus the original active element here.
            if (!target && !isRefocusing) {
                isRefocusing = true;
                (0, $6dfIe$focusWithoutScrolling)(activeElement);
                cleanup();
            }
        }
    };
    let onFocus = (e)=>{
        if (e.target === target || isRefocusing) e.stopImmediatePropagation();
    };
    let onFocusIn = (e)=>{
        if (e.target === target || isRefocusing) {
            e.stopImmediatePropagation();
            if (!isRefocusing) {
                isRefocusing = true;
                (0, $6dfIe$focusWithoutScrolling)(activeElement);
                cleanup();
            }
        }
    };
    window.addEventListener('blur', onBlur, true);
    window.addEventListener('focusout', onFocusOut, true);
    window.addEventListener('focusin', onFocusIn, true);
    window.addEventListener('focus', onFocus, true);
    let cleanup = ()=>{
        cancelAnimationFrame(raf);
        window.removeEventListener('blur', onBlur, true);
        window.removeEventListener('focusout', onFocusOut, true);
        window.removeEventListener('focusin', onFocusIn, true);
        window.removeEventListener('focus', onFocus, true);
        $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;
        isRefocusing = false;
    };
    let raf = requestAnimationFrame(cleanup);
    return cleanup;
}



//# sourceMappingURL=utils.module.js.map

;// CONCATENATED MODULE: ../../node_modules/@react-aria/utils/dist/platform.mjs
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $c87311424ea30a05$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    if (typeof window === 'undefined' || window.navigator == null) return false;
    let brands = (_window_navigator_userAgentData = window.navigator['userAgentData']) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands;
    return Array.isArray(brands) && brands.some((brand)=>re.test(brand.brand)) || re.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return typeof window !== 'undefined' && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator['userAgentData']) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$var$cached(fn) {
    if (false) {}
    let res = null;
    return ()=>{
        if (res == null) res = fn();
        return res;
    };
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testPlatform(/^Mac/i);
});
const $c87311424ea30a05$export$186c6964ca17d99 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testPlatform(/^iPhone/i);
});
const $c87311424ea30a05$export$7bef049ce92e4224 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
});
const $c87311424ea30a05$export$fedb369cb70207f1 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();
});
const $c87311424ea30a05$export$e1865c3bedcd822b = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();
});
const $c87311424ea30a05$export$78551043582a6a98 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();
});
const $c87311424ea30a05$export$6446a186d09e379e = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testUserAgent(/Chrome/i);
});
const platform_$c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
const $c87311424ea30a05$export$b7d78993b74f766d = $c87311424ea30a05$var$cached(function() {
    return $c87311424ea30a05$var$testUserAgent(/Firefox/i);
});



//# sourceMappingURL=platform.module.js.map

;// CONCATENATED MODULE: ../../node_modules/@react-aria/utils/dist/isVirtualEvent.mjs


/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6a7db85432448f7f$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.pointerType === '' && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ((0, platform_$c87311424ea30a05$export$a11b0059900ceec8)() && event.pointerType) return event.type === 'click' && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return !(0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse';
}



//# sourceMappingURL=isVirtualEvent.module.js.map

// EXTERNAL MODULE: ../../node_modules/@react-aria/utils/dist/domHelpers.mjs
var domHelpers = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/utils/dist/domHelpers.mjs");
;// CONCATENATED MODULE: ../../node_modules/@react-aria/interactions/dist/useFocusVisible.mjs





/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions




let $507fabe10e71c6fb$var$currentModality = null;
let $507fabe10e71c6fb$var$changeHandlers = new Set();
let $507fabe10e71c6fb$export$d90243b58daecda7 = new Map(); // We use a map here to support setting event listeners across multiple document objects.
let $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
let $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
// Only Tab or Esc keys will make focus visible on text input elements
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {
    for (let handler of $507fabe10e71c6fb$var$changeHandlers)handler(modality, e);
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */ function $507fabe10e71c6fb$var$isValidKey(e) {
    // Control and Shift keys trigger when navigating back to the tab with keyboard.
    return !(e.metaKey || !(0, $c87311424ea30a05$export$9ac100e40613ea10)() && e.altKey || e.ctrlKey || e.key === 'Control' || e.key === 'Shift' || e.key === 'Meta');
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    if ($507fabe10e71c6fb$var$isValidKey(e)) {
        $507fabe10e71c6fb$var$currentModality = 'keyboard';
        $507fabe10e71c6fb$var$triggerChangeHandlers('keyboard', e);
    }
}
function $507fabe10e71c6fb$var$handlePointerEvent(e) {
    $507fabe10e71c6fb$var$currentModality = 'pointer';
    if (e.type === 'mousedown' || e.type === 'pointerdown') {
        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
        $507fabe10e71c6fb$var$triggerChangeHandlers('pointer', e);
    }
}
function $507fabe10e71c6fb$var$handleClickEvent(e) {
    if ((0, $6a7db85432448f7f$export$60278871457622de)(e)) {
        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
        $507fabe10e71c6fb$var$currentModality = 'virtual';
    }
}
function $507fabe10e71c6fb$var$handleFocusEvent(e) {
    // Firefox fires two extra focus events when the user first clicks into an iframe:
    // first on the window, then on the document. We ignore these events so they don't
    // cause keyboard focus rings to appear.
    if (e.target === window || e.target === document || (0, $8a9cb279dc87e130$export$fda7da73ab5d4c48) || !e.isTrusted) return;
    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
    if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {
        $507fabe10e71c6fb$var$currentModality = 'virtual';
        $507fabe10e71c6fb$var$triggerChangeHandlers('virtual', e);
    }
    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
    $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
    if (0, $8a9cb279dc87e130$export$fda7da73ab5d4c48) return;
    // When the window is blurred, reset state. This is necessary when tabbing out of the window,
    // for example, since a subsequent focus event won't be fired.
    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
    $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */ function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {
    if (typeof window === 'undefined' || typeof document === 'undefined' || $507fabe10e71c6fb$export$d90243b58daecda7.get((0, domHelpers/* getOwnerWindow */.kR)(element))) return;
    const windowObject = (0, domHelpers/* getOwnerWindow */.kR)(element);
    const documentObject = (0, domHelpers/* getOwnerDocument */.r3)(element);
    // Programmatic focus() calls shouldn't affect the current input modality.
    // However, we need to detect other cases when a focus event occurs without
    // a preceding user event (e.g. screen reader focus). Overriding the focus
    // method on HTMLElement.prototype is a bit hacky, but works.
    let focus = windowObject.HTMLElement.prototype.focus;
    windowObject.HTMLElement.prototype.focus = function() {
        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
        focus.apply(this, arguments);
    };
    documentObject.addEventListener('keydown', $507fabe10e71c6fb$var$handleKeyboardEvent, true);
    documentObject.addEventListener('keyup', $507fabe10e71c6fb$var$handleKeyboardEvent, true);
    documentObject.addEventListener('click', $507fabe10e71c6fb$var$handleClickEvent, true);
    // Register focus events on the window so they are sure to happen
    // before React's event listeners (registered on the document).
    windowObject.addEventListener('focus', $507fabe10e71c6fb$var$handleFocusEvent, true);
    windowObject.addEventListener('blur', $507fabe10e71c6fb$var$handleWindowBlur, false);
    if (typeof PointerEvent !== 'undefined') {
        documentObject.addEventListener('pointerdown', $507fabe10e71c6fb$var$handlePointerEvent, true);
        documentObject.addEventListener('pointermove', $507fabe10e71c6fb$var$handlePointerEvent, true);
        documentObject.addEventListener('pointerup', $507fabe10e71c6fb$var$handlePointerEvent, true);
    } else if (false) {}
    // Add unmount handler
    windowObject.addEventListener('beforeunload', ()=>{
        $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);
    }, {
        once: true
    });
    $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {
        focus: focus
    });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener)=>{
    const windowObject = (0, domHelpers/* getOwnerWindow */.kR)(element);
    const documentObject = (0, domHelpers/* getOwnerDocument */.r3)(element);
    if (loadListener) documentObject.removeEventListener('DOMContentLoaded', loadListener);
    if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;
    windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;
    documentObject.removeEventListener('keydown', $507fabe10e71c6fb$var$handleKeyboardEvent, true);
    documentObject.removeEventListener('keyup', $507fabe10e71c6fb$var$handleKeyboardEvent, true);
    documentObject.removeEventListener('click', $507fabe10e71c6fb$var$handleClickEvent, true);
    windowObject.removeEventListener('focus', $507fabe10e71c6fb$var$handleFocusEvent, true);
    windowObject.removeEventListener('blur', $507fabe10e71c6fb$var$handleWindowBlur, false);
    if (typeof PointerEvent !== 'undefined') {
        documentObject.removeEventListener('pointerdown', $507fabe10e71c6fb$var$handlePointerEvent, true);
        documentObject.removeEventListener('pointermove', $507fabe10e71c6fb$var$handlePointerEvent, true);
        documentObject.removeEventListener('pointerup', $507fabe10e71c6fb$var$handlePointerEvent, true);
    } else if (false) {}
    $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element) {
    const documentObject = (0, domHelpers/* getOwnerDocument */.r3)(element);
    let loadListener;
    if (documentObject.readyState !== 'loading') $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
    else {
        loadListener = ()=>{
            $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
        };
        documentObject.addEventListener('DOMContentLoaded', loadListener);
    }
    return ()=>$507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);
}
// Server-side rendering does not have the document object defined
// eslint-disable-next-line no-restricted-globals
if (typeof document !== 'undefined') $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
    return $507fabe10e71c6fb$var$currentModality !== 'pointer';
}
function $507fabe10e71c6fb$export$630ff653c5ada6a9() {
    return $507fabe10e71c6fb$var$currentModality;
}
function $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {
    $507fabe10e71c6fb$var$currentModality = modality;
    $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);
}
function $507fabe10e71c6fb$export$98e20ec92f614cfe() {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents();
    let [modality, setModality] = (0, $28AnR$useState)($507fabe10e71c6fb$var$currentModality);
    (0, $28AnR$useEffect)(()=>{
        let handler = ()=>{
            setModality($507fabe10e71c6fb$var$currentModality);
        };
        $507fabe10e71c6fb$var$changeHandlers.add(handler);
        return ()=>{
            $507fabe10e71c6fb$var$changeHandlers.delete(handler);
        };
    }, []);
    return (0, $28AnR$useIsSSR)() ? null : modality;
}
const $507fabe10e71c6fb$var$nonTextInputTypes = new Set([
    'checkbox',
    'radio',
    'range',
    'color',
    'file',
    'image',
    'button',
    'submit',
    'reset'
]);
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */ function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e) {
    let document1 = (0, domHelpers/* getOwnerDocument */.r3)(e === null || e === void 0 ? void 0 : e.target);
    const IHTMLInputElement = typeof window !== 'undefined' ? (0, domHelpers/* getOwnerWindow */.kR)(e === null || e === void 0 ? void 0 : e.target).HTMLInputElement : HTMLInputElement;
    const IHTMLTextAreaElement = typeof window !== 'undefined' ? (0, domHelpers/* getOwnerWindow */.kR)(e === null || e === void 0 ? void 0 : e.target).HTMLTextAreaElement : HTMLTextAreaElement;
    const IHTMLElement = typeof window !== 'undefined' ? (0, domHelpers/* getOwnerWindow */.kR)(e === null || e === void 0 ? void 0 : e.target).HTMLElement : HTMLElement;
    const IKeyboardEvent = typeof window !== 'undefined' ? (0, domHelpers/* getOwnerWindow */.kR)(e === null || e === void 0 ? void 0 : e.target).KeyboardEvent : KeyboardEvent;
    // For keyboard events that occur on a non-input element that will move focus into input element (aka ArrowLeft going from Datepicker button to the main input group)
    // we need to rely on the user passing isTextInput into here. This way we can skip toggling focus visiblity for said input element
    isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable;
    return !(isTextInput && modality === 'keyboard' && e instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
function $507fabe10e71c6fb$export$ffd9e5021c1fb2d6(props = {}) {
    let { isTextInput: isTextInput, autoFocus: autoFocus } = props;
    let [isFocusVisibleState, setFocusVisible] = (0, $28AnR$useState)(autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27());
    $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible)=>{
        setFocusVisible(isFocusVisible);
    }, [
        isTextInput
    ], {
        isTextInput: isTextInput
    });
    return {
        isFocusVisible: isFocusVisibleState
    };
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents();
    (0, react.useEffect)(()=>{
        let handler = (modality, e)=>{
            // We want to early return for any keyboard events that occur inside text inputs EXCEPT for Tab and Escape
            if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e)) return;
            fn($507fabe10e71c6fb$export$b9b3dfddab17db27());
        };
        $507fabe10e71c6fb$var$changeHandlers.add(handler);
        return ()=>{
            $507fabe10e71c6fb$var$changeHandlers.delete(handler);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
}



//# sourceMappingURL=useFocusVisible.module.js.map

// EXTERNAL MODULE: ../../node_modules/@react-aria/utils/dist/DOMFunctions.mjs + 1 modules
var DOMFunctions = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/utils/dist/DOMFunctions.mjs");
;// CONCATENATED MODULE: ../../node_modules/@react-aria/interactions/dist/useFocus.mjs




/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions



function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
    let { isDisabled: isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange: onFocusChange } = props;
    const onBlur = (0, react.useCallback)((e)=>{
        if (e.target === e.currentTarget) {
            if (onBlurProp) onBlurProp(e);
            if (onFocusChange) onFocusChange(false);
            return true;
        }
    }, [
        onBlurProp,
        onFocusChange
    ]);
    const onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
    const onFocus = (0, react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        const ownerDocument = (0, domHelpers/* getOwnerDocument */.r3)(e.target);
        const activeElement = ownerDocument ? (0, DOMFunctions/* getActiveElement */.vY)(ownerDocument) : (0, DOMFunctions/* getActiveElement */.vY)();
        if (e.target === e.currentTarget && activeElement === (0, DOMFunctions/* getEventTarget */.NI)(e.nativeEvent)) {
            if (onFocusProp) onFocusProp(e);
            if (onFocusChange) onFocusChange(true);
            onSyntheticFocus(e);
        }
    }, [
        onFocusChange,
        onFocusProp,
        onSyntheticFocus
    ]);
    return {
        focusProps: {
            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,
            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined
        }
    };
}



//# sourceMappingURL=useFocus.module.js.map

// EXTERNAL MODULE: ../../node_modules/@react-aria/utils/dist/useGlobalListeners.mjs
var useGlobalListeners = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/utils/dist/useGlobalListeners.mjs");
;// CONCATENATED MODULE: ../../node_modules/@react-aria/interactions/dist/useFocusWithin.mjs




/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions



function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
    let { isDisabled: isDisabled, onBlurWithin: onBlurWithin, onFocusWithin: onFocusWithin, onFocusWithinChange: onFocusWithinChange } = props;
    let state = (0, react.useRef)({
        isFocusWithin: false
    });
    let { addGlobalListener: addGlobalListener, removeAllGlobalListeners: removeAllGlobalListeners } = (0, useGlobalListeners/* useGlobalListeners */.x)();
    let onBlur = (0, react.useCallback)((e)=>{
        // Ignore events bubbling through portals.
        if (!e.currentTarget.contains(e.target)) return;
        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
        // when moving focus inside the element. Only trigger if the currentTarget doesn't
        // include the relatedTarget (where focus is moving).
        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
            state.current.isFocusWithin = false;
            removeAllGlobalListeners();
            if (onBlurWithin) onBlurWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(false);
        }
    }, [
        onBlurWithin,
        onFocusWithinChange,
        state,
        removeAllGlobalListeners
    ]);
    let onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
    let onFocus = (0, react.useCallback)((e)=>{
        // Ignore events bubbling through portals.
        if (!e.currentTarget.contains(e.target)) return;
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        const ownerDocument = (0, domHelpers/* getOwnerDocument */.r3)(e.target);
        const activeElement = (0, DOMFunctions/* getActiveElement */.vY)(ownerDocument);
        if (!state.current.isFocusWithin && activeElement === (0, DOMFunctions/* getEventTarget */.NI)(e.nativeEvent)) {
            if (onFocusWithin) onFocusWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(true);
            state.current.isFocusWithin = true;
            onSyntheticFocus(e);
            // Browsers don't fire blur events when elements are removed from the DOM.
            // However, if a focus event occurs outside the element we're tracking, we
            // can manually fire onBlur.
            let currentTarget = e.currentTarget;
            addGlobalListener(ownerDocument, 'focus', (e)=>{
                if (state.current.isFocusWithin && !(0, DOMFunctions/* nodeContains */.bE)(currentTarget, e.target)) {
                    let nativeEvent = new ownerDocument.defaultView.FocusEvent('blur', {
                        relatedTarget: e.target
                    });
                    (0, $8a9cb279dc87e130$export$c2b7abe5d61ec696)(nativeEvent, currentTarget);
                    let event = (0, $8a9cb279dc87e130$export$525bc4921d56d4a)(nativeEvent);
                    onBlur(event);
                }
            }, {
                capture: true
            });
        }
    }, [
        onFocusWithin,
        onFocusWithinChange,
        onSyntheticFocus,
        addGlobalListener,
        onBlur
    ]);
    if (isDisabled) return {
        focusWithinProps: {
            // These cannot be null, that would conflict in mergeProps
            onFocus: undefined,
            onBlur: undefined
        }
    };
    return {
        focusWithinProps: {
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}



//# sourceMappingURL=useFocusWithin.module.js.map

;// CONCATENATED MODULE: ../../node_modules/@react-aria/focus/dist/useFocusRing.mjs





function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
    let { autoFocus: autoFocus = false, isTextInput: isTextInput, within: within } = props;
    let state = (0, react.useRef)({
        isFocused: false,
        isFocusVisible: autoFocus || (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()
    });
    let [isFocused, setFocused] = (0, react.useState)(false);
    let [isFocusVisibleState, setFocusVisible] = (0, react.useState)(()=>state.current.isFocused && state.current.isFocusVisible);
    let updateState = (0, react.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
    let onFocusChange = (0, react.useCallback)((isFocused)=>{
        state.current.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    }, [
        updateState
    ]);
    (0, $507fabe10e71c6fb$export$ec71b4b83ac08ec3)((isFocusVisible)=>{
        state.current.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused,
        isFocusVisible: isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}



//# sourceMappingURL=useFocusRing.module.js.map


/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@react-aria/interactions/dist/useHover.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   X: function() { return /* binding */ $6179b936705e76d3$export$ae780daf29e6d456; }
/* harmony export */ });
/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/utils/dist/useGlobalListeners.mjs");
/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/utils/dist/domHelpers.mjs");
/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/utils/dist/DOMFunctions.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
let $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;
    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
    // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
    // the distant future because a user previously touched the element.
    setTimeout(()=>{
        $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
    }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e) {
    if (e.pointerType === 'touch') $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
    if (typeof document === 'undefined') return;
    if ($6179b936705e76d3$var$hoverCount === 0) {
        if (typeof PointerEvent !== 'undefined') document.addEventListener('pointerup', $6179b936705e76d3$var$handleGlobalPointerEvent);
        else if (false) {}
    }
    $6179b936705e76d3$var$hoverCount++;
    return ()=>{
        $6179b936705e76d3$var$hoverCount--;
        if ($6179b936705e76d3$var$hoverCount > 0) return;
        if (typeof PointerEvent !== 'undefined') document.removeEventListener('pointerup', $6179b936705e76d3$var$handleGlobalPointerEvent);
        else if (false) {}
    };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
    let { onHoverStart: onHoverStart, onHoverChange: onHoverChange, onHoverEnd: onHoverEnd, isDisabled: isDisabled } = props;
    let [isHovered, setHovered] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({
        isHovered: false,
        ignoreEmulatedMouseEvents: false,
        pointerType: '',
        target: null
    }).current;
    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);
    let { addGlobalListener: addGlobalListener, removeAllGlobalListeners: removeAllGlobalListeners } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__/* .useGlobalListeners */ .x)();
    let { hoverProps: hoverProps, triggerHoverEnd: triggerHoverEnd } = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{
        let triggerHoverStart = (event, pointerType)=>{
            state.pointerType = pointerType;
            if (isDisabled || pointerType === 'touch' || state.isHovered || !event.currentTarget.contains(event.target)) return;
            state.isHovered = true;
            let target = event.currentTarget;
            state.target = target;
            // When an element that is hovered over is removed, no pointerleave event is fired by the browser,
            // even though the originally hovered target may have shrunk in size so it is no longer hovered.
            // However, a pointerover event will be fired on the new target the mouse is over.
            // In Chrome this happens immediately. In Safari and Firefox, it happens upon moving the mouse one pixel.
            addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__/* .getOwnerDocument */ .r3)(event.target), 'pointerover', (e)=>{
                if (state.isHovered && state.target && !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__/* .nodeContains */ .bE)(state.target, e.target)) triggerHoverEnd(e, e.pointerType);
            }, {
                capture: true
            });
            if (onHoverStart) onHoverStart({
                type: 'hoverstart',
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(true);
            setHovered(true);
        };
        let triggerHoverEnd = (event, pointerType)=>{
            let target = state.target;
            state.pointerType = '';
            state.target = null;
            if (pointerType === 'touch' || !state.isHovered || !target) return;
            state.isHovered = false;
            removeAllGlobalListeners();
            if (onHoverEnd) onHoverEnd({
                type: 'hoverend',
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(false);
            setHovered(false);
        };
        let hoverProps = {};
        if (typeof PointerEvent !== 'undefined') {
            hoverProps.onPointerEnter = (e)=>{
                if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e.pointerType === 'mouse') return;
                triggerHoverStart(e, e.pointerType);
            };
            hoverProps.onPointerLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);
            };
        } else if (false) {}
        return {
            hoverProps: hoverProps,
            triggerHoverEnd: triggerHoverEnd
        };
    }, [
        onHoverStart,
        onHoverChange,
        onHoverEnd,
        isDisabled,
        state,
        addGlobalListener,
        removeAllGlobalListeners
    ]);
    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        // Call the triggerHoverEnd as soon as isDisabled changes to true
        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
        if (isDisabled) triggerHoverEnd({
            currentTarget: state.target
        }, state.pointerType);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled
    ]);
    return {
        hoverProps: hoverProps,
        isHovered: isHovered
    };
}



//# sourceMappingURL=useHover.module.js.map


/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@react-aria/utils/dist/DOMFunctions.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  vY: function() { return /* binding */ $d4ee10de306f2510$export$cd4e5573fbe2b576; },
  NI: function() { return /* binding */ $d4ee10de306f2510$export$e58f029f0fbfdb29; },
  bE: function() { return /* binding */ $d4ee10de306f2510$export$4282f70798064fe0; }
});

// EXTERNAL MODULE: ../../node_modules/@react-aria/utils/dist/domHelpers.mjs
var domHelpers = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/utils/dist/domHelpers.mjs");
;// CONCATENATED MODULE: ../../node_modules/@react-stately/flags/dist/import.mjs
/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ let $f4e2df6bd15f8569$var$_tableNestedRows = false;
let $f4e2df6bd15f8569$var$_shadowDOM = false;
function $f4e2df6bd15f8569$export$d9d8a0f82de49530() {
    $f4e2df6bd15f8569$var$_tableNestedRows = true;
}
function $f4e2df6bd15f8569$export$1b00cb14a96194e6() {
    return $f4e2df6bd15f8569$var$_tableNestedRows;
}
function $f4e2df6bd15f8569$export$12b151d9882e9985() {
    $f4e2df6bd15f8569$var$_shadowDOM = true;
}
function $f4e2df6bd15f8569$export$98658e8c59125e6a() {
    return $f4e2df6bd15f8569$var$_shadowDOM;
}



//# sourceMappingURL=module.js.map

;// CONCATENATED MODULE: ../../node_modules/@react-aria/utils/dist/DOMFunctions.mjs



// Source: https://github.com/microsoft/tabster/blob/a89fc5d7e332d48f68d03b1ca6e344489d1c3898/src/Shadowdomize/DOMFunctions.ts#L16


function $d4ee10de306f2510$export$4282f70798064fe0(node, otherNode) {
    if (!(0, $f4e2df6bd15f8569$export$98658e8c59125e6a)()) return otherNode && node ? node.contains(otherNode) : false;
    if (!node || !otherNode) return false;
    let currentNode = otherNode;
    while(currentNode !== null){
        if (currentNode === node) return true;
        if (currentNode.tagName === 'SLOT' && currentNode.assignedSlot) // Element is slotted
        currentNode = currentNode.assignedSlot.parentNode;
        else if ((0, domHelpers/* isShadowRoot */.Zq)(currentNode)) // Element is in shadow root
        currentNode = currentNode.host;
        else currentNode = currentNode.parentNode;
    }
    return false;
}
const $d4ee10de306f2510$export$cd4e5573fbe2b576 = (doc = document)=>{
    var _activeElement_shadowRoot;
    if (!(0, $f4e2df6bd15f8569$export$98658e8c59125e6a)()) return doc.activeElement;
    let activeElement = doc.activeElement;
    while(activeElement && 'shadowRoot' in activeElement && ((_activeElement_shadowRoot = activeElement.shadowRoot) === null || _activeElement_shadowRoot === void 0 ? void 0 : _activeElement_shadowRoot.activeElement))activeElement = activeElement.shadowRoot.activeElement;
    return activeElement;
};
function $d4ee10de306f2510$export$e58f029f0fbfdb29(event) {
    if ((0, $f4e2df6bd15f8569$export$98658e8c59125e6a)() && event.target.shadowRoot) {
        if (event.composedPath) return event.composedPath()[0];
    }
    return event.target;
}



//# sourceMappingURL=DOMFunctions.module.js.map


/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@react-aria/utils/dist/domHelpers.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Zq: function() { return /* binding */ $431fbd86ca7dc216$export$af51f0f06c0f328a; },
/* harmony export */   kR: function() { return /* binding */ $431fbd86ca7dc216$export$f21a1ffae260145a; },
/* harmony export */   r3: function() { return /* binding */ $431fbd86ca7dc216$export$b204af158042fbac; }
/* harmony export */ });
const $431fbd86ca7dc216$export$b204af158042fbac = (el)=>{
    var _el_ownerDocument;
    return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
};
const $431fbd86ca7dc216$export$f21a1ffae260145a = (el)=>{
    if (el && 'window' in el && el.window === el) return el;
    const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);
    return doc.defaultView || window;
};
/**
 * Type guard that checks if a value is a Node. Verifies the presence and type of the nodeType property.
 */ function $431fbd86ca7dc216$var$isNode(value) {
    return value !== null && typeof value === 'object' && 'nodeType' in value && typeof value.nodeType === 'number';
}
function $431fbd86ca7dc216$export$af51f0f06c0f328a(node) {
    return $431fbd86ca7dc216$var$isNode(node) && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && 'host' in node;
}



//# sourceMappingURL=domHelpers.module.js.map


/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@react-aria/utils/dist/useGlobalListeners.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: function() { return /* binding */ $03deb23ff14920c4$export$4eaf04e54aa8eed6; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
    let globalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());
    let addGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, fn, options);
    }, []);
    let removeGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{
        var _globalListeners_current_get;
        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}



//# sourceMappingURL=useGlobalListeners.module.js.map


/***/ }),

/***/ "(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export clsx */
function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f)}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}/* harmony default export */ __webpack_exports__.Z = (clsx);

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/next-themes/dist/index.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: function() { return /* binding */ z; },
/* harmony export */   ThemeProvider: function() { return /* binding */ J; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
/* __next_internal_client_entry_do_not_use__ ThemeProvider,useTheme auto */ 
var M = (e, i, s, u, m, a, l, h)=>{
    let d = document.documentElement, w = [
        "light",
        "dark"
    ];
    function p(n) {
        (Array.isArray(e) ? e : [
            e
        ]).forEach((y)=>{
            let k = y === "class", S = k && a ? m.map((f)=>a[f] || f) : m;
            k ? (d.classList.remove(...S), d.classList.add(a && a[n] ? a[n] : n)) : d.setAttribute(y, n);
        }), R(n);
    }
    function R(n) {
        h && w.includes(n) && (d.style.colorScheme = n);
    }
    function c() {
        return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    if (u) p(u);
    else try {
        let n = localStorage.getItem(i) || s, y = l && n === "system" ? c() : n;
        p(y);
    } catch (n) {}
};
var b = [
    "light",
    "dark"
], I = "(prefers-color-scheme: dark)", O = typeof window == "undefined", x = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0), U = {
    setTheme: (e)=>{},
    themes: []
}, z = ()=>{
    var e;
    return (e = react__WEBPACK_IMPORTED_MODULE_0__.useContext(x)) != null ? e : U;
}, J = (e)=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(x) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, e.children) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(V, {
        ...e
    }), N = [
    "light",
    "dark"
], V = (param)=>{
    let { forcedTheme: e, disableTransitionOnChange: i = !1, enableSystem: s = !0, enableColorScheme: u = !0, storageKey: m = "theme", themes: a = N, defaultTheme: l = s ? "system" : "light", attribute: h = "data-theme", value: d, children: w, nonce: p, scriptProps: R } = param;
    let [c, n] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>H(m, l)), [T, y] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>c === "system" ? E() : c), k = d ? Object.values(d) : a, S = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((o)=>{
        let r = o;
        if (!r) return;
        o === "system" && s && (r = E());
        let v = d ? d[r] : r, C = i ? W(p) : null, P = document.documentElement, L = (g)=>{
            g === "class" ? (P.classList.remove(...k), v && P.classList.add(v)) : g.startsWith("data-") && (v ? P.setAttribute(g, v) : P.removeAttribute(g));
        };
        if (Array.isArray(h) ? h.forEach(L) : L(h), u) {
            let g = b.includes(l) ? l : null, D = b.includes(r) ? r : g;
            P.style.colorScheme = D;
        }
        C == null || C();
    }, [
        p
    ]), f = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((o)=>{
        let r = typeof o == "function" ? o(c) : o;
        n(r);
        try {
            localStorage.setItem(m, r);
        } catch (v) {}
    }, [
        c
    ]), A = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((o)=>{
        let r = E(o);
        y(r), c === "system" && s && !e && S("system");
    }, [
        c,
        e
    ]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{
        let o = window.matchMedia(I);
        return o.addListener(A), A(o), ()=>o.removeListener(A);
    }, [
        A
    ]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{
        let o = (r)=>{
            r.key === m && (r.newValue ? n(r.newValue) : f(l));
        };
        return window.addEventListener("storage", o), ()=>window.removeEventListener("storage", o);
    }, [
        f
    ]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{
        S(e != null ? e : c);
    }, [
        e,
        c
    ]);
    let Q = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({
            theme: c,
            setTheme: f,
            forcedTheme: e,
            resolvedTheme: c === "system" ? T : c,
            themes: s ? [
                ...a,
                "system"
            ] : a,
            systemTheme: s ? T : void 0
        }), [
        c,
        f,
        e,
        T,
        s,
        a
    ]);
    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(x.Provider, {
        value: Q
    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_, {
        forcedTheme: e,
        storageKey: m,
        attribute: h,
        enableSystem: s,
        enableColorScheme: u,
        defaultTheme: l,
        value: d,
        themes: a,
        nonce: p,
        scriptProps: R
    }), w);
}, _ = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo((param)=>{
    let { forcedTheme: e, storageKey: i, attribute: s, enableSystem: u, enableColorScheme: m, defaultTheme: a, value: l, themes: h, nonce: d, scriptProps: w } = param;
    let p = JSON.stringify([
        s,
        i,
        a,
        e,
        h,
        l,
        u,
        m
    ]).slice(1, -1);
    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", {
        ...w,
        suppressHydrationWarning: !0,
        nonce: typeof window == "undefined" ? d : "",
        dangerouslySetInnerHTML: {
            __html: "(".concat(M.toString(), ")(").concat(p, ")")
        }
    });
}), H = (e, i)=>{
    if (O) return;
    let s;
    try {
        s = localStorage.getItem(e) || void 0;
    } catch (u) {}
    return s || i;
}, W = (e)=>{
    let i = document.createElement("style");
    return e && i.setAttribute("nonce", e), i.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), document.head.appendChild(i), ()=>{
        window.getComputedStyle(document.body), setTimeout(()=>{
            document.head.removeChild(i);
        }, 1);
    };
}, E = (e)=>(e || (e = window.matchMedia(I)), e.matches ? "dark" : "light");



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/scroll-into-view-if-needed/dist/index.js":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ dist_e; }
});

;// CONCATENATED MODULE: ../../node_modules/compute-scroll-into-view/dist/index.js
const t=t=>"object"==typeof t&&null!=t&&1===t.nodeType,e=(t,e)=>(!e||"hidden"!==t)&&("visible"!==t&&"clip"!==t),n=(t,n)=>{if(t.clientHeight<t.scrollHeight||t.clientWidth<t.scrollWidth){const o=getComputedStyle(t,null);return e(o.overflowY,n)||e(o.overflowX,n)||(t=>{const e=(t=>{if(!t.ownerDocument||!t.ownerDocument.defaultView)return null;try{return t.ownerDocument.defaultView.frameElement}catch(t){return null}})(t);return!!e&&(e.clientHeight<t.scrollHeight||e.clientWidth<t.scrollWidth)})(t)}return!1},o=(t,e,n,o,l,r,i,s)=>r<t&&i>e||r>t&&i<e?0:r<=t&&s<=n||i>=e&&s>=n?r-t-o:i>e&&s<n||r<t&&s>n?i-e+l:0,l=t=>{const e=t.parentElement;return null==e?t.getRootNode().host||null:e},dist_r=(e,r)=>{var i,s,d,h;if("undefined"==typeof document)return[];const{scrollMode:c,block:f,inline:u,boundary:a,skipOverflowHiddenElements:g}=r,p="function"==typeof a?a:t=>t!==a;if(!t(e))throw new TypeError("Invalid target");const m=document.scrollingElement||document.documentElement,w=[];let W=e;for(;t(W)&&p(W);){if(W=l(W),W===m){w.push(W);break}null!=W&&W===document.body&&n(W)&&!n(document.documentElement)||null!=W&&n(W,g)&&w.push(W)}const b=null!=(s=null==(i=window.visualViewport)?void 0:i.width)?s:innerWidth,H=null!=(h=null==(d=window.visualViewport)?void 0:d.height)?h:innerHeight,{scrollX:y,scrollY:M}=window,{height:v,width:E,top:x,right:C,bottom:I,left:R}=e.getBoundingClientRect(),{top:T,right:B,bottom:F,left:V}=(t=>{const e=window.getComputedStyle(t);return{top:parseFloat(e.scrollMarginTop)||0,right:parseFloat(e.scrollMarginRight)||0,bottom:parseFloat(e.scrollMarginBottom)||0,left:parseFloat(e.scrollMarginLeft)||0}})(e);let k="start"===f||"nearest"===f?x-T:"end"===f?I+F:x+v/2-T+F,D="center"===u?R+E/2-V+B:"end"===u?C+B:R-V;const L=[];for(let t=0;t<w.length;t++){const e=w[t],{height:l,width:r,top:i,right:s,bottom:d,left:h}=e.getBoundingClientRect();if("if-needed"===c&&x>=0&&R>=0&&I<=H&&C<=b&&(e===m&&!n(e)||x>=i&&I<=d&&R>=h&&C<=s))return L;const a=getComputedStyle(e),g=parseInt(a.borderLeftWidth,10),p=parseInt(a.borderTopWidth,10),W=parseInt(a.borderRightWidth,10),T=parseInt(a.borderBottomWidth,10);let B=0,F=0;const V="offsetWidth"in e?e.offsetWidth-e.clientWidth-g-W:0,S="offsetHeight"in e?e.offsetHeight-e.clientHeight-p-T:0,X="offsetWidth"in e?0===e.offsetWidth?0:r/e.offsetWidth:0,Y="offsetHeight"in e?0===e.offsetHeight?0:l/e.offsetHeight:0;if(m===e)B="start"===f?k:"end"===f?k-H:"nearest"===f?o(M,M+H,H,p,T,M+k,M+k+v,v):k-H/2,F="start"===u?D:"center"===u?D-b/2:"end"===u?D-b:o(y,y+b,b,g,W,y+D,y+D+E,E),B=Math.max(0,B+M),F=Math.max(0,F+y);else{B="start"===f?k-i-p:"end"===f?k-d+T+S:"nearest"===f?o(i,d,l,p,T+S,k,k+v,v):k-(i+l/2)+S/2,F="start"===u?D-h-g:"center"===u?D-(h+r/2)+V/2:"end"===u?D-s+W+V:o(h,s,r,g,W+V,D,D+E,E);const{scrollLeft:t,scrollTop:n}=e;B=0===Y?0:Math.max(0,Math.min(n+B/Y,e.scrollHeight-l/Y+S)),F=0===X?0:Math.max(0,Math.min(t+F/X,e.scrollWidth-r/X+V)),k+=n-B,D+=t-F}L.push({el:e,top:B,left:F})}return L};//# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ../../node_modules/scroll-into-view-if-needed/dist/index.js
const dist_o=t=>!1===t?{block:"end",inline:"nearest"}:(t=>t===Object(t)&&0!==Object.keys(t).length)(t)?t:{block:"start",inline:"nearest"};function dist_e(e,r){if(!e.isConnected||!(t=>{let o=t;for(;o&&o.parentNode;){if(o.parentNode===document)return!0;o=o.parentNode instanceof ShadowRoot?o.parentNode.host:o.parentNode}return!1})(e))return;const n=(t=>{const o=window.getComputedStyle(t);return{top:parseFloat(o.scrollMarginTop)||0,right:parseFloat(o.scrollMarginRight)||0,bottom:parseFloat(o.scrollMarginBottom)||0,left:parseFloat(o.scrollMarginLeft)||0}})(e);if((t=>"object"==typeof t&&"function"==typeof t.behavior)(r))return r.behavior(dist_r(e,r));const l="boolean"==typeof r||null==r?void 0:r.behavior;for(const{el:a,top:i,left:s}of dist_r(e,dist_o(r))){const t=i-n.top+n.bottom,o=s-n.left+n.right;a.scroll({top:t,left:o,behavior:l})}}//# sourceMappingURL=index.js.map


/***/ }),

/***/ "(app-pages-browser)/../../node_modules/zustand/esm/react.mjs":
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  U: function() { return /* binding */ create; }
});

// UNUSED EXPORTS: useStore

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
;// CONCATENATED MODULE: ../../node_modules/zustand/esm/vanilla.mjs
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
const createStore = ((createState) => createState ? createStoreImpl(createState) : createStoreImpl);



;// CONCATENATED MODULE: ../../node_modules/zustand/esm/react.mjs



const identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = react.useSyncExternalStore(
    api.subscribe,
    react.useCallback(() => selector(api.getState()), [api, selector]),
    react.useCallback(() => selector(api.getInitialState()), [api, selector])
  );
  react.useDebugValue(slice);
  return slice;
}
const createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = ((createState) => createState ? createImpl(createState) : createImpl);




/***/ })

}]);