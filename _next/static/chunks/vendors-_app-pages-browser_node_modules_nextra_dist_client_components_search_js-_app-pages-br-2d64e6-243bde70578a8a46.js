(self["webpackJsonpNextraApp"] = self["webpackJsonpNextraApp"] || []).push([["vendors-_app-pages-browser_node_modules_nextra_dist_client_components_search_js-_app-pages-br-2d64e6"],{

/***/ "(app-pages-browser)/../../node_modules/nextra/dist/client/components/search.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Search: function() { return /* binding */ Search; }
});

// UNUSED EXPORTS: importPagefind

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js");
// EXTERNAL MODULE: ../../node_modules/react-compiler-runtime/dist/index.js
var dist = __webpack_require__("(app-pages-browser)/../../node_modules/react-compiler-runtime/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/@react-aria/focus/dist/useFocusRing.mjs + 8 modules
var useFocusRing = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/focus/dist/useFocusRing.mjs");
// EXTERNAL MODULE: ../../node_modules/@react-aria/interactions/dist/useHover.mjs
var useHover = __webpack_require__("(app-pages-browser)/../../node_modules/@react-aria/interactions/dist/useHover.mjs");
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js");
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/index.js
var react_dom = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js");
;// CONCATENATED MODULE: ../../node_modules/@tanstack/virtual-core/dist/esm/utils.js
function memo(getDeps, fn, opts) {
  let deps = opts.initialDeps ?? [];
  let result;
  function memoizedFunction() {
    var _a, _b, _c, _d;
    let depTime;
    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();
    result = fn(...newDeps);
    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {
      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      const resultFpsPercentage = resultEndTime / 16;
      const pad = (str, num) => {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info(
        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * resultFpsPercentage, 120)
        )}deg 100% 31%);`,
        opts == null ? void 0 : opts.key
      );
    }
    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);
    return result;
  }
  memoizedFunction.updateDeps = (newDeps) => {
    deps = newDeps;
  };
  return memoizedFunction;
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ""}`);
  } else {
    return value;
  }
}
const approxEqual = (a, b) => Math.abs(a - b) < 1.01;
const utils_debounce = (targetWindow, fn, ms) => {
  let timeoutId;
  return function(...args) {
    targetWindow.clearTimeout(timeoutId);
    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);
  };
};

//# sourceMappingURL=utils.js.map

;// CONCATENATED MODULE: ../../node_modules/@tanstack/virtual-core/dist/esm/index.js

const getRect = (element) => {
  const { offsetWidth, offsetHeight } = element;
  return { width: offsetWidth, height: offsetHeight };
};
const defaultKeyExtractor = (index) => index;
const defaultRangeExtractor = (range) => {
  const start = Math.max(range.startIndex - range.overscan, 0);
  const end = Math.min(range.endIndex + range.overscan, range.count - 1);
  const arr = [];
  for (let i = start; i <= end; i++) {
    arr.push(i);
  }
  return arr;
};
const observeElementRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  const handler = (rect) => {
    const { width, height } = rect;
    cb({ width: Math.round(width), height: Math.round(height) });
  };
  handler(getRect(element));
  if (!targetWindow.ResizeObserver) {
    return () => {
    };
  }
  const observer = new targetWindow.ResizeObserver((entries) => {
    const run = () => {
      const entry = entries[0];
      if (entry == null ? void 0 : entry.borderBoxSize) {
        const box = entry.borderBoxSize[0];
        if (box) {
          handler({ width: box.inlineSize, height: box.blockSize });
          return;
        }
      }
      handler(getRect(element));
    };
    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
  });
  observer.observe(element, { box: "border-box" });
  return () => {
    observer.unobserve(element);
  };
};
const addEventListenerOptions = {
  passive: true
};
const esm_observeWindowRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const handler = () => {
    cb({ width: element.innerWidth, height: element.innerHeight });
  };
  handler();
  element.addEventListener("resize", handler, addEventListenerOptions);
  return () => {
    element.removeEventListener("resize", handler);
  };
};
const supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
const observeElementOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset = 0;
  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : utils_debounce(
    targetWindow,
    () => {
      cb(offset, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    const { horizontal, isRtl } = instance.options;
    offset = horizontal ? element["scrollLeft"] * (isRtl && -1 || 1) : element["scrollTop"];
    fallback();
    cb(offset, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
  if (registerScrollendEvent) {
    element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  }
  return () => {
    element.removeEventListener("scroll", handler);
    if (registerScrollendEvent) {
      element.removeEventListener("scrollend", endHandler);
    }
  };
};
const esm_observeWindowOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset = 0;
  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(
    targetWindow,
    () => {
      cb(offset, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    offset = element[instance.options.horizontal ? "scrollX" : "scrollY"];
    fallback();
    cb(offset, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
  if (registerScrollendEvent) {
    element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  }
  return () => {
    element.removeEventListener("scroll", handler);
    if (registerScrollendEvent) {
      element.removeEventListener("scrollend", endHandler);
    }
  };
};
const measureElement = (element, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size;
    }
  }
  return element[instance.options.horizontal ? "offsetWidth" : "offsetHeight"];
};
const esm_windowScroll = (offset, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a, _b;
  const toOffset = offset + adjustments;
  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
const elementScroll = (offset, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a, _b;
  const toOffset = offset + adjustments;
  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
class Virtualizer {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.targetWindow = null;
    this.isScrolling = false;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.scrollRect = null;
    this.scrollOffset = null;
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.elementsCache = /* @__PURE__ */ new Map();
    this.observer = /* @__PURE__ */ (() => {
      let _ro = null;
      const get = () => {
        if (_ro) {
          return _ro;
        }
        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {
          return null;
        }
        return _ro = new this.targetWindow.ResizeObserver((entries) => {
          entries.forEach((entry) => {
            const run = () => {
              this._measureElement(entry.target, entry);
            };
            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
          });
        });
      };
      return {
        disconnect: () => {
          var _a;
          (_a = get()) == null ? void 0 : _a.disconnect();
          _ro = null;
        },
        observe: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined") delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: true,
        isRtl: false,
        useScrollendEvent: false,
        useAnimationFrameWithResizeObserver: false,
        ...opts2
      };
    };
    this.notify = (sync) => {
      var _a, _b;
      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);
    };
    this.maybeNotify = memo(
      () => {
        this.calculateRange();
        return [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ];
      },
      (isScrolling) => {
        this.notify(isScrolling);
      },
      {
        key:  false && 0,
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    );
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d) => d());
      this.unsubs = [];
      this.observer.disconnect();
      this.scrollElement = null;
      this.targetWindow = null;
    };
    this._didMount = () => {
      return () => {
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      var _a;
      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        if (!scrollElement) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = scrollElement;
        if (this.scrollElement && "ownerDocument" in this.scrollElement) {
          this.targetWindow = this.scrollElement.ownerDocument.defaultView;
        } else {
          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;
        }
        this.elementsCache.forEach((cached) => {
          this.observer.observe(cached);
        });
        this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.maybeNotify();
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? "forward" : "backward" : null;
            this.scrollOffset = offset;
            this.isScrolling = isScrolling;
            this.maybeNotify();
          })
        );
      }
    };
    this.getSize = () => {
      if (!this.options.enabled) {
        this.scrollRect = null;
        return 0;
      }
      this.scrollRect = this.scrollRect ?? this.options.initialRect;
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getScrollOffset = () => {
      if (!this.options.enabled) {
        this.scrollOffset = null;
        return 0;
      }
      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset);
      return this.scrollOffset;
    };
    this.getFurthestMeasurement = (measurements, index) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m = index - 1; m >= 0; m--) {
        const measurement = measurements[m];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {
        if (a.end === b.end) {
          return a.index - b.index;
        }
        return a.end - b.end;
      })[0] : void 0;
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (count, paddingStart, scrollMargin, getItemKey, enabled) => {
        this.pendingMeasuredCacheIndexes = [];
        return {
          count,
          paddingStart,
          scrollMargin,
          getItemKey,
          enabled
        };
      },
      {
        key: false
      }
    );
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {
        if (!enabled) {
          this.measurementsCache = [];
          this.itemSizeCache.clear();
          return [];
        }
        if (this.measurementsCache.length === 0) {
          this.measurementsCache = this.options.initialMeasurementsCache;
          this.measurementsCache.forEach((item) => {
            this.itemSizeCache.set(item.key, item.size);
          });
        }
        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const measurements = this.measurementsCache.slice(0, min);
        for (let i = min; i < count; i++) {
          const key = getItemKey(i);
          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);
          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          const measuredSize = itemSizeCache.get(key);
          const size = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i);
          const end = start + size;
          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;
          measurements[i] = {
            index: i,
            start,
            size,
            end,
            key,
            lane
          };
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key:  false && 0,
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [
        this.getMeasurements(),
        this.getSize(),
        this.getScrollOffset(),
        this.options.lanes
      ],
      (measurements, outerSize, scrollOffset, lanes) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset,
          lanes
        }) : null;
      },
      {
        key:  false && 0,
        debug: () => this.options.debug
      }
    );
    this.getVirtualIndexes = memo(
      () => {
        let startIndex = null;
        let endIndex = null;
        const range = this.calculateRange();
        if (range) {
          startIndex = range.startIndex;
          endIndex = range.endIndex;
        }
        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);
        return [
          this.options.rangeExtractor,
          this.options.overscan,
          this.options.count,
          startIndex,
          endIndex
        ];
      },
      (rangeExtractor, overscan, count, startIndex, endIndex) => {
        return startIndex === null || endIndex === null ? [] : rangeExtractor({
          startIndex,
          endIndex,
          overscan,
          count
        });
      },
      {
        key:  false && 0,
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node, entry) => {
      const index = this.indexFromElement(node);
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const key = item.key;
      const prevNode = this.elementsCache.get(key);
      if (prevNode !== node) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node);
        this.elementsCache.set(key, node);
      }
      if (node.isConnected) {
        this.resizeItem(index, this.options.measureElement(node, entry, this));
      }
    };
    this.resizeItem = (index, size) => {
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {
          if (false) {}
          this._scrollToOffset(this.getScrollOffset(), {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));
        this.notify(false);
      }
    };
    this.measureElement = (node) => {
      if (!node) {
        this.elementsCache.forEach((cached, key) => {
          if (!cached.isConnected) {
            this.observer.unobserve(cached);
            this.elementsCache.delete(key);
          }
        });
        return;
      }
      this._measureElement(node, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getVirtualIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k = 0, len = indexes.length; k < len; k++) {
          const i = indexes[k];
          const measurement = measurements[i];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key:  false && 0,
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset) => {
      const measurements = this.getMeasurements();
      if (measurements.length === 0) {
        return void 0;
      }
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index) => notUndefined(measurements[index]).start,
          offset
        )]
      );
    };
    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
      const size = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        align = toOffset >= scrollOffset + size ? "end" : "start";
      }
      if (align === "center") {
        toOffset += (itemSize - size) / 2;
      } else if (align === "end") {
        toOffset -= size;
      }
      const maxOffset = this.getTotalSize() + this.options.scrollMargin - size;
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index, align = "auto") => {
      index = Math.max(0, Math.min(index, this.options.count - 1));
      const item = this.measurementsCache[index];
      if (!item) {
        return void 0;
      }
      const size = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [scrollOffset, align];
        }
      }
      const toOffset = align === "end" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;
      return [
        this.getOffsetForAlignment(toOffset, align, item.size),
        align
      ];
    };
    this.isDynamicMode = () => this.elementsCache.size > 0;
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index, { align: initialAlign = "auto", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      index = Math.max(0, Math.min(index, this.options.count - 1));
      let attempts = 0;
      const maxAttempts = 10;
      const tryScroll = (currentAlign) => {
        if (!this.targetWindow) return;
        const offsetInfo = this.getOffsetForIndex(index, currentAlign);
        if (!offsetInfo) {
          console.warn("Failed to get offset for index:", index);
          return;
        }
        const [offset, align] = offsetInfo;
        this._scrollToOffset(offset, { adjustments: void 0, behavior });
        this.targetWindow.requestAnimationFrame(() => {
          const currentOffset = this.getScrollOffset();
          const afterInfo = this.getOffsetForIndex(index, align);
          if (!afterInfo) {
            console.warn("Failed to get offset for index:", index);
            return;
          }
          if (!approxEqual(afterInfo[0], currentOffset)) {
            scheduleRetry(align);
          }
        });
      };
      const scheduleRetry = (align) => {
        if (!this.targetWindow) return;
        attempts++;
        if (attempts < maxAttempts) {
          if (false) {}
          this.targetWindow.requestAnimationFrame(() => tryScroll(align));
        } else {
          console.warn(
            `Failed to scroll to index ${index} after ${maxAttempts} attempts.`
          );
        }
      };
      tryScroll(initialAlign);
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getScrollOffset() + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a;
      const measurements = this.getMeasurements();
      let end;
      if (measurements.length === 0) {
        end = this.options.paddingStart;
      } else if (this.options.lanes === 1) {
        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;
      } else {
        const endByLane = Array(this.options.lanes).fill(null);
        let endIndex = measurements.length - 1;
        while (endIndex >= 0 && endByLane.some((val) => val === null)) {
          const item = measurements[endIndex];
          if (endByLane[item.lane] === null) {
            endByLane[item.lane] = item.end;
          }
          endIndex--;
        }
        end = Math.max(...endByLane.filter((val) => val !== null));
      }
      return Math.max(
        end - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    };
    this._scrollToOffset = (offset, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset, { behavior, adjustments }, this);
    };
    this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map();
      this.notify(false);
    };
    this.setOptions(opts);
  }
}
const findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset,
  lanes
}) {
  const lastIndex = measurements.length - 1;
  const getOffset = (index) => measurements[index].start;
  if (measurements.length <= lanes) {
    return {
      startIndex: 0,
      endIndex: lastIndex
    };
  }
  let startIndex = findNearestBinarySearch(
    0,
    lastIndex,
    getOffset,
    scrollOffset
  );
  let endIndex = startIndex;
  if (lanes === 1) {
    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {
      endIndex++;
    }
  } else if (lanes > 1) {
    const endPerLane = Array(lanes).fill(0);
    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {
      const item = measurements[endIndex];
      endPerLane[item.lane] = item.end;
      endIndex++;
    }
    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);
    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {
      const item = measurements[startIndex];
      startPerLane[item.lane] = item.start;
      startIndex--;
    }
    startIndex = Math.max(0, startIndex - startIndex % lanes);
    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));
  }
  return { startIndex, endIndex };
}

//# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ../../node_modules/@tanstack/react-virtual/dist/esm/index.js




const useIsomorphicLayoutEffect = typeof document !== "undefined" ? react.useLayoutEffect : react.useEffect;
function useVirtualizerBase(options) {
  const rerender = react.useReducer(() => ({}), {})[1];
  const resolvedOptions = {
    ...options,
    onChange: (instance2, sync) => {
      var _a;
      if (sync) {
        (0,react_dom.flushSync)(rerender);
      } else {
        rerender();
      }
      (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);
    }
  };
  const [instance] = react.useState(
    () => new Virtualizer(resolvedOptions)
  );
  instance.setOptions(resolvedOptions);
  useIsomorphicLayoutEffect(() => {
    return instance._didMount();
  }, []);
  useIsomorphicLayoutEffect(() => {
    return instance._willUpdate();
  });
  return instance;
}
function useVirtualizer(options) {
  return useVirtualizerBase({
    observeElementRect: observeElementRect,
    observeElementOffset: observeElementOffset,
    scrollToFn: elementScroll,
    ...options
  });
}
function useWindowVirtualizer(options) {
  return useVirtualizerBase({
    getScrollElement: () => typeof document !== "undefined" ? window : null,
    observeElementRect: observeWindowRect,
    observeElementOffset: observeWindowOffset,
    scrollToFn: windowScroll,
    initialOffset: () => typeof document !== "undefined" ? window.scrollY : 0,
    ...options
  });
}

//# sourceMappingURL=index.js.map

// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-active-press.js
var use_active_press = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-active-press.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-by-comparator.js
var use_by_comparator = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-by-comparator.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-controllable.js
var use_controllable = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-controllable.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-default-value.js
var use_default_value = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-default-value.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
var use_disposables = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-disposables.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-element-size.js
var use_element_size = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-element-size.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-event.js
var use_event = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-event.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-inert-others.js
var use_inert_others = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-inert-others.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var use_iso_morphic_effect = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js
var use_latest_value = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-on-disappear.js
var use_on_disappear = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-on-disappear.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js + 1 modules
var use_outside_click = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-owner.js
var use_owner = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-owner.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-quick-release.js
var use_quick_release = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-quick-release.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/dom.js
var dom = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/dom.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-event-listener.js


function E(n, e, a, t) {
    let i = (0,use_latest_value/* useLatestValue */.E)(a);
    (0,react.useEffect)(()=>{
        n = n != null ? n : window;
        function r(o) {
            i.current(o);
        }
        return n.addEventListener(e, r, t), ()=>n.removeEventListener(e, r, t);
    }, [
        n,
        e,
        t
    ]);
}


;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-refocusable-input.js




function use_refocusable_input_f(e) {
    let l = (0,react.useRef)({
        value: "",
        selectionStart: null,
        selectionEnd: null
    });
    return E(e, "blur", (n)=>{
        let t = n.target;
        dom/* isHTMLInputElement */.LL(t) && (l.current = {
            value: t.value,
            selectionStart: t.selectionStart,
            selectionEnd: t.selectionEnd
        });
    }), (0,use_event/* useEvent */.z)(()=>{
        if (document.activeElement !== e && dom/* isHTMLInputElement */.LL(e) && e.isConnected) {
            if (e.focus({
                preventScroll: !0
            }), e.value !== l.current.value) e.setSelectionRange(e.value.length, e.value.length);
            else {
                let { selectionStart: n, selectionEnd: t } = l.current;
                n !== null && t !== null && e.setSelectionRange(n, t);
            }
            l.current = {
                value: "",
                selectionStart: null,
                selectionEnd: null
            };
        }
    });
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
var use_resolve_button_type = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-scroll-lock.js + 7 modules
var use_scroll_lock = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-scroll-lock.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-slot.js
var use_slot = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-slot.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var use_sync_refs = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js
var use_tracked_pointer = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-transition.js + 1 modules
var use_transition = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-transition.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js
var use_tree_walker = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-watch.js


function use_watch_m(u, t) {
    let e = (0,react.useRef)([]), r = (0,use_event/* useEvent */.z)(u);
    (0,react.useEffect)(()=>{
        let o = [
            ...e.current
        ];
        for (let [a, l] of t.entries())if (e.current[a] !== l) {
            let n = r(t, o);
            return e.current = t, n;
        }
    }, [
        r,
        ...t
    ]);
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/disabled.js
var disabled = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/disabled.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/floating.js
var floating = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/floating.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/form-fields.js
var form_fields = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/form-fields.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/frozen.js
var frozen = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/frozen.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/id.js
var id = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/id.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/internal/open-closed.js
var open_closed = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/internal/open-closed.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/machines/stack-machine.js
var stack_machine = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/machines/stack-machine.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/react-glue.js
var react_glue = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/react-glue.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/utils/document-ready.js
function t(n) {
    function e() {
        document.readyState !== "loading" && (n(), document.removeEventListener("DOMContentLoaded", e));
    }
    typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("DOMContentLoaded", e), e());
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/focus-management.js
var focus_management = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/focus-management.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/utils/active-element-history.js



let active_element_history_n = [];
t(()=>{
    function e(t) {
        if (!dom/* isHTMLorSVGElement */.sP(t.target) || t.target === document.body || active_element_history_n[0] === t.target) return;
        let r = t.target;
        r = r.closest(focus_management/* focusableSelector */.y), active_element_history_n.unshift(r != null ? r : t.target), active_element_history_n = active_element_history_n.filter((o)=>o != null && o.isConnected), active_element_history_n.splice(10);
    }
    window.addEventListener("click", e, {
        capture: !0
    }), window.addEventListener("mousedown", e, {
        capture: !0
    }), window.addEventListener("focus", e, {
        capture: !0
    }), document.body.addEventListener("click", e, {
        capture: !0
    }), document.body.addEventListener("mousedown", e, {
        capture: !0
    }), document.body.addEventListener("focus", e, {
        capture: !0
    });
});


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/bugs.js
var bugs = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/bugs.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js
var calculate_active_index = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/disposables.js
var disposables = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/disposables.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/match.js
var match = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/match.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/platform.js
var platform = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/platform.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/render.js + 1 modules
var render = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/render.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/description/description.js
var description = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/description/description.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/keyboard.js
var keyboard = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/keyboard.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/label/label.js
var label = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/label/label.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/mouse.js
var mouse = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/mouse.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/components/portal/portal.js + 1 modules
var portal = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/components/portal/portal.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/machine.js
var machine = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/machine.js");
// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/utils/element-movement.js
var element_movement = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/utils/element-movement.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/components/combobox/combobox-machine.js
var I = Object.defineProperty;
var h = (t, i, e)=>i in t ? I(t, i, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : t[i] = e;
var f = (t, i, e)=>(h(t, typeof i != "symbol" ? i + "" : i, e), e);






var combobox_machine_P = ((e)=>(e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(combobox_machine_P || {}), k = ((e)=>(e[e.Single = 0] = "Single", e[e.Multi = 1] = "Multi", e))(k || {}), combobox_machine_ = ((n)=>(n[n.Pointer = 0] = "Pointer", n[n.Focus = 1] = "Focus", n[n.Other = 2] = "Other", n))(combobox_machine_ || {}), D = ((l)=>(l[l.OpenCombobox = 0] = "OpenCombobox", l[l.CloseCombobox = 1] = "CloseCombobox", l[l.GoToOption = 2] = "GoToOption", l[l.SetTyping = 3] = "SetTyping", l[l.RegisterOption = 4] = "RegisterOption", l[l.UnregisterOption = 5] = "UnregisterOption", l[l.DefaultToFirstOption = 6] = "DefaultToFirstOption", l[l.SetActivationTrigger = 7] = "SetActivationTrigger", l[l.UpdateVirtualConfiguration = 8] = "UpdateVirtualConfiguration", l[l.SetInputElement = 9] = "SetInputElement", l[l.SetButtonElement = 10] = "SetButtonElement", l[l.SetOptionsElement = 11] = "SetOptionsElement", l[l.MarkInputAsMoved = 12] = "MarkInputAsMoved", l))(D || {});
function v(t) {
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (e)=>e;
    let e = t.activeOptionIndex !== null ? t.options[t.activeOptionIndex] : null, n = i(t.options.slice()), o = n.length > 0 && n[0].dataRef.current.order !== null ? n.sort((u, a)=>u.dataRef.current.order - a.dataRef.current.order) : (0,focus_management/* sortByDomNode */.z2)(n, (u)=>u.dataRef.current.domRef.current), r = e ? o.indexOf(e) : null;
    return r === -1 && (r = null), {
        options: o,
        activeOptionIndex: r
    };
}
let j = {
    [1] (t) {
        var e;
        if ((e = t.dataRef.current) != null && e.disabled || t.comboboxState === 1) return t;
        let i = t.inputElement ? element_movement/* ElementPositionState */.On.Tracked((0,element_movement/* computeVisualPosition */.kn)(t.inputElement)) : t.inputPositionState;
        return {
            ...t,
            activeOptionIndex: null,
            comboboxState: 1,
            isTyping: !1,
            activationTrigger: 2,
            inputPositionState: i,
            __demoMode: !1
        };
    },
    [0] (t) {
        var i, e;
        if ((i = t.dataRef.current) != null && i.disabled || t.comboboxState === 0) return t;
        if ((e = t.dataRef.current) != null && e.value) {
            let n = t.dataRef.current.calculateIndex(t.dataRef.current.value);
            if (n !== -1) return {
                ...t,
                activeOptionIndex: n,
                comboboxState: 0,
                __demoMode: !1,
                inputPositionState: element_movement/* ElementPositionState */.On.Idle
            };
        }
        return {
            ...t,
            comboboxState: 0,
            inputPositionState: element_movement/* ElementPositionState */.On.Idle,
            __demoMode: !1
        };
    },
    [3] (t, i) {
        return t.isTyping === i.isTyping ? t : {
            ...t,
            isTyping: i.isTyping
        };
    },
    [2] (t, i) {
        var r, u, a, s;
        if ((r = t.dataRef.current) != null && r.disabled || t.optionsElement && !((u = t.dataRef.current) != null && u.optionsPropsRef.current.static) && t.comboboxState === 1) return t;
        if (t.virtual) {
            let { options: p, disabled: c } = t.virtual, m = i.focus === calculate_active_index/* Focus */.T.Specific ? i.idx : (0,calculate_active_index/* calculateActiveIndex */.d)(i, {
                resolveItems: ()=>p,
                resolveActiveIndex: ()=>{
                    var l, x;
                    return (x = (l = t.activeOptionIndex) != null ? l : p.findIndex((S)=>!c(S))) != null ? x : null;
                },
                resolveDisabled: c,
                resolveId () {
                    throw new Error("Function not implemented.");
                }
            }), b = (a = i.trigger) != null ? a : 2;
            return t.activeOptionIndex === m && t.activationTrigger === b ? t : {
                ...t,
                activeOptionIndex: m,
                activationTrigger: b,
                isTyping: !1,
                __demoMode: !1
            };
        }
        let e = v(t);
        if (e.activeOptionIndex === null) {
            let p = e.options.findIndex((c)=>!c.dataRef.current.disabled);
            p !== -1 && (e.activeOptionIndex = p);
        }
        let n = i.focus === calculate_active_index/* Focus */.T.Specific ? i.idx : (0,calculate_active_index/* calculateActiveIndex */.d)(i, {
            resolveItems: ()=>e.options,
            resolveActiveIndex: ()=>e.activeOptionIndex,
            resolveId: (p)=>p.id,
            resolveDisabled: (p)=>p.dataRef.current.disabled
        }), o = (s = i.trigger) != null ? s : 2;
        return t.activeOptionIndex === n && t.activationTrigger === o ? t : {
            ...t,
            ...e,
            isTyping: !1,
            activeOptionIndex: n,
            activationTrigger: o,
            __demoMode: !1
        };
    },
    [4]: (t, i)=>{
        var r, u, a, s;
        if ((r = t.dataRef.current) != null && r.virtual) return {
            ...t,
            options: [
                ...t.options,
                i.payload
            ]
        };
        let e = i.payload, n = v(t, (p)=>(p.push(e), p));
        t.activeOptionIndex === null && (a = (u = t.dataRef.current).isSelected) != null && a.call(u, i.payload.dataRef.current.value) && (n.activeOptionIndex = n.options.indexOf(e));
        let o = {
            ...t,
            ...n,
            activationTrigger: 2
        };
        return (s = t.dataRef.current) != null && s.__demoMode && t.dataRef.current.value === void 0 && (o.activeOptionIndex = 0), o;
    },
    [5]: (t, i)=>{
        var n;
        if ((n = t.dataRef.current) != null && n.virtual) return {
            ...t,
            options: t.options.filter((o)=>o.id !== i.id)
        };
        let e = v(t, (o)=>{
            let r = o.findIndex((u)=>u.id === i.id);
            return r !== -1 && o.splice(r, 1), o;
        });
        return {
            ...t,
            ...e,
            activationTrigger: 2
        };
    },
    [6]: (t, i)=>t.defaultToFirstOption === i.value ? t : {
            ...t,
            defaultToFirstOption: i.value
        },
    [7]: (t, i)=>t.activationTrigger === i.trigger ? t : {
            ...t,
            activationTrigger: i.trigger
        },
    [8]: (t, i)=>{
        var n, o;
        if (t.virtual === null) return {
            ...t,
            virtual: {
                options: i.options,
                disabled: (n = i.disabled) != null ? n : ()=>!1
            }
        };
        if (t.virtual.options === i.options && t.virtual.disabled === i.disabled) return t;
        let e = t.activeOptionIndex;
        if (t.activeOptionIndex !== null) {
            let r = i.options.indexOf(t.virtual.options[t.activeOptionIndex]);
            r !== -1 ? e = r : e = null;
        }
        return {
            ...t,
            activeOptionIndex: e,
            virtual: {
                options: i.options,
                disabled: (o = i.disabled) != null ? o : ()=>!1
            }
        };
    },
    [9]: (t, i)=>t.inputElement === i.element ? t : {
            ...t,
            inputElement: i.element
        },
    [10]: (t, i)=>t.buttonElement === i.element ? t : {
            ...t,
            buttonElement: i.element
        },
    [11]: (t, i)=>t.optionsElement === i.element ? t : {
            ...t,
            optionsElement: i.element
        },
    [12] (t) {
        return t.inputPositionState.kind !== "Tracked" ? t : {
            ...t,
            inputPositionState: element_movement/* ElementPositionState */.On.Moved
        };
    }
};
class y extends machine/* Machine */.J {
    static new(param) {
        let { id: e, virtual: n = null, __demoMode: o = !1 } = param;
        var r;
        return new y({
            id: e,
            dataRef: {
                current: {}
            },
            comboboxState: o ? 0 : 1,
            isTyping: !1,
            options: [],
            virtual: n ? {
                options: n.options,
                disabled: (r = n.disabled) != null ? r : ()=>!1
            } : null,
            activeOptionIndex: null,
            activationTrigger: 2,
            inputElement: null,
            buttonElement: null,
            optionsElement: null,
            __demoMode: o,
            inputPositionState: element_movement/* ElementPositionState */.On.Idle
        });
    }
    reduce(e, n) {
        return (0,match/* match */.E)(n.type, j, e, n);
    }
    constructor(e){
        super(e);
        f(this, "actions", {
            onChange: (e)=>{
                let { onChange: n, compare: o, mode: r, value: u } = this.state.dataRef.current;
                return (0,match/* match */.E)(r, {
                    [0]: ()=>n == null ? void 0 : n(e),
                    [1]: ()=>{
                        let a = u.slice(), s = a.findIndex((p)=>o(p, e));
                        return s === -1 ? a.push(e) : a.splice(s, 1), n == null ? void 0 : n(a);
                    }
                });
            },
            registerOption: (e, n)=>(this.send({
                    type: 4,
                    payload: {
                        id: e,
                        dataRef: n
                    }
                }), ()=>{
                    this.state.activeOptionIndex === this.state.dataRef.current.calculateIndex(n.current.value) && this.send({
                        type: 6,
                        value: !0
                    }), this.send({
                        type: 5,
                        id: e
                    });
                }),
            goToOption: (e, n)=>(this.send({
                    type: 6,
                    value: !1
                }), this.send({
                    type: 2,
                    ...e,
                    trigger: n
                })),
            setIsTyping: (e)=>{
                this.send({
                    type: 3,
                    isTyping: e
                });
            },
            closeCombobox: ()=>{
                var e, n;
                this.send({
                    type: 1
                }), this.send({
                    type: 6,
                    value: !1
                }), (n = (e = this.state.dataRef.current).onClose) == null || n.call(e);
            },
            openCombobox: ()=>{
                this.send({
                    type: 0
                }), this.send({
                    type: 6,
                    value: !0
                });
            },
            setActivationTrigger: (e)=>{
                this.send({
                    type: 7,
                    trigger: e
                });
            },
            selectActiveOption: ()=>{
                let e = this.selectors.activeOptionIndex(this.state);
                if (e !== null) {
                    if (this.actions.setIsTyping(!1), this.state.virtual) this.actions.onChange(this.state.virtual.options[e]);
                    else {
                        let { dataRef: n } = this.state.options[e];
                        this.actions.onChange(n.current.value);
                    }
                    this.actions.goToOption({
                        focus: calculate_active_index/* Focus */.T.Specific,
                        idx: e
                    });
                }
            },
            setInputElement: (e)=>{
                this.send({
                    type: 9,
                    element: e
                });
            },
            setButtonElement: (e)=>{
                this.send({
                    type: 10,
                    element: e
                });
            },
            setOptionsElement: (e)=>{
                this.send({
                    type: 11,
                    element: e
                });
            }
        });
        f(this, "selectors", {
            activeDescendantId: (e)=>{
                var o, r;
                let n = this.selectors.activeOptionIndex(e);
                if (n !== null) return e.virtual ? (r = e.options.find((u)=>!u.dataRef.current.disabled && e.dataRef.current.compare(u.dataRef.current.value, e.virtual.options[n]))) == null ? void 0 : r.id : (o = e.options[n]) == null ? void 0 : o.id;
            },
            activeOptionIndex: (e)=>{
                if (e.defaultToFirstOption && e.activeOptionIndex === null && (e.virtual ? e.virtual.options.length > 0 : e.options.length > 0)) {
                    if (e.virtual) {
                        let { options: o, disabled: r } = e.virtual, u = o.findIndex((a)=>{
                            var s;
                            return !((s = r == null ? void 0 : r(a)) != null && s);
                        });
                        if (u !== -1) return u;
                    }
                    let n = e.options.findIndex((o)=>!o.dataRef.current.disabled);
                    if (n !== -1) return n;
                }
                return e.activeOptionIndex;
            },
            activeOption: (e)=>{
                var o, r;
                let n = this.selectors.activeOptionIndex(e);
                return n === null ? null : e.virtual ? e.virtual.options[n != null ? n : 0] : (r = (o = e.options[n]) == null ? void 0 : o.dataRef.current.value) != null ? r : null;
            },
            isActive: (e, n, o)=>{
                var u;
                let r = this.selectors.activeOptionIndex(e);
                return r === null ? !1 : e.virtual ? r === e.dataRef.current.calculateIndex(n) : ((u = e.options[r]) == null ? void 0 : u.id) === o;
            },
            shouldScrollIntoView: (e, n, o)=>!(e.virtual || e.__demoMode || e.comboboxState !== 0 || e.activationTrigger === 0 || !this.selectors.isActive(e, n, o)),
            didInputMove (e) {
                return e.inputPositionState.kind === "Moved";
            }
        });
        {
            let n = this.state.id, o = stack_machine/* stackMachines */.n.get(null);
            this.disposables.add(o.on(stack_machine/* ActionTypes */.M.Push, (r)=>{
                !o.selectors.isTop(r, n) && this.state.comboboxState === 0 && this.actions.closeCombobox();
            })), this.on(0, ()=>o.actions.push(n)), this.on(1, ()=>o.actions.pop(n));
        }
        this.disposables.group((n)=>{
            this.on(1, (o)=>{
                o.inputElement && (n.dispose(), n.add((0,element_movement/* detectMovement */.hS)(o.inputElement, o.inputPositionState, ()=>{
                    this.send({
                        type: 12
                    });
                })));
            });
        });
    }
}


// EXTERNAL MODULE: ../../node_modules/@headlessui/react/dist/hooks/use-on-unmount.js
var use_on_unmount = __webpack_require__("(app-pages-browser)/../../node_modules/@headlessui/react/dist/hooks/use-on-unmount.js");
;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/components/combobox/combobox-machine-glue.js



const u = /*#__PURE__*/ (0,react.createContext)(null);
function combobox_machine_glue_p(n) {
    let o = (0,react.useContext)(u);
    if (o === null) {
        let e = new Error("<".concat(n, " /> is missing a parent <Combobox /> component."));
        throw Error.captureStackTrace && Error.captureStackTrace(e, combobox_machine_glue_b), e;
    }
    return o;
}
function combobox_machine_glue_b(param) {
    let { id: n, virtual: o = null, __demoMode: e = !1 } = param;
    let t = (0,react.useMemo)(()=>y.new({
            id: n,
            virtual: o,
            __demoMode: e
        }), []);
    return (0,use_on_unmount/* useOnUnmount */.L)(()=>t.dispose()), t;
}


;// CONCATENATED MODULE: ../../node_modules/@headlessui/react/dist/components/combobox/combobox.js
/* __next_internal_client_entry_do_not_use__ Combobox,ComboboxButton,ComboboxInput,ComboboxLabel,ComboboxOption,ComboboxOptions auto */ 



















































let ce = /*#__PURE__*/ (0,react.createContext)(null);
ce.displayName = "ComboboxDataContext";
function re(x) {
    let P = (0,react.useContext)(ce);
    if (P === null) {
        let e = new Error("<".concat(x, " /> is missing a parent <Combobox /> component."));
        throw Error.captureStackTrace && Error.captureStackTrace(e, re), e;
    }
    return P;
}
let Ve = /*#__PURE__*/ (0,react.createContext)(null);
function Eo(x) {
    let P = combobox_machine_glue_p("VirtualProvider"), e = re("VirtualProvider"), { options: o } = e.virtual, h = (0,react_glue/* useSlice */.M)(P, (a)=>a.optionsElement), [R, y] = (0,react.useMemo)(()=>{
        let a = h;
        if (!a) return [
            0,
            0
        ];
        let i = window.getComputedStyle(a);
        return [
            parseFloat(i.paddingBlockStart || i.paddingTop),
            parseFloat(i.paddingBlockEnd || i.paddingBottom)
        ];
    }, [
        h
    ]), c = useVirtualizer({
        enabled: o.length !== 0,
        scrollPaddingStart: R,
        scrollPaddingEnd: y,
        count: o.length,
        estimateSize () {
            return 40;
        },
        getScrollElement () {
            return P.state.optionsElement;
        },
        overscan: 12
    }), [A, m] = (0,react.useState)(0);
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        m((a)=>a + 1);
    }, [
        o
    ]);
    let T = c.getVirtualItems(), n = (0,react_glue/* useSlice */.M)(P, (a)=>a.activationTrigger === combobox_machine_.Pointer), f = (0,react_glue/* useSlice */.M)(P, P.selectors.activeOptionIndex);
    return T.length === 0 ? null : /*#__PURE__*/ react.createElement(Ve.Provider, {
        value: c
    }, /*#__PURE__*/ react.createElement("div", {
        style: {
            position: "relative",
            width: "100%",
            height: "".concat(c.getTotalSize(), "px")
        },
        ref: (a)=>{
            a && (n || f !== null && o.length > f && c.scrollToIndex(f));
        }
    }, T.map((a)=>{
        var i;
        return /*#__PURE__*/ react.createElement(react.Fragment, {
            key: a.key
        }, /*#__PURE__*/ react.cloneElement((i = x.children) == null ? void 0 : i.call(x, {
            ...x.slot,
            option: o[a.index]
        }), {
            key: "".concat(A, "-").concat(a.key),
            "data-index": a.index,
            "aria-setsize": o.length,
            "aria-posinset": a.index + 1,
            style: {
                position: "absolute",
                top: 0,
                left: 0,
                transform: "translateY(".concat(a.start, "px)"),
                overflowAnchor: "none"
            }
        }));
    })));
}
let Oo = react.Fragment;
function ho(x, P) {
    let e = (0,react.useId)(), o = (0,disabled/* useDisabled */.B)(), { value: h, defaultValue: R, onChange: y, form: c, name: A, by: m, invalid: T = !1, disabled: n = o || !1, onClose: f, __demoMode: a = !1, multiple: i = !1, immediate: _ = !1, virtual: p = null, nullable: U, ...W } = x, C = (0,use_default_value/* useDefaultValue */.L)(R), [g = i ? [] : void 0, v] = (0,use_controllable/* useControllable */.q)(h, y, C), b = combobox_machine_glue_b({
        id: e,
        virtual: p,
        __demoMode: a
    }), H = (0,react.useRef)({
        static: !1,
        hold: !1
    }), F = (0,use_by_comparator/* useByComparator */.J)(m), G = (0,use_event/* useEvent */.z)((u)=>p ? m === null ? p.options.indexOf(u) : p.options.findIndex((d)=>F(d, u)) : b.state.options.findIndex((d)=>F(d.dataRef.current.value, u))), z = (0,react.useCallback)((u)=>(0,match/* match */.E)(r.mode, {
            [k.Multi]: ()=>g.some((d)=>F(d, u)),
            [k.Single]: ()=>F(g, u)
        }), [
        g
    ]), S = (0,react_glue/* useSlice */.M)(b, (u)=>u.virtual), q = (0,use_event/* useEvent */.z)(()=>f == null ? void 0 : f()), r = (0,react.useMemo)(()=>({
            __demoMode: a,
            immediate: _,
            optionsPropsRef: H,
            value: g,
            defaultValue: C,
            disabled: n,
            invalid: T,
            mode: i ? k.Multi : k.Single,
            virtual: p ? S : null,
            onChange: v,
            isSelected: z,
            calculateIndex: G,
            compare: F,
            onClose: q
        }), [
        a,
        _,
        H,
        g,
        C,
        n,
        T,
        i,
        p,
        S,
        v,
        z,
        G,
        F,
        q
    ]);
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        var u;
        p && b.send({
            type: D.UpdateVirtualConfiguration,
            options: p.options,
            disabled: (u = p.disabled) != null ? u : null
        });
    }, [
        p,
        p == null ? void 0 : p.options,
        p == null ? void 0 : p.disabled
    ]), (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        b.state.dataRef.current = r;
    }, [
        r
    ]);
    let [B, Y, s, K] = (0,react_glue/* useSlice */.M)(b, (u)=>[
            u.comboboxState,
            u.buttonElement,
            u.inputElement,
            u.optionsElement
        ]), X = stack_machine/* stackMachines */.n.get(null), Z = (0,react_glue/* useSlice */.M)(X, (0,react.useCallback)((u)=>X.selectors.isTop(u, e), [
        X,
        e
    ]));
    (0,use_outside_click/* useOutsideClick */.O)(Z, [
        Y,
        s,
        K
    ], ()=>b.actions.closeCombobox());
    let ae = (0,react_glue/* useSlice */.M)(b, b.selectors.activeOptionIndex), le = (0,react_glue/* useSlice */.M)(b, b.selectors.activeOption), te = (0,use_slot/* useSlot */.x)({
        open: B === combobox_machine_P.Open,
        disabled: n,
        invalid: T,
        activeIndex: ae,
        activeOption: le,
        value: g
    }), [$, ee] = (0,label/* useLabels */.bE)(), t = P === null ? {} : {
        ref: P
    }, N = (0,react.useCallback)(()=>{
        if (C !== void 0) return v == null ? void 0 : v(C);
    }, [
        v,
        C
    ]), E = (0,render/* useRender */.L6)();
    return /*#__PURE__*/ react.createElement(ee, {
        value: $,
        props: {
            htmlFor: s == null ? void 0 : s.id
        },
        slot: {
            open: B === combobox_machine_P.Open,
            disabled: n
        }
    }, /*#__PURE__*/ react.createElement(floating/* FloatingProvider */.HO, null, /*#__PURE__*/ react.createElement(ce.Provider, {
        value: r
    }, /*#__PURE__*/ react.createElement(u.Provider, {
        value: b
    }, /*#__PURE__*/ react.createElement(open_closed/* OpenClosedProvider */.up, {
        value: (0,match/* match */.E)(B, {
            [combobox_machine_P.Open]: open_closed/* State */.ZM.Open,
            [combobox_machine_P.Closed]: open_closed/* State */.ZM.Closed
        })
    }, A != null && /*#__PURE__*/ react.createElement(form_fields/* FormFields */.Mt, {
        disabled: n,
        data: g != null ? {
            [A]: g
        } : {},
        form: c,
        onReset: N
    }), E({
        ourProps: t,
        theirProps: W,
        slot: te,
        defaultTag: Oo,
        name: "Combobox"
    }))))));
}
let Ao = "input";
function Io(x, P) {
    var $, ee;
    let e = combobox_machine_glue_p("Combobox.Input"), o = re("Combobox.Input"), h = (0,react.useId)(), R = (0,id/* useProvidedId */.Q)(), { id: y = R || "headlessui-combobox-input-".concat(h), onChange: c, displayValue: A, disabled: m = o.disabled || !1, autoFocus: T = !1, type: n = "text", ...f } = x, [a] = (0,react_glue/* useSlice */.M)(e, (t)=>[
            t.inputElement
        ]), i = (0,react.useRef)(null), _ = (0,use_sync_refs/* useSyncRefs */.T)(i, P, (0,floating/* useFloatingReference */.AZ)(), e.actions.setInputElement), p = (0,use_owner/* useOwnerDocument */.i)(a), [U, W] = (0,react_glue/* useSlice */.M)(e, (t)=>[
            t.comboboxState,
            t.isTyping
        ]), C = (0,use_disposables/* useDisposables */.G)(), g = (0,use_event/* useEvent */.z)(()=>{
        e.actions.onChange(null), e.state.optionsElement && (e.state.optionsElement.scrollTop = 0), e.actions.goToOption({
            focus: calculate_active_index/* Focus */.T.Nothing
        });
    }), v = (0,react.useMemo)(()=>{
        var t;
        return typeof A == "function" && o.value !== void 0 ? (t = A(o.value)) != null ? t : "" : typeof o.value == "string" ? o.value : "";
    }, [
        o.value,
        A
    ]);
    use_watch_m((param, param1)=>{
        let [t, N] = param, [E, u] = param1;
        if (e.state.isTyping) return;
        let d = i.current;
        d && ((u === combobox_machine_P.Open && N === combobox_machine_P.Closed || t !== E) && (d.value = t), requestAnimationFrame(()=>{
            if (e.state.isTyping || !d || (p == null ? void 0 : p.activeElement) !== d) return;
            let { selectionStart: L, selectionEnd: J } = d;
            Math.abs((J != null ? J : 0) - (L != null ? L : 0)) === 0 && L === 0 && d.setSelectionRange(d.value.length, d.value.length);
        }));
    }, [
        v,
        U,
        p,
        W
    ]), use_watch_m((param, param1)=>{
        let [t] = param, [N] = param1;
        if (t === combobox_machine_P.Open && N === combobox_machine_P.Closed) {
            if (e.state.isTyping) return;
            let E = i.current;
            if (!E) return;
            let u = E.value, { selectionStart: d, selectionEnd: L, selectionDirection: J } = E;
            E.value = "", E.value = u, J !== null ? E.setSelectionRange(d, L, J) : E.setSelectionRange(d, L);
        }
    }, [
        U
    ]);
    let b = (0,react.useRef)(!1), H = (0,use_event/* useEvent */.z)(()=>{
        b.current = !0;
    }), F = (0,use_event/* useEvent */.z)(()=>{
        C.nextFrame(()=>{
            b.current = !1;
        });
    }), G = (0,use_event/* useEvent */.z)((t)=>{
        switch(e.actions.setIsTyping(!0), t.key){
            case keyboard/* Keys */.R.Enter:
                if (e.state.comboboxState !== combobox_machine_P.Open || b.current) return;
                if (t.preventDefault(), t.stopPropagation(), e.selectors.activeOptionIndex(e.state) === null) {
                    e.actions.closeCombobox();
                    return;
                }
                e.actions.selectActiveOption(), o.mode === k.Single && e.actions.closeCombobox();
                break;
            case keyboard/* Keys */.R.ArrowDown:
                return t.preventDefault(), t.stopPropagation(), (0,match/* match */.E)(e.state.comboboxState, {
                    [combobox_machine_P.Open]: ()=>e.actions.goToOption({
                            focus: calculate_active_index/* Focus */.T.Next
                        }),
                    [combobox_machine_P.Closed]: ()=>e.actions.openCombobox()
                });
            case keyboard/* Keys */.R.ArrowUp:
                return t.preventDefault(), t.stopPropagation(), (0,match/* match */.E)(e.state.comboboxState, {
                    [combobox_machine_P.Open]: ()=>e.actions.goToOption({
                            focus: calculate_active_index/* Focus */.T.Previous
                        }),
                    [combobox_machine_P.Closed]: ()=>{
                        (0,react_dom.flushSync)(()=>e.actions.openCombobox()), o.value || e.actions.goToOption({
                            focus: calculate_active_index/* Focus */.T.Last
                        });
                    }
                });
            case keyboard/* Keys */.R.Home:
                if (t.shiftKey) break;
                return t.preventDefault(), t.stopPropagation(), e.actions.goToOption({
                    focus: calculate_active_index/* Focus */.T.First
                });
            case keyboard/* Keys */.R.PageUp:
                return t.preventDefault(), t.stopPropagation(), e.actions.goToOption({
                    focus: calculate_active_index/* Focus */.T.First
                });
            case keyboard/* Keys */.R.End:
                if (t.shiftKey) break;
                return t.preventDefault(), t.stopPropagation(), e.actions.goToOption({
                    focus: calculate_active_index/* Focus */.T.Last
                });
            case keyboard/* Keys */.R.PageDown:
                return t.preventDefault(), t.stopPropagation(), e.actions.goToOption({
                    focus: calculate_active_index/* Focus */.T.Last
                });
            case keyboard/* Keys */.R.Escape:
                return e.state.comboboxState !== combobox_machine_P.Open ? void 0 : (t.preventDefault(), e.state.optionsElement && !o.optionsPropsRef.current.static && t.stopPropagation(), o.mode === k.Single && o.value === null && g(), e.actions.closeCombobox());
            case keyboard/* Keys */.R.Tab:
                if (e.actions.setIsTyping(!1), e.state.comboboxState !== combobox_machine_P.Open) return;
                o.mode === k.Single && e.state.activationTrigger !== combobox_machine_.Focus && e.actions.selectActiveOption(), e.actions.closeCombobox();
                break;
        }
    }), z = (0,use_event/* useEvent */.z)((t)=>{
        c == null || c(t), o.mode === k.Single && t.target.value === "" && g(), e.actions.openCombobox();
    }), S = (0,use_event/* useEvent */.z)((t)=>{
        var E, u, d;
        let N = (E = t.relatedTarget) != null ? E : active_element_history_n.find((L)=>L !== t.currentTarget);
        if (!((u = e.state.optionsElement) != null && u.contains(N)) && !((d = e.state.buttonElement) != null && d.contains(N)) && e.state.comboboxState === combobox_machine_P.Open) return t.preventDefault(), o.mode === k.Single && o.value === null && g(), e.actions.closeCombobox();
    }), q = (0,use_event/* useEvent */.z)((t)=>{
        var E, u, d;
        let N = (E = t.relatedTarget) != null ? E : active_element_history_n.find((L)=>L !== t.currentTarget);
        (u = e.state.buttonElement) != null && u.contains(N) || (d = e.state.optionsElement) != null && d.contains(N) || o.disabled || o.immediate && e.state.comboboxState !== combobox_machine_P.Open && C.microTask(()=>{
            (0,react_dom.flushSync)(()=>e.actions.openCombobox()), e.actions.setActivationTrigger(combobox_machine_.Focus);
        });
    }), r = (0,label/* useLabelledBy */.wp)(), B = (0,description/* useDescribedBy */.zH)(), { isFocused: Y, focusProps: s } = (0,useFocusRing/* useFocusRing */.F)({
        autoFocus: T
    }), { isHovered: K, hoverProps: X } = (0,useHover/* useHover */.X)({
        isDisabled: m
    }), Z = (0,react_glue/* useSlice */.M)(e, (t)=>t.optionsElement), ae = (0,use_slot/* useSlot */.x)({
        open: U === combobox_machine_P.Open,
        disabled: m,
        invalid: o.invalid,
        hover: K,
        focus: Y,
        autofocus: T
    }), le = (0,render/* mergeProps */.dG)({
        ref: _,
        id: y,
        role: "combobox",
        type: n,
        "aria-controls": Z == null ? void 0 : Z.id,
        "aria-expanded": U === combobox_machine_P.Open,
        "aria-activedescendant": (0,react_glue/* useSlice */.M)(e, e.selectors.activeDescendantId),
        "aria-labelledby": r,
        "aria-describedby": B,
        "aria-autocomplete": "list",
        defaultValue: (ee = ($ = x.defaultValue) != null ? $ : o.defaultValue !== void 0 ? A == null ? void 0 : A(o.defaultValue) : null) != null ? ee : o.defaultValue,
        disabled: m || void 0,
        autoFocus: T,
        onCompositionStart: H,
        onCompositionEnd: F,
        onKeyDown: G,
        onChange: z,
        onFocus: q,
        onBlur: S
    }, s, X);
    return (0,render/* useRender */.L6)()({
        ourProps: le,
        theirProps: f,
        slot: ae,
        defaultTag: Ao,
        name: "Combobox.Input"
    });
}
let Ro = "button";
function Do(x, P) {
    let e = combobox_machine_glue_p("Combobox.Button"), o = re("Combobox.Button"), [h, R] = (0,react.useState)(null), y = (0,use_sync_refs/* useSyncRefs */.T)(P, R, e.actions.setButtonElement), c = (0,react.useId)(), { id: A = "headlessui-combobox-button-".concat(c), disabled: m = o.disabled || !1, autoFocus: T = !1, ...n } = x, [f, a, i] = (0,react_glue/* useSlice */.M)(e, (r)=>[
            r.comboboxState,
            r.inputElement,
            r.optionsElement
        ]), _ = use_refocusable_input_f(a), p = f === combobox_machine_P.Open;
    (0,use_quick_release/* useQuickRelease */.G)(p, {
        trigger: h,
        action: (0,react.useCallback)((r)=>{
            if (h != null && h.contains(r.target)) return use_quick_release/* Action */.a.Ignore;
            if (a != null && a.contains(r.target)) return use_quick_release/* Action */.a.Ignore;
            let B = r.target.closest('[role="option"]:not([data-disabled])');
            return dom/* isHTMLElement */.Re(B) ? use_quick_release/* Action */.a.Select(B) : i != null && i.contains(r.target) ? use_quick_release/* Action */.a.Ignore : use_quick_release/* Action */.a.Close;
        }, [
            h,
            a,
            i
        ]),
        close: e.actions.closeCombobox,
        select: e.actions.selectActiveOption
    });
    let U = (0,use_event/* useEvent */.z)((r)=>{
        switch(r.key){
            case keyboard/* Keys */.R.Space:
            case keyboard/* Keys */.R.Enter:
                r.preventDefault(), r.stopPropagation(), e.state.comboboxState === combobox_machine_P.Closed && (0,react_dom.flushSync)(()=>e.actions.openCombobox()), _();
                return;
            case keyboard/* Keys */.R.ArrowDown:
                r.preventDefault(), r.stopPropagation(), e.state.comboboxState === combobox_machine_P.Closed && ((0,react_dom.flushSync)(()=>e.actions.openCombobox()), e.state.dataRef.current.value || e.actions.goToOption({
                    focus: calculate_active_index/* Focus */.T.First
                })), _();
                return;
            case keyboard/* Keys */.R.ArrowUp:
                r.preventDefault(), r.stopPropagation(), e.state.comboboxState === combobox_machine_P.Closed && ((0,react_dom.flushSync)(()=>e.actions.openCombobox()), e.state.dataRef.current.value || e.actions.goToOption({
                    focus: calculate_active_index/* Focus */.T.Last
                })), _();
                return;
            case keyboard/* Keys */.R.Escape:
                if (e.state.comboboxState !== combobox_machine_P.Open) return;
                r.preventDefault(), e.state.optionsElement && !o.optionsPropsRef.current.static && r.stopPropagation(), (0,react_dom.flushSync)(()=>e.actions.closeCombobox()), _();
                return;
            default:
                return;
        }
    }), W = (0,use_event/* useEvent */.z)((r)=>{
        r.preventDefault(), !(0,bugs/* isDisabledReactIssue7711 */.P)(r.currentTarget) && (r.button === mouse/* MouseButton */.t.Left && (e.state.comboboxState === combobox_machine_P.Open ? e.actions.closeCombobox() : e.actions.openCombobox()), _());
    }), C = (0,label/* useLabelledBy */.wp)([
        A
    ]), { isFocusVisible: g, focusProps: v } = (0,useFocusRing/* useFocusRing */.F)({
        autoFocus: T
    }), { isHovered: b, hoverProps: H } = (0,useHover/* useHover */.X)({
        isDisabled: m
    }), { pressed: F, pressProps: G } = (0,use_active_press/* useActivePress */.x)({
        disabled: m
    }), z = (0,use_slot/* useSlot */.x)({
        open: f === combobox_machine_P.Open,
        active: F || f === combobox_machine_P.Open,
        disabled: m,
        invalid: o.invalid,
        value: o.value,
        hover: b,
        focus: g
    }), S = (0,render/* mergeProps */.dG)({
        ref: y,
        id: A,
        type: (0,use_resolve_button_type/* useResolveButtonType */.f)(x, h),
        tabIndex: -1,
        "aria-haspopup": "listbox",
        "aria-controls": i == null ? void 0 : i.id,
        "aria-expanded": f === combobox_machine_P.Open,
        "aria-labelledby": C,
        disabled: m || void 0,
        autoFocus: T,
        onPointerDown: W,
        onKeyDown: U
    }, v, H, G);
    return (0,render/* useRender */.L6)()({
        ourProps: S,
        theirProps: n,
        slot: z,
        defaultTag: Ro,
        name: "Combobox.Button"
    });
}
let _o = "div", Fo = render/* RenderFeatures */.VN.RenderStrategy | render/* RenderFeatures */.VN.Static;
function So(x, P) {
    var d, L, J;
    let e = (0,react.useId)(), { id: o = "headlessui-combobox-options-".concat(e), hold: h = !1, anchor: R, portal: y = !1, modal: c = !0, transition: A = !1, ...m } = x, T = combobox_machine_glue_p("Combobox.Options"), n = re("Combobox.Options"), f = (0,floating/* useResolvedAnchor */.Vy)(R);
    f && (y = !0);
    let [a, i] = (0,floating/* useFloatingPanel */.ES)(f), [_, p] = (0,react.useState)(null), U = (0,floating/* useFloatingPanelProps */.U8)(), W = (0,use_sync_refs/* useSyncRefs */.T)(P, f ? a : null, T.actions.setOptionsElement, p), [C, g, v, b, H] = (0,react_glue/* useSlice */.M)(T, (D)=>[
            D.comboboxState,
            D.inputElement,
            D.buttonElement,
            D.optionsElement,
            D.activationTrigger
        ]), F = (0,use_owner/* useOwnerDocument */.i)(g || v), G = (0,use_owner/* useOwnerDocument */.i)(b), z = (0,open_closed/* useOpenClosed */.oJ)(), [S, q] = (0,use_transition/* useTransition */.Y)(A, _, z !== null ? (z & open_closed/* State */.ZM.Open) === open_closed/* State */.ZM.Open : C === combobox_machine_P.Open);
    (0,use_on_disappear/* useOnDisappear */.m)(S, g, T.actions.closeCombobox);
    let r = n.__demoMode ? !1 : c && C === combobox_machine_P.Open;
    (0,use_scroll_lock/* useScrollLock */.P)(r, G);
    let B = n.__demoMode ? !1 : c && C === combobox_machine_P.Open;
    (0,use_inert_others/* useInertOthers */.s)(B, {
        allowed: (0,react.useCallback)(()=>[
                g,
                v,
                b
            ], [
            g,
            v,
            b
        ])
    });
    let s = (0,react_glue/* useSlice */.M)(T, T.selectors.didInputMove) ? !1 : S;
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        var D;
        n.optionsPropsRef.current.static = (D = x.static) != null ? D : !1;
    }, [
        n.optionsPropsRef,
        x.static
    ]), (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        n.optionsPropsRef.current.hold = h;
    }, [
        n.optionsPropsRef,
        h
    ]), (0,use_tree_walker/* useTreeWalker */.B)(C === combobox_machine_P.Open, {
        container: b,
        accept (D) {
            return D.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : D.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
        },
        walk (D) {
            D.setAttribute("role", "none");
        }
    });
    let K = (0,label/* useLabelledBy */.wp)([
        v == null ? void 0 : v.id
    ]), X = (0,use_slot/* useSlot */.x)({
        open: C === combobox_machine_P.Open,
        option: void 0
    }), Z = (0,use_event/* useEvent */.z)(()=>{
        T.actions.setActivationTrigger(combobox_machine_.Pointer);
    }), ae = (0,use_event/* useEvent */.z)((D)=>{
        D.preventDefault(), T.actions.setActivationTrigger(combobox_machine_.Pointer);
    }), le = (0,render/* mergeProps */.dG)(f ? U() : {}, {
        "aria-labelledby": K,
        role: "listbox",
        "aria-multiselectable": n.mode === k.Multi ? !0 : void 0,
        id: o,
        ref: W,
        style: {
            ...m.style,
            ...i,
            "--input-width": (0,use_element_size/* useElementSize */.h)(S, g, !0).width,
            "--button-width": (0,use_element_size/* useElementSize */.h)(S, v, !0).width
        },
        onWheel: H === combobox_machine_.Pointer ? void 0 : Z,
        onMouseDown: ae,
        ...(0,use_transition/* transitionDataAttributes */.X)(q)
    }), te = S && C === combobox_machine_P.Closed && !x.static, $ = (0,frozen/* useFrozenData */._)(te, (d = n.virtual) == null ? void 0 : d.options), ee = (0,frozen/* useFrozenData */._)(te, n.value), t = (0,react.useCallback)((D)=>n.compare(ee, D), [
        n.compare,
        ee
    ]), N = (0,react.useMemo)(()=>{
        if (!n.virtual) return n;
        if ($ === void 0) throw new Error("Missing `options` in virtual mode");
        return $ !== n.virtual.options ? {
            ...n,
            virtual: {
                ...n.virtual,
                options: $
            }
        } : n;
    }, [
        n,
        $,
        (L = n.virtual) == null ? void 0 : L.options
    ]);
    n.virtual && Object.assign(m, {
        children: /*#__PURE__*/ react.createElement(ce.Provider, {
            value: N
        }, /*#__PURE__*/ react.createElement(Eo, {
            slot: X
        }, m.children))
    });
    let E = (0,render/* useRender */.L6)(), u = (0,react.useMemo)(()=>n.mode === k.Multi ? n : {
            ...n,
            isSelected: t
        }, [
        n,
        t
    ]);
    return /*#__PURE__*/ react.createElement(portal/* Portal */.h_, {
        enabled: y ? x.static || S : !1,
        ownerDocument: F
    }, /*#__PURE__*/ react.createElement(ce.Provider, {
        value: u
    }, E({
        ourProps: le,
        theirProps: {
            ...m,
            children: /*#__PURE__*/ react.createElement(frozen/* Frozen */.F, {
                freeze: te
            }, typeof m.children == "function" ? (J = m.children) == null ? void 0 : J.call(m, X) : m.children)
        },
        slot: X,
        defaultTag: _o,
        features: Fo,
        visible: s,
        name: "Combobox.Options"
    })));
}
let Mo = "div";
function Lo(x, P) {
    var r, B, Y;
    let e = re("Combobox.Option"), o = combobox_machine_glue_p("Combobox.Option"), h = (0,react.useId)(), { id: R = "headlessui-combobox-option-".concat(h), value: y, disabled: c = (Y = (B = (r = e.virtual) == null ? void 0 : r.disabled) == null ? void 0 : B.call(r, y)) != null ? Y : !1, order: A = null, ...m } = x, [T] = (0,react_glue/* useSlice */.M)(o, (s)=>[
            s.inputElement
        ]), n = use_refocusable_input_f(T), f = (0,react_glue/* useSlice */.M)(o, (0,react.useCallback)((s)=>o.selectors.isActive(s, y, R), [
        y,
        R
    ])), a = e.isSelected(y), i = (0,react.useRef)(null), _ = (0,use_latest_value/* useLatestValue */.E)({
        disabled: c,
        value: y,
        domRef: i,
        order: A
    }), p = (0,react.useContext)(Ve), U = (0,use_sync_refs/* useSyncRefs */.T)(P, i, p ? p.measureElement : null), W = (0,use_event/* useEvent */.z)(()=>{
        o.actions.setIsTyping(!1), o.actions.onChange(y);
    });
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>o.actions.registerOption(R, _), [
        _,
        R
    ]);
    let C = (0,react_glue/* useSlice */.M)(o, (0,react.useCallback)((s)=>o.selectors.shouldScrollIntoView(s, y, R), [
        y,
        R
    ]));
    (0,use_iso_morphic_effect/* useIsoMorphicEffect */.e)(()=>{
        if (C) return (0,disposables/* disposables */.k)().requestAnimationFrame(()=>{
            var s, K;
            (K = (s = i.current) == null ? void 0 : s.scrollIntoView) == null || K.call(s, {
                block: "nearest"
            });
        });
    }, [
        C,
        i
    ]);
    let g = (0,use_event/* useEvent */.z)((s)=>{
        s.preventDefault(), s.button === mouse/* MouseButton */.t.Left && (c || (W(), (0,platform/* isMobile */.tq)() || requestAnimationFrame(()=>n()), e.mode === k.Single && o.actions.closeCombobox()));
    }), v = (0,use_event/* useEvent */.z)(()=>{
        if (c) return o.actions.goToOption({
            focus: calculate_active_index/* Focus */.T.Nothing
        });
        let s = e.calculateIndex(y);
        o.actions.goToOption({
            focus: calculate_active_index/* Focus */.T.Specific,
            idx: s
        });
    }), b = (0,use_tracked_pointer/* useTrackedPointer */.g)(), H = (0,use_event/* useEvent */.z)((s)=>b.update(s)), F = (0,use_event/* useEvent */.z)((s)=>{
        if (!b.wasMoved(s) || c || f && o.state.activationTrigger === combobox_machine_.Pointer) return;
        let K = e.calculateIndex(y);
        o.actions.goToOption({
            focus: calculate_active_index/* Focus */.T.Specific,
            idx: K
        }, combobox_machine_.Pointer);
    }), G = (0,use_event/* useEvent */.z)((s)=>{
        b.wasMoved(s) && (c || f && (e.optionsPropsRef.current.hold || o.state.activationTrigger === combobox_machine_.Pointer && o.actions.goToOption({
            focus: calculate_active_index/* Focus */.T.Nothing
        })));
    }), z = (0,use_slot/* useSlot */.x)({
        active: f,
        focus: f,
        selected: a,
        disabled: c
    }), S = {
        id: R,
        ref: U,
        role: "option",
        tabIndex: c === !0 ? void 0 : -1,
        "aria-disabled": c === !0 ? !0 : void 0,
        "aria-selected": a,
        disabled: void 0,
        onMouseDown: g,
        onFocus: v,
        onPointerEnter: H,
        onMouseEnter: H,
        onPointerMove: F,
        onMouseMove: F,
        onPointerLeave: G,
        onMouseLeave: G
    };
    return (0,render/* useRender */.L6)()({
        ourProps: S,
        theirProps: m,
        slot: z,
        defaultTag: Mo,
        name: "Combobox.Option"
    });
}
let Vo = (0,render/* forwardRefWithAs */.yV)(ho), wo = (0,render/* forwardRefWithAs */.yV)(Do), Bo = (0,render/* forwardRefWithAs */.yV)(Io), No = label/* Label */.__, ko = (0,render/* forwardRefWithAs */.yV)(So), Uo = (0,render/* forwardRefWithAs */.yV)(Lo), kt = Object.assign(Vo, {
    Input: Bo,
    Button: wo,
    Label: No,
    Options: ko,
    Option: Uo
});


// EXTERNAL MODULE: ../../node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__("(app-pages-browser)/../../node_modules/clsx/dist/clsx.mjs");
// EXTERNAL MODULE: ./node_modules/next/dist/client/add-base-path.js
var add_base_path = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js");
// EXTERNAL MODULE: ./node_modules/next/dist/api/link.js
var api_link = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/api/link.js");
// EXTERNAL MODULE: ./node_modules/next/dist/api/navigation.js
var navigation = __webpack_require__("(app-pages-browser)/./node_modules/next/dist/api/navigation.js");
// EXTERNAL MODULE: ../../node_modules/nextra/dist/client/hooks/use-mounted.js
var use_mounted = __webpack_require__("(app-pages-browser)/../../node_modules/nextra/dist/client/hooks/use-mounted.js");
;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/icons/github-note.js


const SvgGithubNote = (props) => {
  const $ = (0,dist.c)(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z" });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 16 16", fill: "currentColor", ...props, children: t0 });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
};


;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/icons/spinner.js


const SvgSpinner = (props) => {
  const $ = (0,dist.c)(4);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ (0,jsx_runtime.jsx)("circle", { className: "x:opacity-25", cx: 12, cy: 12, r: 10, strokeWidth: 4 });
    t1 = /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { className: "x:opacity-75", fill: "currentColor", stroke: "none", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" });
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  let t2;
  if ($[2] !== props) {
    t2 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", ...props, children: [
      t0,
      t1
    ] });
    $[2] = props;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
};


;// CONCATENATED MODULE: ../../node_modules/nextra/dist/client/components/search.js
/* __next_internal_client_entry_do_not_use__ Search,importPagefind auto */ 









async function importPagefind() {
    window.pagefind = await import(/* webpackIgnore: true */ (0,add_base_path.addBasePath)("/_pagefind/pagefind.js"));
    await window.pagefind.options({
        baseUrl: "/"
    });
}
const INPUTS = /* @__PURE__ */ new Set([
    "INPUT",
    "SELECT",
    "BUTTON",
    "TEXTAREA"
]);
const DEV_SEARCH_NOTICE = /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
    children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("p", {
            children: "Search isn't available in development because Nextra\xa04 uses Pagefind package, which indexes built `.html` files instead of `.md`/`.mdx`."
        }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("p", {
            className: "x:mt-2",
            children: "To test search during development, run `next build` and then restart your app with `next dev`."
        })
    ]
});
const Search = (t0)=>{
    const $ = (0,dist.c)(60);
    let className;
    let onSearch;
    let props;
    let searchOptions;
    let t1;
    let t2;
    let t3;
    let t4;
    if ($[0] !== t0) {
        ({ className, emptyResult: t1, errorText: t2, loading: t3, placeholder: t4, searchOptions, onSearch, ...props } = t0);
        $[0] = t0;
        $[1] = className;
        $[2] = onSearch;
        $[3] = props;
        $[4] = searchOptions;
        $[5] = t1;
        $[6] = t2;
        $[7] = t3;
        $[8] = t4;
    } else {
        className = $[1];
        onSearch = $[2];
        props = $[3];
        searchOptions = $[4];
        t1 = $[5];
        t2 = $[6];
        t3 = $[7];
        t4 = $[8];
    }
    const emptyResult = t1 === void 0 ? "No results found." : t1;
    const errorText = t2 === void 0 ? "Failed to load search index." : t2;
    const loading = t3 === void 0 ? "Loading…" : t3;
    const placeholder = t4 === void 0 ? "Search documentation…" : t4;
    const [isLoading, setIsLoading] = (0,react.useState)(true);
    const [error, setError] = (0,react.useState)("");
    let t5;
    if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
        t5 = [];
        $[9] = t5;
    } else {
        t5 = $[9];
    }
    const [results, setResults] = (0,react.useState)(t5);
    const [search, setSearch] = (0,react.useState)("");
    const deferredSearch = (0,react.useDeferredValue)(search);
    let t6;
    if ($[10] !== deferredSearch || $[11] !== searchOptions) {
        t6 = ()=>{
            const handleSearch = async (value)=>{
                if (!value) {
                    setResults([]);
                    setError("");
                    return;
                }
                setIsLoading(true);
                if (!window.pagefind) {
                    ;
                    try {
                        await importPagefind();
                    } catch (t72) {
                        const error_0 = t72;
                        const message = error_0 instanceof Error ?  false ? 0 : "".concat(error_0.constructor.name, ": ").concat(error_0.message) : String(error_0);
                        setError(message);
                        setIsLoading(false);
                        return;
                    }
                }
                const response = await window.pagefind.debouncedSearch(value, searchOptions);
                if (!response) {
                    return;
                }
                const data = await Promise.all(response.results.map(_temp));
                setIsLoading(false);
                setError("");
                setResults(data.map(_temp3));
            };
            handleSearch(deferredSearch);
        };
        $[10] = deferredSearch;
        $[11] = searchOptions;
        $[12] = t6;
    } else {
        t6 = $[12];
    }
    let t7;
    if ($[13] !== deferredSearch) {
        t7 = [
            deferredSearch
        ];
        $[13] = deferredSearch;
        $[14] = t7;
    } else {
        t7 = $[14];
    }
    (0,react.useEffect)(t6, t7);
    const router = (0,navigation.useRouter)();
    const [focused, setFocused] = (0,react.useState)(false);
    const mounted = (0,use_mounted.useMounted)();
    const inputRef = (0,react.useRef)(null);
    let t8;
    let t9;
    if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
        t8 = ()=>{
            const handleKeyDown = function handleKeyDown2(event) {
                const el = document.activeElement;
                if (!el || INPUTS.has(el.tagName) || el.isContentEditable) {
                    return;
                }
                if (event.key === "/" || event.key === "k" && !event.shiftKey && (navigator.userAgent.includes("Mac") ? event.metaKey : event.ctrlKey)) {
                    event.preventDefault();
                    inputRef.current.focus({
                        preventScroll: true
                    });
                }
            };
            window.addEventListener("keydown", handleKeyDown);
            return ()=>{
                window.removeEventListener("keydown", handleKeyDown);
            };
        };
        t9 = [];
        $[15] = t8;
        $[16] = t9;
    } else {
        t8 = $[15];
        t9 = $[16];
    }
    (0,react.useEffect)(t8, t9);
    const t10 = (!mounted || focused) && "x:invisible x:opacity-0";
    let t11;
    if ($[17] !== t10) {
        t11 = (0,clsx/* default */.Z)("x:absolute x:my-1.5 x:select-none x:pointer-events-none x:end-1.5 x:transition-all", "x:h-5 x:rounded x:bg-nextra-bg x:px-1.5 x:font-mono x:text-[11px] x:font-medium x:text-gray-600 x:dark:text-gray-400", "x:border nextra-border", "x:contrast-more:text-current", "x:items-center x:gap-1 x:flex", "x:max-sm:hidden not-prose", t10);
        $[17] = t10;
        $[18] = t11;
    } else {
        t11 = $[18];
    }
    let t12;
    if ($[19] !== mounted) {
        t12 = mounted && navigator.userAgent.includes("Mac") ? /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)("span", {
                    className: "x:text-xs",
                    children: "⌘"
                }),
                "K"
            ]
        }) : "CTRL K";
        $[19] = mounted;
        $[20] = t12;
    } else {
        t12 = $[20];
    }
    let t13;
    if ($[21] !== t11 || $[22] !== t12) {
        t13 = /* @__PURE__ */ (0,jsx_runtime.jsx)("kbd", {
            className: t11,
            children: t12
        });
        $[21] = t11;
        $[22] = t12;
        $[23] = t13;
    } else {
        t13 = $[23];
    }
    const shortcut = t13;
    let t14;
    if ($[24] === Symbol.for("react.memo_cache_sentinel")) {
        t14 = (event_0)=>{
            const isFocus = event_0.type === "focus";
            setFocused(isFocus);
        };
        $[24] = t14;
    } else {
        t14 = $[24];
    }
    const handleFocus = t14;
    let t15;
    if ($[25] !== onSearch) {
        t15 = (event_1)=>{
            const { value: value_0 } = event_1.currentTarget;
            setSearch(value_0);
            onSearch === null || onSearch === void 0 ? void 0 : onSearch(value_0);
        };
        $[25] = onSearch;
        $[26] = t15;
    } else {
        t15 = $[26];
    }
    const handleChange = t15;
    let t16;
    if ($[27] !== router) {
        t16 = (searchResult)=>{
            if (!searchResult) {
                return;
            }
            inputRef.current.blur();
            const [url_0, hash] = searchResult.url.split("#");
            const isSamePathname = location.pathname === url_0;
            if (isSamePathname) {
                location.href = "#".concat(hash);
            } else {
                router.push(searchResult.url);
            }
            setSearch("");
        };
        $[27] = router;
        $[28] = t16;
    } else {
        t16 = $[28];
    }
    const handleSelect = t16;
    let t17;
    if ($[29] !== className) {
        t17 = (0,clsx/* default */.Z)("nextra-search", "x:relative x:flex x:items-center", "x:text-gray-900 x:dark:text-gray-300", "x:contrast-more:text-gray-800 x:contrast-more:dark:text-gray-300", className);
        $[29] = className;
        $[30] = t17;
    } else {
        t17 = $[30];
    }
    let t18;
    if ($[31] !== handleChange || $[32] !== placeholder || $[33] !== props || $[34] !== search) {
        t18 = /* @__PURE__ */ (0,jsx_runtime.jsx)(Bo, {
            spellCheck: false,
            autoComplete: "off",
            type: "search",
            ...props,
            ref: inputRef,
            className: _temp4,
            onChange: handleChange,
            onFocus: handleFocus,
            onBlur: handleFocus,
            value: search,
            placeholder
        });
        $[31] = handleChange;
        $[32] = placeholder;
        $[33] = props;
        $[34] = search;
        $[35] = t18;
    } else {
        t18 = $[35];
    }
    let t19;
    if ($[36] !== shortcut || $[37] !== t17 || $[38] !== t18) {
        t19 = /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", {
            className: t17,
            children: [
                t18,
                shortcut
            ]
        });
        $[36] = shortcut;
        $[37] = t17;
        $[38] = t18;
        $[39] = t19;
    } else {
        t19 = $[39];
    }
    let t20;
    if ($[40] === Symbol.for("react.memo_cache_sentinel")) {
        t20 = {
            to: "top end",
            gap: 10,
            padding: 16
        };
        $[40] = t20;
    } else {
        t20 = $[40];
    }
    let t21;
    if ($[41] !== error || $[42] !== isLoading || $[43] !== results) {
        t21 = (0,clsx/* default */.Z)("nextra-search-results", "nextra-scrollbar x:max-md:h-full", "x:border x:border-gray-200 x:text-gray-100 x:dark:border-neutral-800", "x:z-30 x:rounded-xl x:py-2.5 x:shadow-xl", "x:contrast-more:border x:contrast-more:border-gray-900 x:contrast-more:dark:border-gray-50", "x:backdrop-blur-md x:bg-nextra-bg/70", "x:motion-reduce:transition-none", "x:origin-top x:transition x:duration-200 x:ease-out x:data-closed:scale-95 x:data-closed:opacity-0 x:empty:invisible", error || isLoading || !results.length ? [
            "x:md:min-h-28 x:grow x:flex x:justify-center x:text-sm x:gap-2 x:px-8",
            error ? "x:text-red-500 x:items-start" : "x:text-gray-400 x:items-center"
        ] : "x:md:max-h-[min(calc(100vh-5rem),400px)]!", "x:w-full x:md:w-[576px]");
        $[41] = error;
        $[42] = isLoading;
        $[43] = results;
        $[44] = t21;
    } else {
        t21 = $[44];
    }
    let t22;
    if ($[45] !== deferredSearch || $[46] !== emptyResult || $[47] !== error || $[48] !== errorText || $[49] !== isLoading || $[50] !== loading || $[51] !== results) {
        t22 = error ? /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(SvgGithubNote, {
                    height: "1.25em",
                    className: "x:shrink-0"
                }),
                /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", {
                    className: "x:grid",
                    children: [
                        /* @__PURE__ */ (0,jsx_runtime.jsx)("b", {
                            className: "x:mb-2",
                            children: errorText
                        }),
                        error
                    ]
                })
            ]
        }) : isLoading ? /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(SvgSpinner, {
                    height: "20",
                    className: "x:shrink-0 x:animate-spin"
                }),
                loading
            ]
        }) : results.length ? results.map(_temp5) : deferredSearch && emptyResult;
        $[45] = deferredSearch;
        $[46] = emptyResult;
        $[47] = error;
        $[48] = errorText;
        $[49] = isLoading;
        $[50] = loading;
        $[51] = results;
        $[52] = t22;
    } else {
        t22 = $[52];
    }
    let t23;
    if ($[53] !== t21 || $[54] !== t22) {
        t23 = /* @__PURE__ */ (0,jsx_runtime.jsx)(ko, {
            transition: true,
            anchor: t20,
            className: t21,
            children: t22
        });
        $[53] = t21;
        $[54] = t22;
        $[55] = t23;
    } else {
        t23 = $[55];
    }
    let t24;
    if ($[56] !== handleSelect || $[57] !== t19 || $[58] !== t23) {
        t24 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(kt, {
            onChange: handleSelect,
            children: [
                t19,
                t23
            ]
        });
        $[56] = handleSelect;
        $[57] = t19;
        $[58] = t23;
        $[59] = t24;
    } else {
        t24 = $[59];
    }
    return t24;
};
const Result = (t0)=>{
    const $ = (0,dist.c)(8);
    const { data } = t0;
    let t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = (0,clsx/* default */.Z)("x:mx-2.5 x:mb-2 x:not-first:mt-6 x:select-none x:border-b x:border-black/10 x:px-2.5 x:pb-1.5 x:text-xs x:font-semibold x:uppercase x:text-gray-600 x:dark:border-white/20 x:dark:text-gray-300", "x:contrast-more:border-gray-600 x:contrast-more:text-gray-900 x:contrast-more:dark:border-gray-50 x:contrast-more:dark:text-gray-50");
        $[0] = t1;
    } else {
        t1 = $[0];
    }
    let t2;
    if ($[1] !== data.meta.title) {
        t2 = /* @__PURE__ */ (0,jsx_runtime.jsx)("div", {
            className: t1,
            children: data.meta.title
        });
        $[1] = data.meta.title;
        $[2] = t2;
    } else {
        t2 = $[2];
    }
    let t3;
    if ($[3] !== data.sub_results) {
        t3 = data.sub_results.map(_temp7);
        $[3] = data.sub_results;
        $[4] = t3;
    } else {
        t3 = $[4];
    }
    let t4;
    if ($[5] !== t2 || $[6] !== t3) {
        t4 = /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                t2,
                t3
            ]
        });
        $[5] = t2;
        $[6] = t3;
        $[7] = t4;
    } else {
        t4 = $[7];
    }
    return t4;
};
function _temp(o) {
    return o.data();
}
function _temp2(r) {
    const url = r.url.replace(/\.html$/, "").replace(/\.html#/, "#");
    return {
        ...r,
        url
    };
}
function _temp3(newData) {
    return {
        ...newData,
        sub_results: newData.sub_results.map(_temp2)
    };
}
function _temp4(t0) {
    const { focus } = t0;
    return (0,clsx/* default */.Z)("x:rounded-lg x:px-3 x:py-2 x:transition-all", "x:w-full x:md:w-64", "x:text-base x:leading-tight x:md:text-sm", focus ? "x:bg-transparent x:nextra-focus" : "x:bg-black/[.05] x:dark:bg-gray-50/10", "x:placeholder:text-gray-600 x:dark:placeholder:text-gray-400", "x:contrast-more:border x:contrast-more:border-current", "x:[&::-webkit-search-cancel-button]:appearance-none");
}
function _temp5(searchResult_0) {
    return /* @__PURE__ */ (0,jsx_runtime.jsx)(Result, {
        data: searchResult_0
    }, searchResult_0.url);
}
function _temp6(t0) {
    const { focus } = t0;
    return (0,clsx/* default */.Z)("x:mx-2.5 x:break-words x:rounded-md", "x:contrast-more:border", focus ? "x:text-primary-600 x:contrast-more:border-current x:bg-primary-500/10" : "x:text-gray-800 x:dark:text-gray-300 x:contrast-more:border-transparent", "x:block x:scroll-m-12 x:px-2.5 x:py-2");
}
function _temp7(subResult) {
    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(Uo, {
        as: api_link["default"],
        value: subResult,
        href: subResult.url,
        className: _temp6,
        children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", {
                className: "x:text-base x:font-semibold x:leading-5",
                children: subResult.title
            }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", {
                className: (0,clsx/* default */.Z)("x:mt-1 x:text-sm x:leading-[1.35rem] x:text-gray-600 x:dark:text-gray-400 x:contrast-more:dark:text-gray-50", "x:[&_mark]:bg-primary-600/80 x:[&_mark]:text-white"),
                dangerouslySetInnerHTML: {
                    __html: subResult.excerpt
                }
            })
        ]
    }, subResult.url);
}



/***/ }),

/***/ "(app-pages-browser)/../../node_modules/nextra-theme-docs/dist/style.css":
/***/ (function() {

// extracted by mini-css-extract-plugin

/***/ })

}]);